<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>802.11AX QTP（Quiet Time Period）和QP</title>
      <link href="posts/3b63b924.html"/>
      <url>posts/3b63b924.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="序言">1 序言</h1><p>QTP（Quiet Time Period）是802.11ax中新引入的技术，而QP（Quiet Period）是802.11协议初始就有的一个技术，两者都是在802.11协议中比较冷门的一个技术。在笔者的认知中，这两个技术最大的用处就是为了兼容，毕竟是商业协议，各种场景都需要考虑到。所以本文仅仅做一个笔记记录下。</p><h1 id="信道静默QP（Quiet-Period）">2 信道静默QP（Quiet Period）</h1><p>这里Quiet Period我们翻译成信道静默，这是参考802.11权威指南的翻译。我们知道802.11协议是工作在2.4GHz和5GHz频段的，这个频段在很多国家是有雷达设备也工作的。为了避免对雷达的干扰，802.11协议中采用了TPC和DFS两项技术。然而，究竟周边有没有雷达设备呢，这个时候实际上要802.11设备做一个探测的。</p><p>但是由于无线网络传输本身会影响探测结果。此时，我们就需要把整个网络静默一段时间，也就是不允许任何的数据包传输，让网络去检测周围有没有雷达信号。这个机制就是QP（Quite Period）机制。</p><p>QP时间是一个周期的时间，该周期间隔是通过Beacon或者Probe Response中的Quiet Element元素进行安排的。而QP时间的保护是通过NAV机制来实现的，这里是通过Quiet Element来实现NAV，有点类似于CFP时间可以由CF Parameter Set里面元素设置的一样。</p><p><img "" class="lazyload placeholder" data-original="https://pic2.zhimg.com/80/v2-df6ef2432bb63c077d4ec1572b8599a1_720w.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><p>Quiet Element的结构如上图所示，其中Quiet Period是静默期，代表了QP时间的间隔（单位为几个Beacon间隔，也就是TBTT时间），Quiet Duration为静默持续的Duration时间。Quiet Offset是一个时间偏移，一般而言，Quiet时间是紧接着Beacon开始的，停止时间就是Quiet Duration，然而该时间也可以向后延迟，那么延迟的时间就是Quiet offset。</p><h1 id="静默时间QTP（Quiet-Time-Period）">3 静默时间QTP（Quiet Time Period）</h1><p>Quiet Time Period（QTP）我们目前就直译成静默时间。该机制是802.11ax中新引入的，由于802.11ax需要兼容过往的工作模式，其中最主要的就是ad-hoc模式，其他还有相关的P2P，TLS模式等，这一系列通信模式我们成为STA-STA直接通信。STA-STA通信会对密集网络场景的性能造成影响。因此，为了避免STA-STA通信对密集网络的性能影响，我们需要做一个时间调度，所以才有了QTP这个设计。</p><p>QTP是一个兼容类型的设计，其是通过设置了一个NAV保护时间，该保护时间内，基础架构模式的节点都不会通信，把信道让给STA-STA类型的节点，实际上就是进行了时间分配，关于STA-STA模式和基础架构模式下的节点。</p><p><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/80/v2-9cae957acc5324833310b03918591b86_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><p>参考：IEEE 802.11-16/1459r0</p><p>如上图所示，这里有三个帧，QTP Request，QTP Response以及QTP Setup。在802.11ax中，网络的控制基本是掌握在AP手里的，这点是802.11ax的一个特点。因此，待传输的P2P节点首先需要向AP发送QTP Request帧，申请QTP传输。如果AP同意的话，那么AP会向其反馈QTP Response，与此同时，该AP还会向其余所有节点广播QTP Setup，这些节点收到QTP Setup后，实际上就被设置为了NAV状态。此时，收到QTP Response的节点知道信道已经被预约好了，可以直接进行一次P2P传输了，传输完成后，P2P的接收节点会反馈ACK。</p><p>这里的QTP Setup可以按照802.11ax的帧格式发送，如下图</p><p><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/80/v2-81473ef0bee6d98caa750043b0d26422_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><p>此时，由于传统的802.11节点无法识别该802.11ax的帧（HE PPDU），所以这些传统的节点不会被置为NAV状态，只有802.11ax的节点才会。</p><p>如果是按照传统的802.11帧的形式发送QTP Setup，那么所有的节点都会在QTP时间被设置为NAV状态，如下图：</p><p><img "" class="lazyload placeholder" data-original="https://pic1.zhimg.com/80/v2-0fa5064049fe0afffda1ea9c18e9bd0c_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><p>以上，我们简单阐述了QTP技术的应用场景。主要是协议目前已经很复杂了，概念较多，尤其是QTP和QP这两个概念，因此做一个笔记记录下。</p>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11AX TXOP时间设置和动态分片技术</title>
      <link href="posts/a86949a4.html"/>
      <url>posts/a86949a4.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="序言">1 序言</h1><p>前面已经介绍过了UL/DL-OFDMA的接入机制。下行接入是AP分配的，上行接入过程包含两种：(1) 允许竞争的UORA; (2) 无竞争，完全是由AP分配的模式。</p><p>无论在上行还是下行的OFDMA接入机制中，都可以简单概述成：先发送一个TF帧，AP会在这个TF帧中指定用户所占据的RU，或者指定特定的RU让用户做竞争接入。</p><p>该TF帧会启用TXOP机制，换言之，它会设置信道在一定时间内为NAV状态，从而让AP获得更高等级的调度权。然而，一个基本问题就引发了，这个TXOP时间是怎么设置的，有没有什么限定？因此，本文简单讨论了这个一个问题，以及该问题所需要引入的新技术，动态分片技术。</p><h1 id="UL-DL-OFDMA接入过程">2 UL/DL-OFDMA接入过程</h1><p>首先回顾下在802.11ax中的UL-OFDMA过程，ax中的接入过程最简化可以为三个帧，TF，UP-OFDMA PPDU，MU-BlockACK，如下图所示：</p><p><img "" class="lazyload placeholder" data-original="https://pic1.zhimg.com/80/v2-b6d66730777b25fec8f34ec1d4655dc4_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><p>在首先发送的Trigger帧中，会开启一个TXOP时间，该时间内，所有的节点都被强制设置为NAV，即虚拟载波监听状态，无法主动的竞争信道。Trigger帧是一个触发传输的帧，其包含了节点上行传输所需要的设置信息，包含了MCS和传输功率控制，如下图所示：</p><p><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-bea350aff7d90031ca73c7d5a0b729df_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><p>其中的User ID对应用户的AID，对应AID的用户会在该资源块RU上进行对应的上行传输，可以通过AID=STA来指定特定节点，也可通过AID=RA（具体可以是0，也可以是2045）来指定该RU用于随机接入。</p><p>每一个RU才还被指定了MCS以及其对应的数据流数目，即SS Allocation，以及MCS，这是802.11协议中首次引入的机制，AP可以控制节点的发送速率。</p><h1 id="UL-DL-OFDMA的TXOP时间设置">3 UL/DL-OFDMA的TXOP时间设置</h1><p>TXOP机制是首次在802.11e中被引入，其允许“一次竞争，多次传输”。即在节点竞争胜利后，可以持续占用信道一段时间。标准的TXOP时间是和数据包的业务优先级AC有关的，并在802.11e中是给出了默认值，如下图所示（不同协议版本的TXOP时间设置不同）：</p><p><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/80/v2-2741ff864c97be812b9a03e06c7c9dee_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="TXOP默认值"></p><p>在802.11后期的发展中，TXOP成为一种机制。在一些其他用处下，比如802.11ax中的OFDMA接入过程，其TXOP的时间不是按照上图的默认机制，而是和传输数据包的大小有关。</p><img "" class="lazyload placeholder" data-original="/posts/a86949a4/image-20210425151244812.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Setting for single and multiple protection under enhanced distributed channel access (EDCA)" style="zoom:67%;"><p>从上述协议可以得到，<strong>TXOP时间=TF+CTS+PPDU+ACK</strong></p><p>该TXOP时间的核心设置为一次对应传输的PPDU时间（即HE_TB_PPDU）。</p><ul><li>下行：由于传输方是AP，所有AP知道待传输的数据包大小，并且所有的RU传输速率都是已经设定好的，所以该PPDU传输时间是一个固定值，可以设置。</li><li>上行：因为在传统的802.11中，AP是无法知道节点上行数据包的对应情况的。传统的802.11中，AP不仅预知节点的数据包情况（比如包大小之类），同时期物理层传输参数也是无法预知的（比如传输的速率）。</li></ul><p>那么在802.11ax中，需要引入新的机制，已知一些信息才可以确定性的设置对应传输的TXOP时间。所以协议中有两个设置：</p><ol><li>OFDMA传输时，AP发送Trigger帧，指定各个RU对应的MCS和NSS，确定传输速率。</li><li>通过BSR，BSRP机制，AP获取节点对应的buffer信息，确定数据包大小。</li></ol><p>基于以上两点，AP可以设置该传输所需要的PPDU时间。</p><h1 id="动态帧分片（Dynamic-Fragmentation）">4 动态帧分片（Dynamic Fragmentation）</h1><p>除了基于BSR机制的上行传输机制外，还有一种基于随机接入的上行机制UORA。</p><p>在UORA情况下，假设AP设置的时间为A。而节点上行传输所需要的时间为B。那么会分两种情况：</p><ul><li>如果A&gt;B，可以实现，但是效率低下，节点传输完自己数据包之后，需要padding，充填一些冗余数据，将时间填充满A。</li><li>如果A&lt;B，AP给出的时间不够一个数据包传输的，在传统的TXOP中，是不传输（也就是TXOP最后的时间片段，是否能够传输一个数据帧）。在802.11ax中，这不仅仅是一个效率问题了，而是出现这种情况，一个上行帧都无法传输出去，造成的问题比较大。</li></ul><p>所以在802.11ax中，为了解决该问题，引出了一个新的设计即为动态帧分片技术。</p><p>在802.11ax中，传输都是由AP同意调度的。无论上行还是下行，AP都会为节点分配好传输所用的RU数目，传输速率MCS之类。</p><p>然而，在OFDMA传输过程时，传输时间也是由AP设定的。标准情况下，AP可以通过BSR机制，基于节点的待传数据包大小设置。然而，在UORA传输时则无法准确设置。此时有可能会出现，节点待传数据所需时间会大于TXOP时间，比如节点传输需要30ms，但是txop时间只有20ms，此时我们就需要引入动态帧分片。动态帧分片是针对于传统的静态帧分片技术做个补充。</p><p>其实除了上述这一个角度，我们可以理解动态帧分片技术的必要性。我们还可以换一个角度理解，也就是结合帧聚合技术理解动态帧分片。</p><p>![TXOP时间较长](802.11AX TXOP时间设置和动态分片技术/v2-6d78d6e905e0bc05dfff60c8ef97d662_720w.jpg)</p><p>如上图所示，如果TXOP时间较长，那么多余的部分是需要padding的。这一块padding能不能传输内容呢？在最传统的802.11中是不可以的，但是在帧聚合模式下，这是一个特例。</p><p>如果物理层传输的PPDU对应的是一个A-MPDU的话，也就是一个聚合帧的话。那么在传输过程前，节点可以决定我的聚合长度是多少。此时，如果节点一直传输的TXOP时间，并且剩余所需要的Padding的时间，那么此时节点可以利用动态帧分片技术，切出来一个短帧来补充这一块需要的Padding片段，从而提升效率。从这个角度而言，动态帧分片也是非常有价值的一个设计。</p><p>在协议中，动态帧分片一共包含3个等级：</p><p>![Fragmentation and defragmentation](802.11AX TXOP时间设置和动态分片技术/image-20210425163638902.png)</p><p>这三个实际上是针对不同场景的帧分片，比如说针对于非帧聚合模式下，以及针对于帧聚合模式下的帧分片。</p>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11AX TWT节能机制</title>
      <link href="posts/58ddbf13.html"/>
      <url>posts/58ddbf13.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="序言">1 序言</h1><p>关于802.11协议的节能机制，包含了PSM，APSD，PSMP以及SMPS。在802.11ax中，为了在速率提高的场景下，降低所花费的功耗，协议采用了一种新的节能机制TWT（Target Wake Time）。TWT首先是在802.11ah中被引入的，在802.11ax中又经过一些改良。本文就针对于TWT技术做一个介绍。</p><p>本文参考：</p><ul><li><p><a href="https://www.commscope.com/blog/2018/802.11ax-fundamentals-target-wake-time-twt/?utm_source=ruckus&utm_medium=redirect">802.11ax fundamentals: Target Wake Time (TWT)</a></p></li><li><p><a href="https://www.cleartosend.net/802-11ax-target-wake-time/">CTS 164: 802.11ax Target Wake Time</a></p></li><li><p><a href>Aruba 802.11ax White Paper</a></p></li></ul><h1 id="简介（Target-Wake-Time）">2 简介（Target Wake Time）</h1><p>  TWT定时唤醒机制（<strong>Target Wake Time</strong>，<strong>TWT</strong>）首次出现在802.11ah “Wi-Fi HaLow”标准中，其用于支持大规模物联网环境下的节能工作。随着IEEE 802.11ax标准的发展，TWT的功能获得了进一步的扩展，这使得IEEE 802.11ax标准能够更加优化设备的节能机制，提供更可靠，更节能的传输机制。在802.11ax中，TWT机制在ah的基础上，已经被修改为支持基于触发的上行链路传输，从而扩展了TWT工作的范围。</p><p>  在TWT中，终端和AP之间建立了一张时间表（该时间表是终端和AP协定的），时间表是由TWT时间周期所组成的。通常终端和AP所协商的TWT时间周期包含一个或者多个beacon周期（总体时间比如几分钟，几小时，甚至高达几天）。当终端和AP所协商的时间周期到达后，终端会醒来，并等待AP发送的触发帧，并进行一次数据交换。当本次传输完成后，返回睡眠状态。每一个终端和AP都会进行独立的协商，每一个终端都具有单独的TWT时间周期。AP也可以将终端们根据设定的TWT时间周期进行分组，一次和多个终端进行连接，从而提高节能效率。</p><p>  ![The Target Wake Time mechanism first appeared in the IEEE](802.11AX TWT节能机制/medium.png)</p><p>  如上图所示，User 1和User 2分别和AP协定了两个TWT时间周期，分别为TW1和TW2。终端User 1和User 2默认就工作在睡眠模式下（sleep mode），保持一个较低的功耗。当TWT时间周期到达时，AP会发送一个触发帧（Trigger）给终端，终端进而苏醒并和AP执行数据交换，当数据交换完成后，终端恢复睡眠模式。TWT和传统PSM模式的差别是，终端只在TWT时间开始的时候苏醒，而在PSM模式中，从该beacon周期开始，终端就会通过该beacon帧中的DTIM信息，观察是否AP是否由缓存自己的数据帧，如果有的话，那么就保持苏醒，直到接收完成后，才恢复到睡眠模式。在上图中，如果是传统的PSM的话，若本轮beacon帧中提示有User 1的信息，那么其不会在TW1时间内睡眠，会保持苏醒，直到数据交换完成后，才恢复睡眠。</p><h1 id="三种工作模式">3 三种工作模式</h1><h2 id="Individual-TWT">3.1 Individual TWT</h2><p>  该模式下终端会和AP协商特定的TWT时间，该时间会被存放在AP的时间表中。终端会在特定的时间醒来并和AP进行帧交换。每一个终端仅仅直到自己和AP协商的TWT时间，不需要知道其他终端的TWT时间。Individual TWT还有多种工作模式，比如说显式工作模式。</p><p>  其大致工作流程如下：</p><p>  1、终端想要建立一个TWT连接，其会将自己的节能调度信息告知给AP</p><p>  2、AP将会分配TWT周期，并将该周期反馈给终端</p><p>  3、终端会在指定的TWT周期时苏醒，并和AP进行数据帧交换</p><p>  4、在本轮交换中，会分成显式和隐式两种工作模式</p><p>  ①、显式工作模式</p><p>  在本次数据帧交换中，AP会显式告诉终端，下一轮的TWT周期</p><p>  终端会在新的指定的TWT周期时苏醒，并再一次和AP进行数据帧交换</p><p>  ②、隐式工作模式</p><p>  在本次数据帧交换中，AP不会告诉终端，下一轮的TWT周期 终端会自己计算出下一轮的TWT周期（通过在当前TWT周期上增加一个特定的时间） 终端会在自己计算的TWT周期时苏醒，并再一次和AP进行数据帧交换</p><p>  ![img](802.11AX TWT节能机制/v2-ec145d8747af4677e0b9fba559b01719_720w.png)</p><p>  如上图所示，终端会在苏醒的时候，首先和AP发起一个TWT建立请求，终端和AP协商一个TWT时间（即图中Negotiate a schedule），当协商完成后，终端就进入睡眠状态。在该图上，AP发送Beacon时，也会包含了公开的TWT信息，在Individual TWT工作模式下，该信息终端时不需要的。终端一直保持睡眠状态，直到TWT时间到达。终端苏醒，并接收AP的触发帧，即TWT Trigger。当终端接收到该触发后，其会和AP进行数据帧交互。于此同时，AP会告知终端下一次的TWT时间（在显式TWT中，睡眠间隔是逐次设定的），终端会在新的TWT时间上，定时苏醒，并执行数据帧交换。TWT的一次苏醒间隔有可能是小于一个beacon周期，也有可能是大于一个beacon周期的，相比于传统的PSM，APSD之类的节能方式，更加具有一般性。</p><p>  ![img](802.11AX TWT节能机制/v2-87f88e9269bcd820138de1cd9145e96b_720w.jpg)</p><p>  终端和AP可以关于TWT时间周期进行协商，终端可以要求取消TWT参数，或者向AP请求特定的TWT时间。如果AP统一终端的请求，其会反馈“Accept TWT”。还有多种协商的具体参数，可以参考上图。</p><h2 id="Broadcast-TWT">3.2 Broadcast TWT</h2><p>  广播TWT机制是一种由AP负责管理的工作机制。在该机制下，TWT时间周期是由AP宣告，通常AP会在每一个beacon帧中宣告本轮的TWT时间周期。在一些特殊的情况下，AP也会在其他的管理帧中宣告，比如Association帧，Reassociation帧或者Probe Response帧等等。我们需要注意在Broadcast TWT中，存在加入组和离开组的交互动作，终端需要向AP申请加组才可以执行Broadcast TWT，这个加组交互动作也是通过在终端和AP交换管理帧中，通过携带TWT elements完成的。当终端完成加组后，终端会按照最近接收到的TWT时间周期进行工作，此时这一类型的终端也被叫做“TWT Scheduled STA”，AP被称为“TWT Scheduling AP”。终端在TWT时间周期到达后进行苏醒，AP会发送广播的触发帧，发现哪些终端正在处于苏醒状态（加组后的终端们），并向这些终端发送数据帧，这里由于是广播通信，所以只有AP向节点发送。当AP发送完成后，终端恢复到睡眠状态，直到下一次广播TWT时间到达。通常，这种广播TWT中的时间间隔，我们也称为“TWT SP (Service Period)”。</p><p>  ![img](802.11AX TWT节能机制/v2-64658809cffd8f6a8013f41949ba8a5f_720w.png)</p><p>  如上图所示，AP会在Beacon帧中，进行TWT Broadcast时间周期（即TWT SP时间）的宣告。终端们苏醒并接收该Beacon信息。然后在对应的TWT时间到达时，对应的终端们会提前苏醒，接收AP发送的TWT trigger，以及AP发送的下行数据帧，在此过程中，AP也由可能发送新的一次的TWT Broadcast时间周期（即TWT SP时间）。终端接收完成后，进入睡眠状态，并在新的TWT SP时间到达时，再次苏醒，以后以此类推。</p><h2 id="Opportunistic-PS">3.3 Opportunistic PS</h2><p>  机会PS模式和前面两种工作模式是类似的，但是没有AP和节点的协商过程。AP会在每一个Beacon内，公开宣告一个TWT时间。任意终端可以选择在这个公开TWT时间内进行苏醒，并和AP执行数据帧交换。这个交换可以是单个节点的，也可以是采用OFDMA机制进行交换。</p><p>  ![img](802.11AX TWT节能机制/v2-9c1d1b7a9da20b7c1f9de1c06b23b7be_720w.png)</p><p>  如上图所示，AP在Beacon帧中宣告了一个公开的TWT时间，任意终端都可以直到该TWT时间。当该TWT公开时间到达后，AP会发送触发帧，此时苏醒的节点可以和AP进行交互，并执行数据帧的交换。在图中，由多个节点苏醒，从而触发了一次OFDMA类型的数据帧交互。</p><h1 id="其他节能机制">4 其他节能机制</h1><p>  802.11ax协议对于功耗这一面是很关注的，除了TWT以外，还包含了一些其他的特殊设计，用以节能，并延长终端的电池寿命。这些在IoT场景中都是非常重要的。</p><ul><li><strong>选择性的接收数据帧</strong>：在传统的802.11中，节点需要接收所有的数据帧，即使该数据帧不是自己的，那么也需要接收完成后，检查MAC地址（即BSSID），判断之后才可以丢包。接收无用的数据帧也是要耗费能量的，所以在802.11ax中，节点可以在数据帧的物理层头部就判断，该帧是不是要进行接收的，如果不是需要接收的，那么就可以停止接收，从而节约能量。</li></ul><p>  在802.11ax协议中，这一点的实现是基于新的物理层头部的：</p><p>  ![Timing boundaries for HE PPDU fields if midamble is not present](802.11AX TWT节能机制/image-20210420170741665.png)</p><p>  如上图所示，为一个802.11ax的帧结构，我们红色标出的位置HE-SIG-A是其物理层头部的一部分。在节点接收过程中，节点需要首先接收物理层头部，并完成解调，获取了相应的信息后，才可以进行数据部分的解调。在物理层头部HE-SIG-A字段中，有两个字段我们需要关注：</p><p>  ![image-20210420171108181](802.11AX TWT节能机制/image-20210420171108181.png)</p><p>  ![image-20210420171124117](802.11AX TWT节能机制/image-20210420171124117.png)</p><p>  ![image-20210420171153148](802.11AX TWT节能机制/image-20210420171153148.png)</p><p>  <strong>Uplink/downlink字段（即UL/DL）</strong>：终端可以通过物理层头部的UL/DL字段知道这个帧是由AP发送给节点的，还是由别的节点发送给AP的。由于当前的无线网络基本都是工作在基础架构模式，或者扩展服务集模式，总之该模式都是有中心节点AP的，任何的流量转发都需要经过AP，节点和节点直接无法直接交换数据。这种情况下，节点要不是向AP发送，要不是接收AP的数据帧。所以当一个节点通过HE-SIG-A中的UL/DL字段判断该数据帧是其他节点发送的话（即UL状态），那么其就不需要接收，反之如果是DL状态的话，那么就表示是AP发送的下行帧，所以需要接收。</p><blockquote><p>Remark：由于下行数据帧有可能是广播或者组播，也有可能是单播，所以无论下行数据帧是不是自己的，节点都需要接收。节点只有在识别到是其他上行流量时，才会停止接收。</p></blockquote><p>  <strong>BSS Color字段</strong>：在多AP的场景下，节点仅仅会接收感兴趣的AP（比如本地关联的AP）信息，如果非感兴趣的下行信息，其是可以不接收，从而节能的。BSS Color字段也是在物理层头部HE-SIG-A中（如上图所示）。在802.11ax中，不同的AP可以通过BSS Color字段来进行识别，每一个AP都有预设的BSS Color，节点也知道不同AP对应的BSS Color。节点如果识别到非感兴趣的帧，那么会停止接收帧，并返回睡眠模式。</p><ul><li><strong>发送功率限制</strong>：在OFDMA接入模式中，AP会通过发送Trigger帧通知不同节点，其上行传输所用的功率和MCS。一方面是为了优化接收信号的性能，即为了执行OFDMA，需要不同节点的信号到AP处近似相等，否则会出现远近效应。另外一方面，可以优化能耗，让部分节点不需要满功率发送，从而节能。</li></ul><p>  ![User Info field format](802.11AX TWT节能机制/image-20210420171330790.png)</p><p>  如上图所示，在Trigger帧中的User Info Field中，UL MCS指示了节点发送时候的速率，已经UL Target RSSI指示了AP端期望接收的功率，节点根据该位计算出合适自己的发送功率。由于这种功率调节机制，节点不会一直以满功率进行传输，从而进行节能。</p><ul><li><strong>OMI模式（Operating mode indication）</strong>：我们之前介绍过OMI模式，该模式节点和AP之间会协定传输参数，以及是否采用OFDMA形式进行传输。OMI还分成“Receive operating mode”（ROM），“Transmit operating mode”（TOM）。</li></ul><p>  ![img](802.11AX TWT节能机制/v2-2e58fd82e3d87a87b2962f705e60337b_720w.png)</p><p>  上图给出了OMI模式中可以控制的参数。通过OMI可以控制数据传输时的信道带宽，空间流数目，工作模式，OMI可以限定工作模式，对于IoT场景而言，节点可以用OMI来限定发送和接收数据时的带宽以及空间流的数目，从而实现节能的目的。</p><ul><li><strong>20MHz-only工作模式</strong>：支持该模式的设备只能够以20MHz的方式，接入2.4GHz或者5GHz频段的AP，具体时接入主信道（即Primary Channel）。限定节点的工作带宽，可以减少大带宽信号所使用的功率，从而实现节能。</li></ul><p>  ![20 MHz-only Wi-Fi 6 Client](802.11AX TWT节能机制/image-20210420171548215.png)</p><p>  ![img](802.11AX TWT节能机制/v2-81c02ffb80b19412961417ccda6574b0_720w.jpg)</p><p>  如上图所示，我们认为这里有4个20MHz的信道，对于接入者而言，只有1个主信道（即Primary Channel）是信道3，然后还有3个从信道（secondary Channel)。当节点启用20MHz-only时，其只会在Primary 20MHz信道上工作，该工作可以是采用OFDM技术，也可以使用OFDMA技术，即占据部分的子载波。在Secondary Channel上，节点不会进行工作。</p><h1 id="帧格式">5 帧格式</h1><p>  ![image-20210421161836600](802.11AX TWT节能机制/image-20210421161836600.png)</p><p>  ![image-20210421161824717](802.11AX TWT节能机制/image-20210421161824717.png)</p><p>  ![image-20210421161805490](802.11AX TWT节能机制/image-20210421161805490.png)</p><p>  ![image-20210421161853921](802.11AX TWT节能机制/image-20210421161853921.png)</p><p>  ![image-20210421165400875](802.11AX TWT节能机制/image-20210421165400875.png)</p><p>  ![image-20210421165414882](802.11AX TWT节能机制/image-20210421165414882.png)</p>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11AX 双重NAV技术</title>
      <link href="posts/30d166dc.html"/>
      <url>posts/30d166dc.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="序言">1 序言</h1><p>NAV是802.11中最基本的MAC层元素之一，在802.11协议中起着非常重要的功能，而且先行协议下，基本上所有的兼容性机制都围绕的NAV展开。在802.11ax中，引入了双重NAV技术（Dueling NAVs）进一步扩展其功能，本文即针对这项技术做一个展开。</p><p>参考资料：</p><ul><li><a href="https://note-on-clouds.blogspot.com/2019/07/new-wifi-dueling-navs-in-80211ax.html">Dueling NAVs in 802.11ax</a></li><li><a href="https://www.programmersought.com/article/19873582929/">802.11ax Preview 9: Dual NAV technology (Dueling NAVs)</a></li></ul><h1 id="802-11ax中的双重NAV技术（Dueling-NAVs）">2 802.11ax中的双重NAV技术（Dueling NAVs）</h1><p>Wi-Fi使用两种载波侦听方法来确定信道是否繁忙，若繁忙那么要延迟进行传输。空闲信道评估（clear channel assessment，CCA）是检测信道是否繁忙的物理机制，同时在WiFi中，还存在一种虚拟载波监听机制，其和物理载波监听机制并行工作。虚拟载波侦听机制的核心是网络分配矢量（network allocation vector ，NAV）的定时器机制。</p><p>在802.11ax中已经引入了BSS Coloring机制，以适应在OBSS环境下，自适应调节空闲信道评估阈值（即adaptive CCA)，以增加空间信道的复用率，提供更多并行传输的可能性。</p><p>在BSS Coloring中引入的adaptive CCA也可以和虚拟载波监听的NAV组合使用，由于adaptive CCA中已经引入了两个不同的监测阈值，那么意味着其和NAV机制组合使用时，也需要两个独立的NAV定时器。在802.11ax中，目前已经新定义了两个NAV定时器：BSS内部的NAV定时器（intra-BSS NAV timer），和基本NAV定时器（basic NAV timer）。</p><ul><li><strong>BSS内部NAV定时器（intra-BSS NAV timer）</strong>：其只够通过来自于同一个BSS内部的终端来设置，通过BSS内部终端传输的Duration/ID字段来设置NAV定时器的数值。</li><li><strong>基本NAV定时器（basic NAV timer）</strong>：其可由来自于不同BSS区域的终端来设置，也是根据这些终端传输的Duration/ID字段来设置NAV定时器的数值。</li></ul><p>以上两个NAV定时器同时工作，如果由<strong>任意一个NAV设置为非0</strong>，也就是正在定时中，那么就认为信道是忙，正在被占据。</p><p>引入了两个NAV定时器是有益的，尤其在密集场景下。802.11ax的终端不仅仅需要保护其在BSS内部 （intra-BSS）传输的帧，还需要避免来与于其他BSS（即BSS间，inter-BSS）传输的干扰。</p><p>![image-20210422141942909](802.11AX 双重NAV技术/image-20210422141942909.png)</p><p>如上图所示，802.11ax AP-1发送了一个RTS帧（包含设置NAV=200us），以保护其与终端STA#1的数据帧交换。因为STA#1与AP-1相关联，即STA#1是AP-1这个BSS内部的终端（称该BSS为BSS#1），所以STA#1将<strong>BSS内部NAV定时器</strong>设置为200μs。然而，在数据帧交换期间，属于BSS#1（即AP-1）的终端（即STA#1）还可以收到不同BSS的客户端传递的RTS帧。比如终端STA#2传输的RTS帧（包含Duration=125us），其也会设置STA#1的NAV定时器，此时由于是不同BSS的终端设置，STA#1会将其<strong>基本NAV定时器</strong>设置成125us。在上图中，STA#1的内部NAV定时器首先倒数到0，但是其基本NAV定时器还没有倒数到0，还将继续递减。在此两个NAV定时器没有全部倒数至0之前，STA#1无法进行新的一轮发送。这种双重NAV的机制可以保证BSS#2中，帧的交换不受到干扰。</p>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11AX AMPDU</title>
      <link href="posts/c12a6ff1.html"/>
      <url>posts/c12a6ff1.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="序言">1 序言</h1><p>帧聚合（Frame Aggregation）是802.11中为了提升传输效率的一种方式，自802.11n开始被引入，本文介绍一下802.11ax中对帧聚合的进一步使用。</p><p>参考资料：</p><ul><li><a href="https://www.extremenetworks.com/extreme-networks-blog/802-11ax-frame-aggregation-enhancements/">802.11ax Frame Aggregation Enhancements</a>。</li></ul><h1 id="802-11ax帧聚合增强功能">2 802.11ax帧聚合增强功能</h1><p>802.11n和802.11ac的主要目标是提高物理层传输速率和吞吐量。在802.11n/ac中，帧聚合(Frame Aggregation)是一个提高空口效率的关键技术。帧聚合是将多个无线帧组合成单个更长的无线帧传输，然后一次进行传输。在MAC层的竞争开销不变的情况下（由于用一个帧代替多个帧，所以只有一次竞争开销），增加了传输的内容，导致减少额外的空口时间。</p><p>为了理解帧聚合技术，需要知道两个概念：MSDU和MPDU。SDU和PDU是两个基本单元，M代表MAC层。在802.11中，MAC服务数据单元（MAC Service Data Unit <em>,</em> MSDU）是802.11数据帧的第3-7层有效载荷(即Payload)，MSDU仅仅是Payload部分，没有Header。 802.11 MAC协议数据单元（MAC Protocol Data Unit ,MPDU）本质是除了Payload以外，还包含了MAC层的数据包头部，即MDPU包含了MAC层头部以及MSDU。</p><p>802.11n定义了两种帧聚合方法：</p><ul><li>针对MSDU的帧聚合（A-MSDU），将多个MSDU组合成一个数据帧，共享一个MAC头部</li><li>针对MPDU的帧聚合（A-MPDU），将多个MPDU组合，其结构如下图所示</li></ul><p>![Multi-TID AMPDU](802.11AX AMPDU/image-20210420164520531.png)</p><p>当节点接收到聚合帧后，采用块ACK（Block ACK）的形式进行反馈。</p><p>在实际场景中，A-MPDU最为常用。因为其采用Block ACK，重传开销较少。因此，在802.11ac中，仅仅定义了A-MPDU（即没有定义A-MSDU了）。802.11ac的数据帧仅仅采用A-MPDU进行聚合传输。所有的802.11ac数据帧都是采用A-MPDU的形式传输的。尽管802.11ac传输采用A-MPDU，但是需要被指出的是A-MSDU可以和A-MPDU一起使用，一个A-MPDU的Payload部分可以携带A-MSDU，这样两者就是结合使用了。</p><p>802.11ax在物理层定义了多种增强功能，比如引入OFDMA提高效率。另外，实际上在MAC层上还存在一种有效增强效率的机制，即帧聚合技术的改进。</p><p>在802.11ax之前，A-MPDU中每个MPDU必须都具有相同的802.11e QoS接入类别，也就是所有的MPDU都要是同一个优先级的流量。比如高优先级的MPDU（比如语音）不能和其他相对低优先级（比如Best Effort或Video）的MPDU组成聚合帧进行传输。 <strong>802.11ax引入多流量标识符</strong>（Multi-Traffic Identifier，Multi-TID）的A-MPDU，其允许来自相同或不同QoS接入类别流量进行聚合，其通过流量标识符（TID）进行识别。通过组合不同QoS流量类别的MPDU，其能更有效的让802.11ax终端进行聚合传输，减少竞争开销，提高吞吐量，最终提高整体网络效率。</p>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11AX SRP空间复用和Adaptive-CCA</title>
      <link href="posts/cef8c64f.html"/>
      <url>posts/cef8c64f.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="序言">1 序言</h1><p>BSS Coloring技术是802.11ax中引入，目的进一步优化空间复用（Spatial Reuse Parameter）。在前文讨论过关于BSS Coloring技术，但是关于如何基于BSS Coloring进行Spatial Reuse Parameter，还需要额外介绍Adaptive-CCA机制。本文就关于这两个问题做一个阐述。</p><p>本文参考自：</p><ul><li><a href="/books/Future-and-Indoor-Networks.pdf">Future Indoor Networks: The role of Wi-Fi and its evolution - nokia bell lab</a></li><li><a href="/books/IEEE-802.11ax-Highly-Efficient-WLANs-for-Intelligent-Information-Infrastructure.pdf">IEEE 802.11ax: Highly Efficient WLANs for Intelligent Information Infrastructure</a></li><li><a href="https://www.ni.com/zh-cn/innovations/white-papers/16/introduction-to-802-11ax-high-efficiency-wireless.html">Introduction to 802.11ax High-Efficiency Wireless</a></li><li><a href="/books/Draft_P802.11ax_D8.0.pdf">Draft P802.11ax_D8.0.pdf</a></li><li><a href="https://www.wifi-professionals.com/2019/07/bss-colouring-or-spatial-reuse-802-11ax-aka-wifi6">BSS COLOURING OR SPATIAL REUSE (802.11AX AKA WIFI6)</a></li></ul><h1 id="SRP空间复用（Spatial-Reuse-Parameter）">2 SRP空间复用（Spatial Reuse Parameter）</h1><p>在802.11ax中，基于BSS Coloring，我们可以区分出Inter-BSS和Intra-BSS。如果现在一个Inter-BSS的节点检测到信道是忙的，但是其知道这个信道不是自己BSS正在进行传输，那么其可以认为信道是idle状态，进而继续backoff。如果backoff到0，那么其可以进行传输。</p><p>![image-20210407163921854](802.11AX SRP空间复用和Adaptive-CCA/image-20210407163921854.png)</p><p>如上图所示，假设一个BSS的AP发送了一个SR-enable trigger frame（协议中称为SRP PPDU），代表当前的AP是允许一个SRP传输的。目前我理解的SRP仅仅支持AP上行接收的情况。AP发送完SRP TF帧后，其执行自己BSS内的一次传输，比如说一次上行传输。此时，如果一个支持SRP技术的Inter-BSS STA，也就是其他BSS Color下的节点，收到该SRP TF帧后。其会采用adaptive-CCA机制进行信道检测。如果其在adaptive-CCA的阈值下（即OBSS_PD阈值）检测信道是idle的，那么其可以继续执行backoff的操作。当backoff到0以后，其就可以执行一次数据的传输。</p><p>SR-enable的标志位应该是在PHY头部的HE-SIG-A1里面的Spatial Reuse field，这里面一共有4个field，可以设置disable SRP技术，也可以设置对应延迟或者具体的adaptive-CCA阈值等。</p><p>另外需要注意的是，这里允许传输的inter-BSS STA的数据帧大小也是有限制的。在一开始AP发送的TF帧中，实际上是包含了duration参数设置，代表其上行接收PPDU过程所需要的时间。inter-BSS需要在该Duration时间内完成SRP空间复用的传输，这里可能又会应用到动态帧分片技术了。</p><p>SRP技术实际上是一种利用捕获效应的空间复用技术，简单理解就是，如果当前AP的接收信号质量不错，不容易被干扰。那么此时就允许在该网络内，一个其他BSS的节点传输。由于本身我的信号强度够强，所以不会受到其他节点的干扰。该技术可以利用的核心机制就是adaptive-CCA机制，AP可以控制CCA的阈值，从而控制让部分节点（也就是不对自己产生干扰的节点）进行空间复用。</p><h1 id="Adaptive-CCA（自适应CCA）">3 Adaptive-CCA（自适应CCA）</h1><p><strong>CCA技术是</strong>802.11协议用来检测信道是否有数据包在传输的<strong>物理载波监听技术</strong>。</p><p>802.11ax除了传统的ED_Threshold和CS_Threshold，进一步引入了OBSS_PD这个参数。</p><p>![Using Color Codes for Clear Channel Assessment](802.11AX SRP空间复用和Adaptive-CCA/image-20210407180033598.png)</p><p>上面左图描述的是传统802.11的情况，其中CCA-Energy Detection对应到EDThreshold（-82 dBm），CCA-Signal Detection对应到CS_Threshold（-62 dBm）。右边描述的是802.11ax中的情况，我们可以看到起CCA_SD实际上一个新的阈值（协议命名是OBSS_PD），其高于原来的CS_Threshold（-62 dBm），这个阈值是自适应调节的，所以被称为Adaptive-CCA。该阈值的目的就是用来区分，目前CCA检测到的数据帧是不是本BSS域内的。<strong>按照SRP的规则，如果STA检测到该数据帧不是本BSS的，而且STA的信号强度是小于该Adaptive-CCA的，那么可以认为信道是idle，可以继续backoff</strong>。</p><p>![Colouring-decision-process](802.11AX SRP空间复用和Adaptive-CCA/Colouring-decision-process.png)</p><p>上面两个图进行分析：</p><ul><li>首先STA进行能量检测</li><li>如果RSSI小于-82，则认为没有数据在传输，信道空闲。</li><li>如果RSSI大于-82，说明有数据在传输，开始PLCP解调，</li><li>如果PLCP解调失败，那么等待EIFS，等待完挂起到当前数据帧的传输结束</li><li>如果PLCP成功，那么它将读取框架标题以查看框架的颜色。</li><li>如果其颜色相同，说明信道忙，有数据，开始接收数据。如果要发送数据，则必须经过正常的CSMA / CA过程。</li><li>如果颜色与其自己的BSS不同，则说明它是一个BSS间帧，不需要接收该数据帧，但如果要发送数据，则需要与动态CCA值进行比较</li><li>如果RSSI大于OBSS_SD，说明OBSS的传输对MYBSS的干扰较大，标记MYBSS信道忙，不进行SR传输。</li><li>如果RSSI小于OBSS_SD，说明OBSS的传输对MYBSS的干扰较小，标记MYBSS信道空闲，可以开始backoff，到0时，可以进行上行传输</li><li>此时，还有另一个阈值检查，它检查帧的信号强度是否高于-62或低于。</li></ul><p>在协议中，该OBSS_SD（本文命名有点杂，对应协议是OBSS_PD）是一个范围值，是AP根据网络情况自适应调节的，并且在Spatial Reuse field给出。</p><p>![image-20210407163311302](802.11AX SRP空间复用和Adaptive-CCA/image-20210407163311302.png)</p><p>如上图所示，该范围是在-62dBm和-82dBm之间，也就是对应传统的ED_Threshold和CSThreshold之间。该图上的21dBm描述的参考的发送功率，TXPWR_Ref。</p>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11AX BSS Color</title>
      <link href="posts/bc6a848b.html"/>
      <url>posts/bc6a848b.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="序言">1 序言</h1><p>参考资料：</p><ul><li><a href="https://www.extremenetworks.com/extreme-networks-blog/">What Is BSS Coloring In 802.11ax?</a></li><li><a href="https://www.extremenetworks.com/extreme-networks-blog/what-is-bss-color-in-802-11ax/">What is BSS Color in 802.11ax?</a></li><li><a href="https://www.extremenetworks.com/extreme-networks-blog/how-does-bss-coloring-work-in-802-11ax/">How Does BSS Coloring Work in 802.11ax?</a></li><li><a href="/books/802.11%E2%84%A2-2016.pdf">802.11-2016.pdf</a></li><li><a href="/books/Draft_P802.11ax_D8.0.pdf">Draft P802.11ax_D8.0.pdf</a></li></ul><h1 id="介绍">2 介绍</h1><p>BSS Coloring是最初在802.11ah中引入的一种机制，用于为每个BSS分配不同的“颜色”。该技术目的是增加在密集环境中，无线网络的系统容量，增加BSS之间的频率重用。然而，当前的802.11的MAC层机制，其会导致一个BSS的设备会被同频道的另一个BSS影响，无法同时进行传输，从而对于网络容量没有提升。</p><p>在802.11ax中，BSS Coloring是一种用于解决由于重叠基本服务集（OBSS）提升空间重用率的方法，减少因为重叠BSS导致的MAC层竞争开销。BSS Coloring的目标是提升空间复用，同时不会因为BSS间的干扰而导致节点间PHY层传输速率的降低（即降低MCS值）。802.11ax设备通过向PHY头部添加字段（即BSS Coloring字段）来区分BSS，节点在竞争时，根据检测到物理层头部的BSS Coloring字段来分配MAC层的竞争行为。若BSS Coloring字段信息相同，那么代表在同一个BSS内(intra-BSS)。若BSS Coloring字段信息不同，那么代表这里是重叠覆盖区域，在多个BSS间(inter-BSS)。 在传统802.11中，若在BSS间(inter-BSS)，当节点检测到信道忙时，需要推迟自己的传输，直到信道空闲才可以发送。在802.11ax中，引入了<strong>自适应CCA机制</strong>(adaptive CCA)。通过提高BSS间(inter-BSS)信号检测阈值，同时保持BSS内(intra-BSS)的较低信号检测阈值（两个阈值，大约4dB左右的差值），来减少MAC层竞争时的竞争问题，提升MAC层效率。</p><p>BSS Color特性如下：</p><ul><li>STA可以使用信道接入规则（26.10 Spatial reuse operation）</li><li>降低能量消耗</li><li>更新NAV</li></ul><h1 id="什么是802-11ax中的BSS-Coloring技术？">3 什么是802.11ax中的BSS Coloring技术？</h1><p>整理自<a href="https://www.extremenetworks.com/extreme-networks-blog/what-is-bss-color-in-802-11ax/">What is BSS Color in 802.11ax?</a></p><p>802.11协议是采用CSMA/CA作为MAC层的协议，其采用的是半双工通信机制，这表示在同一个时间只有一个无线电设备可以在网络上进行传输。如果一个802.11终端检测到任意一个802.11终端的传输信号(即PHY层的Header)，其会推迟传输。我们称多个AP和客户端在同一个信道上进行部署，并执行竞争传输叫做OBSS(具有重叠的基本服务集)。在OBSS中，我们描述这种同信道的干扰为co-channel interference(CCI).</p><p>信道复用的核心问题是最小化空口传输时间并减少由于OBSS场景导致的性能下降。 802.11ax修正案基于提升空间复用的思想，提出<strong>自适应的CCA机制</strong>(adaptive clear channel assessment, adaptive-CCA)来对于信道进行检测。</p><p>BSS Coloring，是用于识别重叠基本服务集（OBSS）的方法。 其最先是在802.11ah-2016修正案中定义，现在也沿用到了802.11ax中。 BSS Coloring是一个字段，标识了BSS的ID。当多个无线终端在同一信道上传输时，802.11ax无线电能够使用BSS Coloring字段区分BSS。</p><p>BSS Coloring的信息是同时被添加在PHY层和MAC层中的。在802.11ax PHY头部的Preamble中，其SIG-A字段包含6个Bit的BSS Coloring信息字段，如下表所示，该字段可以识别多达63个BSS。</p><table><thead><tr><th>bit0</th><th>1</th><th>2</th><th>3-6</th><th>7</th><th>8-13</th><th>14</th><th>15-18</th><th>B19-B20</th><th>…</th></tr></thead><tbody><tr><td>Format</td><td>Beam change</td><td>UL/DL</td><td>HE-MCS</td><td>DCM</td><td>BSS Color</td><td>Reserved</td><td>Spatial Reuse</td><td>Bandwidth</td><td>…</td></tr></tbody></table><p>![802.11管理帧中BSS color字段](802.11AX BSS Color/bss-color.png)</p><p>在802.11管理帧中也可以看到BSS Coloring信息(如上图所示)。在Beacon帧中的HE Element中，包含BSS Coloring的子字段。其也是6个Bit的BSS Coloring信息字段，可以标识63个BSS。</p><p>在802.11ax中，MAC层的竞争取决于检测到的BSS Coloring。其将CCA的阈值和BSS Coloring信息关联起来(即adaptive-CCA)，从而提升空间复用能力。让节点可以忽略OBSS间的传输，可以在此时同时进行传输，从而提升信道利用率。802.11ax修正案定义了两种的空间重用模式，一种称为基于OBSS PD的空间重用，另一种称为基于SRP的空间重用。</p><h1 id="BSS-Color原理">4 BSS Color原理</h1><p>整理自<a href="https://www.extremenetworks.com/extreme-networks-blog/how-does-bss-coloring-work-in-802-11ax/">How Does BSS Coloring Work in 802.11ax?</a></p><p>基本服务集（BSS）是任意802.11网络的基础拓扑。构成BSS的元素包含，包括1个AP和多个节点。在多个节点在信道传输时，802.11ax通过BSS Coloring字段来区分BSS。若BSS Coloring信息相同，那么是BSS内的传输，若BSS Coloring不同，那么是BSS间的传输，即来自于OBSS内部的传输。</p><img "" class="lazyload placeholder" data-original="/posts/bc6a848b/1f.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="颜色冲突" style="zoom: 67%;"><p>对于802.11ax的AP，其如果检测到使用相同颜色的OBSS，则它能够更改变其BSS颜色，减少同频干扰。若AP与AP间的BSS Coloring一样，那么这也是一种BSS Coloring的冲突，即颜色冲突。如上图所示，如果802.11ax AP听到来自其他AP或者该AP节点的不同BSS Coloring字段，那么是检测到一次颜色冲突。</p><img "" class="lazyload placeholder" data-original="/posts/bc6a848b/2f.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="上报颜色冲突" style="zoom:67%;"><p>另外，如果终端检测到颜色冲突，则该终端会向其关联的AP发送颜色冲突报告。如上图所示，AP-1无法听到AP-2，但AP-1的关联的终端可以听到来自于OBSS区域内，其他不同BSS Coloring的传输，从而向AP发送颜色冲突报告。终端向AP会报告其能够监听到的所有OBSS的BSS Coloring信息。</p><p>当AP检测到颜色冲突后，其可以决定改变其BSS颜色。不过改变BSS Coloring的标准和选择新BSS Coloring信息的方法超出802.11ax草案修正案的范围。WLAN供应商目前可以自行制定，例如Aerohive信道选择协议（ACSP）。</p><p>![BSS color change announcement](802.11AX BSS Color/v2-16f827ae3d3c33cc2d1577f0ce9b9075_720w.jpg)</p><p>AP会通过Beacon告知所有关联在本BSS内部的节点，BSS Coloring的改变。BSS Coloring的改变还可以通过探测响应和重新关联响应帧中进行通知。如上图所示，AP告知节点BSS Coloring的颜色变化，其New BSS Color子字段则包含新BSS Coloring的数值。</p><h1 id="初始化BSS-color">5 初始化BSS color</h1><p>当HE AP开始一个基础BSS（infrastructure BSS）或者HE STA开始一个IBSS或者MBSS，在它发送的第一个<strong>HE Operation element</strong>中，其帧格式如下图所示，设置BSS Color子字段为1~63中的一个值，并且在BSS的存在时间或直到BSS color改变，都需要维持这个值不变。如果选择一个BSS Color，HE STA需要考虑相邻OBSS中BSS color的使用。</p><img "" class="lazyload placeholder" data-original="/posts/bc6a848b/image-20210331232050904.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="HE Operation element format" style="zoom:50%;"><p>其中<strong>BSS Color Information</strong>字段如下所示</p><p>![BSS Color Information](802.11AX BSS Color/image-20210401104143752.png)</p><p><strong>Partial BSS Color</strong>字段为1表示将基于(AID 分配)中定义的BSS颜色的AID分配规则应用于BSS</p><p>AID分配规则：![AID分配公式](802.11AX BSS Color/image-20210401104001452.png)</p><h1 id="禁用BSS-color">6 禁用BSS color</h1><p>当HE STA探测到BSS color collision时，发送一个HE Operation element来禁止BSS使用BSS color，设置HE Operation element中的BSS Color Disabled子字段为1来通知该BSS下的其他STA禁止使用BSS Color；否则HE STA设置BSS Color Disabled子字段为0。</p><blockquote><p>NOTE: 发送了HE Operation element的HE STA不要长时间禁止BSS color，否则会影响其他依赖BSS color的HE STAs的功能。</p></blockquote><p>如果AP接收到的HE operation element中的BSS Color Disabled子字段为1，则：</p><ul><li>non-AP HE STA使用HE PPDU中的Address 1, Address 2, Duration/ID代替RXVECTOR parameters BSS_COLOR和TXOP_DURATION来决定STA是否更新intra-BSS NAV</li><li>non-AP HE STA使用HE PPDU中的Address 1, Address 2代替RXVECTOR parameters BSS_COLOR和STA_ID来决定STA在PPDU持续时间是否进入休眠</li></ul><h1 id="BSS-color冲突">7 BSS color冲突</h1><p>BSS冲突上报使用的是管理帧，这里先复习一下管理帧的具体细节。</p><table><thead><tr><th align="left">字段</th><th>Frame Control</th><th>Duration</th><th>Address1</th><th>Address2</th><th>Address3</th><th>Sequence Control</th><th>HT Control</th><th>Frame Body</th><th>FCS</th></tr></thead><tbody><tr><td align="left">Octets</td><td>2</td><td>2</td><td>6</td><td>6</td><td>6</td><td>2</td><td>0 or 4</td><td>Variable</td><td>4</td></tr></tbody></table><p>管理帧：Beacon、ATIM、Disassociation、Association Request、Association Response、Reassociation Request、Reassociation Response、Probe Request、Probe Response、Authentication、Deauthentication、Action、Action No Ack、Timing Advertisement。</p><p>其中Action frame的frame body格式如下所示。</p><p>![Action frame body](802.11AX BSS Color/image-20210402143824652.png)</p><p>Action字段格式如下</p><p>![Action field](802.11AX BSS Color/image-20210331175719479.png)</p><p>Action frame的类别如下图所示：Spectrum management Action、QoS Action、DLS Action、Block Ack Action、Vendor-specific action、Radio Measurement action、Public Action、FT Action、SA Query Action、Protected Dual of Public Action、HT Action、TDLS Action、WNM Action、Unprotected WNM Action等。</p><p>![Category filed](802.11AX BSS Color/image-20210406105156487.png)</p><p>![Category filed](802.11AX BSS Color/image-20210406105300871.png)</p><p>![Category filed](802.11AX BSS Color/image-20210406105318271.png)</p><p>这里讨论的BSS color冲突上报就隶属于WNM Action类别中的Event Report Frame中，Action字段格式如下。</p><p>![Event Report Action field format](802.11AX BSS Color/image-20210331174935637.png)</p><p>Category（类别）：值为10，代表WNM Action</p><p>WNM Action：其他值省略，这里为上报，所以为1</p><table><thead><tr><th>WNM Action field value</th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>0</td><td>Event Request</td></tr><tr><td>1</td><td>Event Report</td></tr><tr><td>2-255</td><td>此处省略</td></tr></tbody></table><p><strong>Dialog Token</strong>判断是上报还是响应帧</p><table><thead><tr><th>Dialog Token value</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>该帧为事件报告帧</td></tr><tr><td>非零</td><td>对应Event Request frame</td></tr></tbody></table><p><strong>Event Report Elements</strong>格式如下图所示，注意，由于对应的是BSS Color事件，则<strong>Event Report Status</strong>为0(Successful)，并且<strong>Event Type</strong>是4（BSS Color collision）或者5（BSS Color in use）,则在事件上报状态后面的字段使用Event TSF, UTC Offset, Event Time Error, Event Report等字段。</p><img "" class="lazyload placeholder" data-original="/posts/bc6a848b/image-20210331235333867.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Event Report element format" style="zoom:50%;"><p>Element格式如下如所示，对于BSS Color事件，其中Element ID Extension长度为1个字节。</p><p>其中<strong>Element ID</strong>定义如下表所示。</p><table><thead><tr><th>Element</th><th>Element id</th><th><strong>Element ID</strong> Extension</th><th>Extensible</th><th>Fragmentable</th></tr></thead><tbody><tr><td>BSS Color Change Announcement</td><td>255</td><td>42</td><td>YES</td><td>NO</td></tr></tbody></table><p><strong>Event Token</strong>事件令牌：由于BSS Color冲突事件是自动上报的，所以该字段为0</p><p><strong>Event Type</strong>事件上报类型：定义如下表所示</p><table><thead><tr><th>Event Type</th><th>Name</th></tr></thead><tbody><tr><td>0</td><td>Transition</td></tr><tr><td>1</td><td>RSNA</td></tr><tr><td>2</td><td>Peer-to-peer link</td></tr><tr><td>3</td><td>WNM log</td></tr><tr><td><strong>4</strong></td><td><strong>BSS Color Collision</strong></td></tr><tr><td><strong>5</strong></td><td><strong>BSS Color In Use</strong></td></tr><tr><td>6-220</td><td>Reserved</td></tr><tr><td>221</td><td>Vendor Specific</td></tr><tr><td>222-255</td><td>Reserved</td></tr></tbody></table><p><strong>Event Report Status</strong>定义如下图所示</p><img "" class="lazyload placeholder" data-original="/posts/bc6a848b/image-20210331235803357.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Event Report Status" style="zoom:50%;"><p><strong>Event TSF</strong>:当STA记录事件时，该字段为TSF的值。</p><p><strong>UTC Offset</strong>：当TSF timer等于0时，该字段是与UTC事件相对应的UTC值。如果UTC Offset未知，则改字段为0。</p><p><strong>Event Time Error</strong>：UTC标准偏差，对应事件记录的TSF值。如果Event Time Error未知，则该字段为0.</p><p><strong>Event Report</strong>：该字段包含单个事件报告的说明。相对于BSS color collision event report，该字段是一个八字节共64位，每一位对应BSS Color(1-63)，如果该bit的值为1，则表示non-AP HE STA检测到与该位置对应的BSS Color已被使用，我理解的是第0位保留不用。举例：如果第10bit位为1，则表示non-AP HE STA检测到BSS Color=10已经被OBSS使用。</p><h1 id="BSS-color-change发布">8 BSS color change发布</h1><p>当监测到bss color collision，禁用BSS color后，HE AP使用<strong>BSS Color Change Announcement element</strong>来宣布即将到来的BSS color改变。</p><blockquote><ul><li>non-AP HE STA不应该发送BSS Color Change Announcement element。</li><li>Beacon, Probe Response, (Re)Association Response和HE BSS Color Change Announcement帧可以携带BSS Color Change Announcement element，AP通过发送这些帧来宣布bss color change。</li><li>HE AP公告即将到来的BSS color change的时间要足够长，这样BSS内的所有STA，包括处于PS模式下的，可以确保在BSS Color改变之前收到携带BSS Color change Announcement element的帧。</li></ul></blockquote><p>如果使用Action frame来通知颜色改变，帧细节在上一节已经讨论过。</p><blockquote><p>注意：HE AP可能会将HE BSS color change announcement frame作为action frame来发送给一些错过了颜色更改公告并仍以旧颜色发送的STA.</p></blockquote><p>在802.11ax中新增两个类别，category字段新增的值如下所示</p><p>![category filed](802.11AX BSS Color/image-20210406110855445.png)</p><p>BSS Color change announcement frame对应于Protected HE Action frame，其帧格式如下所示。</p><p>![HE BSS Color change announcement frame](802.11AX BSS Color/image-20210401154758894.png)</p><p>其中category就是新增的值：31</p><p>则Protected HE Action字段值如下所示，对应value=0，为颜色更改公告。</p><p>![image-20210402145037669](802.11AX BSS Color/image-20210402145037669.png)</p><p><strong>BSS Color Change Announcement element</strong>格式如下所示</p><p>![BSS clor change announcement element format](802.11AX BSS Color/image-20210331154920218-7177023.png)</p><p>其中New BSS Color Information字段如下</p><p>![New BSS Color Information filed format](802.11AX BSS Color/image-20210331155505916.png)</p><ul><li>如果BSS Color Change Announcement element中的Color Switch Countdown字段的值大于1，那么下一个TBTT后，AP应该将Color Switch Countdown减1。当Color Switch Countdown等于1时，就是BSS color change TBTT，也就意味着<strong>在该时刻修改BSS color</strong>。当HE AP公示BSS Color即将改变后，不应该修改BSS Color change TBTT。</li><li>属于共同托管的BSSID集的AP（请参见26.17.7（共同托管的BSSID集））应选择“ Color Switch Countdown”字段的值，以使集合中各个BSS之间的BSS颜色变化TBTT间隔不大于该集合中具有最大信标间隔的BSS的信标间隔。</li></ul><p>在导致BSS color change TBTT内，也就是Color Switch Countdown的值大于1的时间段内：</p><ul><li>HE AP应该设置BSS Color Disabled子字段为1，同时，继续通过HE Operation element中的BSS Color子字段发布之前存在的BSS color。</li><li>HE AP不能改变BSS Color Change Announcement elemen中New BSS Color子字段的值。</li><li>HE AP应该设置HE PPDU中的TXVECTOR parameter BSS_COLOR为之前存在的BSS color。</li></ul><p>在BSS color change TBTT内，也就是Color Switch Countdown的值等于1的时间段内：</p><ul><li>HE AP应该将它发送的HE Operation element中的BSS Color Disabled子字段置为0，除非HE AP属于co-hosted BSSID set（共同托管的BSSID集），这样它可以继续保持该值为1，直到co-hosted BSSID set中所有的BSS都结束了各自的BSS color change TBTT。</li><li>HE AP在HE operation element中的BSS Color子字段中使用新的BSS color。</li><li>HE AP在TBTT之后在它发送的所有帧中使用新的BSS color。</li></ul>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11AX Buffer Status Report</title>
      <link href="posts/e017b6e6.html"/>
      <url>posts/e017b6e6.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="序言">1 序言</h1><p>上文叙述了上行OFDMA接入机制。该机制的基本思想就是通过AP竞争，获得TXOP传输时间后，根据各个终端的缓存情况，进行RU资源的分配，当分配完成后，进行上行OFDMA的传输。在这个过程中，缓存情况的反馈可以通过AP询问的方式主动完成（即AP发送BSRP帧向终端请求），也可以进行非主动的反馈，本文就针对于非主动反馈缓存信息BSR（Buffer Status Reports）做一个介绍。</p><p>参考资料：</p><ul><li><a href="/books/Wi-Fi_6_FD_Extreme_Networks_Special_Edition.pdf">Wi-Fi_6_FD_Extreme_Networks_Special_Edition</a></li></ul><h1 id="非主动的BSR反馈">2 非主动的BSR反馈</h1><p>在802.11ax中，UL-OFDMA一共有三次帧交换过程，一共包含了3个触发帧</p><ul><li>Trigger #1：BSRP帧，用于请求终端的缓存情况</li><li>Trigger #2：MU-RTS帧，用于兼容保护传统的802.11终端，以及分配RU资源</li><li>Trigger #3：Basic-Trigger帧，用于触发节点进行并行的上行传输</li></ul><p>在此叙述中，重点描述的是，AP采用<strong>显式</strong>的请求终端们的缓存情况（即BSRP，BSR过程）。在实际情况下，UL-OFDMA不一定具备完整的这个三个触发帧。比如，若网络中不存在传统的802.11终端，则不需要MU-RTS帧，或者为了减少开销，AP不用显式的发送BSRP帧，而是将其和其他的控制帧，数据帧或者管理帧结合进行发送。</p><p>终端是可以在未经BSRP请求的时候，直接反馈非主动的BSR帧给AP，即unsolicited buffer status report。终端可以在任意一个帧中利用以下字段发送这种非主动的BSR：</p><p><strong>QoS控制字段（QoS Control field）</strong>：802.11 ax终端可以在其发送的<strong>QoS数据帧</strong>或者<strong>QoS Null帧</strong>（也就是只有Header，payload部分为空）中，利用<strong>Queue Size字段</strong>（每一个QoS类型有一个单独该字段），来反馈缓存的状态信息。另外，终端还可以用聚合帧的形式，反馈多个QoS类别，其不同的缓存情况。不同的QoS类别利用TID进行区分（Traffic identifier，TID）。Queue Size字段用来指示具体的缓存信息。</p><p><strong>BSR控制字段（BSR Control subfield）</strong>：如果是在一个802.11ax的网络中，AP支持BSR控制字段的话，那么终端还可以在发送的<strong>任意帧中添加BSR控制字段</strong>内，进行BSR信息的反馈。如下图所示，802.11ax会标识不同的QoS接入类别（Access Category，AC）通过ACI High字段，并且反馈具体的Buffer信息通过Queue Size High字段（图上粉色标识为反馈单个接入类型的BSR情况）。终端会决定哪个QoS队列相对于其他队列具备更高的优先级。这一种相对QoS设置的方法并没有在协议中严格规定，从而为不同类型的终端分配优先级提供灵活性。</p><p>![Control Information subfield format in a BSR Control subfield](802.11AX Buffer Status Report/image-20210420105910432.png)</p><p>一个802.11ax终端还可以报告多个QoS类别的缓存情况。这要通过上图中的ACI Bitmap，Delta TID和Queue Size All字段来反馈（图中蓝色标识为反馈多个接入类型的BSR情况）。ACI Bitmap和Delta TID标识多个QoS的接入类型，QoS Size All字段标识其对应的缓存情况。另外还有一个字段为Scaling Factor（SF），这个字段代表缩放因子，用以表示缓存的单位大小。即QoS Size High或者QoS Size All需要配合SF字段才表示真实的缓存情况。SF一共有两位，分别表示了4种缩放情况，如下图所示。这种缩放的表示方法也是为了不同终端其反馈对应流量时候，具有比较高的灵活性。</p><p>![Scaling Factor subfield encoding](802.11AX Buffer Status Report/image-20210420110122893.png)</p><p>另外一点需要注意的是，在802.11协议中，协议支持同时在QoS控制字段（QoS Control field）和BSR控制字段（BSR Control subfield）中，同时反馈BSR信息，当然这也协议中是一种可选的选项，而且同时包含BSR信息时，其两个字段所包含的信息需要一致才行。</p>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11AX UL-OFDMA</title>
      <link href="posts/9d40f8c2.html"/>
      <url>posts/9d40f8c2.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="序言">1 序言</h1><p>在802.11ax以前，协议仅仅支持过下行的多用户接入，比如说MU-MIMO技术（在802.11ac中仅仅支持下行），为了进一步增加并发传输的能力，在802.11ax中引入了上行OFDMA技术和上行的MU-MIMO接入。在协议中上行OFDMA和上行MU-MIMO是组合出现的，其是采用同一种接入思想，区别只在于触发帧内的参数以及数据帧的物理层头部上，本文仅介绍上行OFDMA接入机制。</p><p>参考资料：<a href="/books/Wi-Fi_6_FD_Extreme_Networks_Special_Edition.pdf">Wi-Fi_6_FD_Extreme_Networks_Special_Edition</a></p><h1 id="上行OFDMA和PCF的区别">2 上行OFDMA和PCF的区别</h1><p>在802.11ax中，UL-OFDMA的接入机制也是基于触发帧（Trigger Frames）的，这一种机制和传统802.11中的PCF机制有一些类似，但是也有点区别。</p><p>在传统的802.11标准中定义了一种PCF工作模式（Point Coordination Function），该模式是一种基于轮询的工作模式。AP执行轮询者的角色（point coordinator ），其可以在CFP时间范围内（contention-free period ），轮询客户端并执行上下行的传输。在PCF之后，802.11e修正案中为了整体解决无线网络中QoS的问题，定义了一种HCCA的方式（HCF Controlled Channel Access）。在HCCA中，AP作为具有QoS的中心调度器（Hybrid Coordinator ，HC），其在接入网络时默认具有比较高的优先级。利用该优先级，其可以将TXOP分给自身或者其他的节点，以提供一个受控的接入时间段，该时间段也被称为CAP时间（Controlled Access Phase ）。在这段时间内，QoS数据可以无需竞争，直接传输。PCF以及HCCA直至目前也很少在实际产品中实现过，有传言指该机制有可能会在将来的802.11标准中被逐步淘汰。</p><p>在802.11ax中，AP可以控制信道并调度上行OFDMA（UL-OFDMA）的接入。这一种控制和PCF或者HCCA时有区别的。基于CSMA/CA的竞争规则在UL-OFDMA中还是使用的，<strong>只有当802.11ax AP首先竞争胜利，并开启一个TXOP时间之后，其才可以占据并调度信道上其他的节点执行UL-OFDMA</strong>。在UL-OFDMA中，也会类似HCCA一样轮询终端的buffer情况以及其对应数据的QoS情况，但是和HCCA的区别在于，HCCA是主动轮询的，而802.11ax终端可以隐式的反馈其缓存的信息，无需主动轮询。另外还有一点区别在于802.11ax中引入了资源分配，即<strong>AP还需要为UL-OFDMA调度的时候，为多用户分配分配RU资源</strong>。在UL-OFDMA传输之前，AP会通过触发帧来指示每一个终端其对应的RU资源，以及对应RU资源上的传输模式（包含空间流数量，MCS速率等）。</p><h1 id="Scheduled-UL-OFDMA">3 Scheduled UL-OFDMA</h1><p>下面介绍上行OFDMA的工作机制（UL-OFDMA），其基本思想是802.11ax AP通过竞争获取信道后，发起一次TXOP传输时间，并在该时间内通过触发帧调度对应的节点进行并发的上行OFDMA传输。具体过程中UL-OFDMA比DL-OFDMA更为复杂一些，其会采用三个触发帧进行交互，每个触发帧都是AP向节点获取特定的信息反馈。UL-OFDMA中AP会要求终端反馈缓存情况（即Buffer Status Report, BSR）。BSR中包含了终端缓存数据的多少以及对应的QoS类别信息，这些信息会帮助AP优化RU的资源分配。AP将利用这些信息分配对应的RU，上行传输的时间，以及终端传输时对应的速率和功率。BSR信息是可以AP轮询请求的，也可以是非请求（也就是隐式反馈的）。</p><p>![Uplink OFDMA](802.11AX UL-OFDMA/image-20210413174859455.png)</p><p>以上图作为示例简单说明，当802.11ax竞争成功后，其首先会发送第一个触发帧（即Trigger #1），该触发帧类型是BSRP（Buffer Status Report Poll ），其用于请求终端的Buffer信息。当终端收到BSRP以后，其会反馈BSR（Buffer Status Reports）信息，就如之前我们提到的，该信息用于辅助AP进行UL-OFDMA中RU资源的分配。</p><p>当BSRP,BSR交互后，如果网络中存在传统的802.11客户端，那么AP还需要发送MU-RTS帧（即Trigger #2），该帧也是一种触发帧，并采用传统的OFDM技术进行发送，所有的终端（包含802.11ax和非802.11ax）都可以接收。非802.11ax的终端会通过接收MU-RTS帧中的Duration/ID字段，设置本地的NAV计时器，以保证在剩余UL-OFDMA时间内不会发起主动竞争。同时该MU-RTS帧中还包含了RU资源分配内容。</p><blockquote><p>AP进行RU资源分配是在MU-RTS帧，而下一个触发帧仅仅是指示开启传输的作用。因为在AP分配RU资源后，需要得到终端的反馈，即终端会反馈CTS帧，告知AP其认可并知道了当前资源分配的情况。</p></blockquote><p>当MU-RTS，CTS交换完后，AP会发送第三个触发帧（即Triiger #3），通知终端在对应的RU资源上进行上行传输，该触发帧还指示了本次上行传输的时间。</p><blockquote><p>一次UL-OFDMA需要所有节点同时开始和同时结束（如果存在不同步的情况，那么需要在数据帧添加PAD用以填充，如图上STA2所示）。</p></blockquote><p>该触发帧还包含了节点对应的功率控制信息，以便终端增加或者减少发送功率，这样有利于多终端均衡接收，并提高接收信号的质量。当上行UL-OFDMA传输完成后，AP会向终端们反馈Multi-STA Block ACK确认。另外，AP也可以逐个客户端反馈Block ACK，这在协议中是可选的。</p><blockquote><p>并不是所有的上行链路传输需要三个触发帧，仅仅出于对传统客户端的保护机制的目的才需要MU-RTS触发帧。</p></blockquote><h1 id="UL-OFDMA-Random-Access-UORA">4 UL-OFDMA Random Access (UORA)</h1><p>前面所介绍的802.11ax的接入机制中，都是由AP通过获取全局的缓存情况，然后为上行和下行传输统一分配RU资源。然而，如果缓存情况未知的情况下，协议如果需要工作的话，那么就需要引入随机接入机制，该随机接入机制就是UORA（UL-OFDMA Random Access）。本文将会对UORA做一个简单介绍。在介绍TF-R机制中，提过UORA机制。</p><p>在802.11ax中，AP利用OFDMA技术，将信道分成多个RU，不同终端可以通过占据不同的RU，从而并行的执行多用户传输。AP可以在上行和下行传输中，站在全局的角度，进行RU资源的最优化分配。在分配过程中，AP可以通过显式请求的方式，或者被动收集的方式，获取节点的缓存情况（即BSR反馈）。AP会根据BSR信息，做全局资源的分配，当分配完成后，AP通过触发帧机制启动一次传输过程。</p><p>在802.11ax中还存在一种可选的随机接入机制（UORA），在该方法下，上行UL-OFDMA链路中RU资源的分配不是由AP决定的，而式通过随机接入机制UORA来竞争的。这种接入机制不需要终端侧实时的反馈BSR信息，对于AP不知道终端缓存情况下是有利的。</p><p>在UORA中，会使用一种频域的back-off技术（即OFDMA back-off，OBO）。在OBO中，一开始终端会选择一个随机数，然后AP会发送一个竞争类型的触发帧，其中还包含了本轮可用的RU数量。终端会将自己的随机数减去本轮的RU数量，直到减为0。如果终端利用随机数相减之后，本轮值为0的话，那么相当于竞争成功，终端将会随机选择一个RU进行占据。如果本轮相减后，没有为0，那么相当于本轮竞争失败，那么会保持这个数值，下一轮进行继续相减。</p><img "" class="lazyload placeholder" data-original="/posts/9d40f8c2/v2-adec2f422eea8fd4d9e41a2e620ba751_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img" style="zoom:33%;"><p>具体还有一些细节如下</p><ul><li><p>802.11ax AP发送一个触发帧，该触发帧是用于触发一次OBO随机接入的，并且包含了可以被分配的RU数目</p></li><li><p>该触发帧中的User Info字段中包含了AID字段（每一个RU都有一个AID指示），该AID字段表示该RU是否可用被用来进行随机接入</p><ul><li>如果AID=0，表示该RU用于一个或者多个已关联的终端进行随机接入（如上图中，STA 1,2,4是已经关联的）</li><li>如果AID=2045，表示该RU可用于一个或者多个没有被关联的终端进行随机接入（如上图中，STA 3是没有被关联的）</li></ul></li><li><p>终端在初始时刻选择的随机值的范围是通过AP指定的，AP会利用OFDMA contention window (OCW) 字段（在UORA Parameter Set Information字段内）进行范围指定</p></li><li><p>终端会在OCW范围内选择一个随机数，然后每次OBO随机接入开始的时候，进行一次相减</p><ul><li>如果OBO计数器（OBO counter）的数值是小于本轮可用的RU的数值的话（其实这个和前面说的，OBO计数器的值减去可用的RU数目，如果小于等于0的话），那么本轮相当于竞争成功，然后会选择一个随机的RU进行占据（在其可用选择的RU范围内)</li><li>如果OBO计数器是大于本轮RU的数值的话，那么相减完之后，等待下一轮OBO的开始，直到递减为0</li></ul></li></ul><p>大致的OBO的执行流程我们已经解释完了，为了更清楚一些，我们下面举个具体的例子：</p><p>首先AP发送一个触发帧（如下图 Trigger 1），该触发帧中的OCW标识了随机数的选择范围，并且标识了可以用于随机接入的RU资源（即eligible RA-RUs，可用于Random Access的RU）。在图中，我们还需要关注到终端所对应的AID，STA 1对应的AID=1，STA 2对应AID=2，STA 4对应AID=3，AID仅仅是分配给已关联的节点的，由于STA3没有关联，所以其没有被分配的AID。在该Trigger 1帧中，标识了RU 1 ~ RU 3是可以用于已关联节点进行随机接入的（即允许STA 1，2，4竞争），RU 4 ~ RU 5是可以用于未关联的节点进行随机接入（即允许STA 3竞争），RU6是已经被分配给特定节点了（即分配给了AID=3，也就是STA 4）。</p><p>当收到Trigger 1之后，终端们在OCW范围内，各自选择一个随机数进行OFDMA Back-off（OBO），如图中，STA 1的OBO counter =3，STA 2的OBO counter =5，STA 3的OBO counter =4，STA 4的OBO counter =2。其中STA 1，2，4和AP已经关联的，STA3是和AP没有关联的。</p><img "" class="lazyload placeholder" data-original="/posts/9d40f8c2/v2-3bbec9f2af7a2d75f5a9a8978b2c649a_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img" style="zoom:33%;"><p>由于STA 4在触发帧中已经被分配了资源（即RU 6），那么只剩STA 1和STA 2进行本轮的OBO，已经有资源的终端本轮就不需要进行OBO了，随机数保持不变。对于STA 1和STA 2而言，本轮可用竞争使用的RU数目为3个，其对应的STA 1的OBO counter = 3，STA 2的OBO counter = 5。在本轮相减后，STA 1的OBO counter = 3-3 = 0，STA 2的OBO counter = 5-3 = 2。对于STA 3而言，本轮可用的RU数目为2个（即RU 4和RU 5），所以本轮相减后，STA 3的OBO counter = 4-2 =2。</p><img "" class="lazyload placeholder" data-original="/posts/9d40f8c2/v2-46302b09c24a39feefbf8e716eb14b14_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img" style="zoom:33%;"><p>如上图所示，由于STA 1本轮相减后OBO counter = 0，其相当于竞争胜利，可用随机选择一个RU占据（图中即RU 2）。STA 2本轮相减后，OBO counter = 2，那么本轮竞争失败，其会保持该值，直到下一轮OBO中继续相减。STA 3本轮相减后，OBO counter = 2，那么本轮竞争也是失败的，需要进行下一轮的OBO竞争。STA 4由于一开始AP已经指定了其对应的RU（即RU 6），那么本轮其不用进行OBO，所以保持其OBO counter不变，即STA 4的OBO counter =2。然后已经竞争成功或者分配成功的终端，就在其选择的RU位置上，进行上行数据的传输，从而本轮OBO完成。</p><img "" class="lazyload placeholder" data-original="/posts/9d40f8c2/v2-89b427eebc632dad21e7b7d23ffcd04d_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img" style="zoom:33%;"><p>当上一轮传输完成后，AP发送了一个新的触发帧（即Trigger 2）开启一轮新的OBO。如上图所示，在该触发帧中，RU 1 ~ RU 2是用于给已关联的终端进行OBO（由于该RU的AID=0），RU 3 ~ RU 4是给未关联的终端进行OBO（由于该RU的AID=2045），RU5 ~ RU 6是被分配给了特定终端，即AID = 6。</p><p>当收到Trigger 2帧后，由于STA 1上一轮竞争成功，所以其需要在OCW范围内重新选择一个随机数，本轮STA 1的OBO counter = 4，其余STA 2，STA 3，STA 4都是保留上一轮OBO之后的OBO counter。</p><p>![img](802.11AX UL-OFDMA/v2-b9286487cef9fb2ed12127491dd8282c_720w.jpg)</p><p>然后要执行本轮的OBO相减了。</p><p>首先关注已经关联的终端，即对于STA 1，STA 2和STA 4而言，本轮可用的RU数目（eligible RA-RUs）为2，所以相减完后，STA 1的OBO counter = 4-2 = 2，STA 2的OBO counter = 2-2 = 0，STA 4的OBO counter = 2-2 = 0。那么本轮竞争的胜利者为STA 2和STA 4，其分别随机选择了RU 1（STA 4）和RU 2（STA 2）占据，STA 1本轮没有竞争成功，所以不能进行传输。</p><p>对于未被关于的终端，即STA 3，本轮可用的RU数目为2，所以相减后，STA 3的OBO counter = 2-2 = 0，即本轮竞争成功。其选择了RU 4占据，并执行上行传输。</p><p>其余RU 5 ~ RU 6被分配给了特定节点，上图中就没有表示了。</p><p>当本轮分配好RU后，终端就会在自己对应的RU上进行上行数据的反馈。</p><blockquote><p><strong>Remark</strong>：在UORA的过程中，还是有可能会出现冲突的。即终端OBO counter=0之后，需要随机占据一个RU进行上行传输，若此时有两个或者两个以上节点占据了同一个RU，那么在这个一个RU上就会发生一次冲突。如果发生冲突，那么AP就无法成功收到该RU上对应的数据帧，从而不会反馈ACK。终端通过ACK来得知本轮是否传输成功，如果失败的话，那么他们会增大其OCW的大小至两倍（即double OCW范围，直到OCWmax值），这里和传统802.11的backoff中的BEB机制是类似的，用于减少冲突概率。802.11ax中的UORA实际上冲突概率还是小于传统802.11的，主要是因为其是多资源中，任意选择一个RU，这种冲突概率还是小于原来单信道模式下，所有节点进行竞争的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11AX DL-OFDMA</title>
      <link href="posts/2d51c977.html"/>
      <url>posts/2d51c977.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="序言">1 序言</h1><p>在介绍完802.11ax的信道接入以及其触发帧机制后，本文着重介绍下行OFDMA的接入机制（即DL-OFDMA）。</p><p>参考资料：<a href="/books/Wi-Fi_6_FD_Extreme_Networks_Special_Edition.pdf">Wi-Fi_6_FD_Extreme_Networks_Special_Edition</a></p><h1 id="下行OFDMA接入机制（DL-OFDMA）">2 下行OFDMA接入机制（DL-OFDMA）</h1><p>OFDMA是一种多用户通信机制，其只适用于802.11ax AP和802.11ax用户之间的数据帧交换。为了保证协议的兼容，在802.11ax中，管理和控制帧还是按照传统的单用户OFDM进行传输。在此之中，OFDMA和OFDM的工作切换需要进行一系列的特定帧交换，比如之前提到的触发帧（Trigger Frame），这种机制在下行OFDMA（DL-OFDMA）和上行OFDMA（UL-OFDMA）中都需要被引入。</p><p>![Downlink OFDMA](802.11AX DL-OFDMA/image-20210413172631964.png)</p><p>接下来分析一下触发帧（Trigger Frames）机制是如何用户DL-OFDMA通信，即802.11ax AP向802.11ax终端们进行多用户下行传输。</p><p>首先，802.11ax AP需要通过竞争（即CSMA/CA的竞争过程），竞争胜利后，其发起一个TXOP传输时间，相当于这一段TXOP时间内，信道都是被AP所预约占据的，其余所有节点都会被延迟。如上图所示，一旦802.11ax AP获得了TXOP传输时间，AP可以给多个目标终端发送MU-RTS帧，这也是一种类型的触发帧。该MU-RTS帧有以下两个目的：</p><ul><li><strong>预约信道（Reserve the medium）</strong>：MU-RTS采用传统的OFDM技术，在整个20MHz信道上进行传输，所有的节点（包含802.11ax节点和传统的802.11节点）都可以接收。其功能和传统的RTS是类似的。通过该MU-RTS帧中的Duration/ID字段，该帧设置其余所有节点的NAV定时器，在预约时间内（即定时器设置的时间），所有的终端都处于被动接收状态，不会主动竞争信道。NAV定时器设置的时间值用于DL-OFDMA的数据帧交换。在802.11ax AP向802.11ax终端之间进行OFDMA传输时，信道是必须保证空闲的。</li><li><strong>RU分配（RU allocation）</strong>：MU-RTS还被用来同步802.11终端的RU分配。MU-RTS由于是一种触发帧（Trigger Frames），触发帧内部包含了RU分配对应的字段。802.11ax AP通过MU-RTS作为触发帧，告诉每一个终端其被分配的时频资源（即对应的RU）。当接收到MU-RTS后，终端需要向AP反馈CTS用于确认。</li></ul><p>当收到来自于802.11ax终端的CTS后，802.11ax AP将执行一次下行的OFDMA数据传输（如图，即传输Multi-user DL-PPDU部分）。由于AP已经将信道划分成了多个RU，当终端在自己对应的RU上接收数据，并校验成功后，其需要向AP反馈ACK。该ACK还是通过Block-ACK的形式进行反馈的。具体为当传输完成后，AP会等待SIFS时间，然后发送BAR帧（Block ACK Request）向节点请求Block-ACK，然后终端并行反馈Block-ACK。这里反馈ACK还可以采用Automatic Block-ACK（即AutoBA，Auto Block-Ack ）机制。</p><blockquote><p>注：在以上传输过程中，CTS和Block-ACK都是并行传输的，这里并行传输实际上还是利用到了MU传输的机制。</p></blockquote><p>当本轮的DL-OFDMA传输完成后，所有节点（包含AP和终端）都需要进行下一次竞争。若802.11ax AP竞争成功，那么可以执行新的一次DL-OFDMA传输。若802.11n/ac的终端竞争成功，那么会执行一次传统的OFDM传输，以此类推。</p>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11AX OMI技术</title>
      <link href="posts/792c3209.html"/>
      <url>posts/792c3209.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="序言">1 序言</h1><p>**Operating Mode Indication (OMI)**是802.11ax MAC层运行的一种基本机制，用以交互形式分配兼容性以及信道带宽的协商。</p><p>参考资料：</p><ul><li><a href="https://www.extremenetworks.com/extreme-networks-blog/what-is-operating-mode-indication-omi/">What is Operating Mode Indication (OMI)?</a>。</li></ul><h1 id="Operating-Mode-Indication-OMI">2 Operating Mode Indication (OMI)</h1><p>在802.11ax中，上行和下行链路都引入了OFDMA技术，以实现802.11ax AP和终端间的多用户通信。当任意节点竞争胜利后，其会发起一次TXOP传输（Transmit Opportunity）。在TXOP期间，AP会利用OFDMA技术，将信道分成一个个资源单元（Resource Units ，RUs），以便可以同时进行多用户传输。</p><p>传统的802.11a/b/g/n/ac终端想要传输上行数据时（比如进行TXOP传输），其必须通过竞争。在802.11ax中，终端的上行接入机会是可以被AP进行同步和控制的。那么这里常被问的一个问题，即“802.11ax终端能不能不参与一个OFDMA的上行传输，而做为一个独立终端竞争信道，并进行单独的上行传输? ”</p><p>![Transmit Operating Mode](802.11AX OMI机制/image-20210413151332699.png)</p><p>802.11ax为此目的定义了操作模式指示（OMI）过程，802.11ax通过OMI机制完成传输模式的切换。如上图所示，终端作为OMI发起者（OMI Initiator）发送具有OM控制字段的帧给AP，AP作为OMI的响应者（OMI Responder）。</p><p>802.11ax终端使用802.11数据使用OM控制字段（OM Control Subfield，其通常位于数据或者管理帧中），其用来指示改变AP的发送或者接收模式。802.11ax终端可以通过发送TOM信息（Transmit Operating Mode）给AP，从而在单用户或多用户UL-OFDMA之间切换。若多用户模式，即根据AP控制进行UL-OFDMA传输，若单用户模式，那么终端就自行竞争，并执行单用户的数据传输。802.11ax的终端可以在上行OFDMA传输期间（UL-OFDMA），暂停并且恢复对AP发送的触发帧（Trigger Frames）反馈。</p><p>![Receive Operating Mode](802.11AX OMI机制/image-20210413151356053.png)</p><p>另外，OMI还可以用作802.11ax终端和AP进行接收模式（Receive Operating Mode ，ROM）的切换。802.11ax终端作为OMI Initiator向AP指示，其支持的下行链路的最大空间流数量和最大的信道带宽。如上图所示，终端会通过发送ROM信息给AP，指示其工作的信道大小从80MHz切换到20MHz。</p><p>OMI功能对于802.11ax客户端是可选的。</p><h1 id="Operating-Mode-Notification-frame">3 Operating Mode Notification frame</h1><p>操作模式通知帧是VHT类别中的一个action帧，其帧格式如下所示。</p><p>![Operating Mode Notification frame Action field format](802.11AX OMI机制/image-20210413154115678.png)</p><p>category字段值为</p><p>![Category values](802.11AX OMI机制/image-20210413154421104.png)</p><p>VHT Action字段为：</p><p>![VHT Action field values](802.11AX OMI机制/image-20210413154522070.png)</p><p>Operation Mode字段为：</p><p>![Operating Mode field](802.11AX OMI机制/image-20210413154730764.png)</p><p>STA通过发送该帧，表示当前工作的信道宽度和它可以接收的空间流的数量。</p>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11AX MAC层接入机制</title>
      <link href="posts/e5853641.html"/>
      <url>posts/e5853641.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="序言">1 序言</h1><p>在802.11ax以前，MAC的接入机制是典型的CSMA机制（即DCF中所采用的CSMA/CA）。</p><p>在引入了OFDMA的需求之后，802.11ax的MAC层随机接入机制也发生了变化，在协议中，代替传统的CSMA思想，802.11ax采用了基于ALOHA思想设计了竞争协议。其基本思想已经从强调分布式的场景，逐渐变成了强调中心式，高密度，优化资源分配上了。</p><p>本节主要就是介绍802.11ax中所采用的TF（Trigger Frame）以及TF-R（Trigger Frame for Random access）机制。</p><p>参考资料：</p><ul><li><a href>Wi-Fi_6_FD_Extreme_Networks_Special_Edition</a></li></ul><h1 id="MAC层接入机制">2 MAC层接入机制</h1><p>  802.11ax提升效率的秘诀之一就是OFDMA技术。OFDMA是OFDM技术的多用户版本，在诸如LTE等的其他无线技术中已经被广泛采用。在OFDMA中，信道被细分称更小的单元，称为资源单元（Resource Units，RU） 。通过细分信道，OFDMA通过分配不同的RU给多终端，从而允许多个终端执行并行传输，同时接入无线网络。即总结而言，OFDMA是一种多用户传输技术。</p><p>  ![OFDMA传输过程](802.11AX MAC层接入机制/image-20210412150306471.png)</p><p>  如上图所示，在802.11ax中，1个802.11ax AP将1个20 MHz信道划分为多个资源单元（RU），每一个RU被分配给不同的终端，802.11ax AP同时向这些终端进行下行传输。</p><p>  同时，802.11ax AP还可以同步调度802.11终端，让其执行并行的上行传输。</p><p>  在802.11ax中，竞争的规则还是存在的（即CSMA/CA）的规则，任何节点（包括AP）在发送之前都需要竞争。</p><p>  在此技术上，AP通过利用竞争（比如利用更高优先级的竞争参数）获得信道后，通过TXOP（transmission opportunity ）技术占据信道一段时间，从而达到控制信道接入的目的，因此802.11ax中AP具有一定的控制能力。</p><p>  一旦AP竞争并获得了TXOP是时间，AP可以控制高达9个802.11ax的终端进行上行传输或者下行传输（指的是在20MHz信道带宽下，最多可以承载9个RU，每一个RU为26个子载波）。</p><p>  针对于不同的TXOP，其RU的数量也是不一样的。对于上行接入（UL-OFDMA），AP采用触发帧机制（Trigger Frames），向802.11ax的终端进行调度和RU资源的分配。</p><p>  <img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-e90b62f696539d2e138501fef5ce205f_720w.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><p>  在802.11ax中，还存在一个OMI机制，这个机制是为了解决802.11终端是采用竞争接入信道（即单用户接入）还是采用OFDMA调度接入信道的（即多用户接入）。在OMI中，终端可以向AP发送信息，通知AP其支持的上下行所支持的最大空间流数目以及信道带宽。如上图所示，802.11ax终端采用OM控制字段（在数据帧或者管理帧中），来指示传输模式或者接收模式的变化。比如802.11ax终端可以在单用户接入或者多用户接入模式间切换。</p><h1 id="TF机制（Trigger-Frame）">3 TF机制（Trigger Frame）</h1><p>  802.11ax与传统的DCF所需求的MAC层机制是不同的。传统的DCF同一个时刻只有一个用户接入信道，而由于802.11ax采用OFDMA技术，其需求多个用户可以同一时间接入信道（选择的RU是正交的）。</p><p>  本节所介绍的TF机制，主要是用在UL MU（Uplink Multi-users）这种上行传输的场景下的。</p><p>  TF机制是一个<strong>上行传输</strong>的框架，其具体的随机接入的方法是TF-R机制。</p><p>  ![TF机制](802.11AX MAC层接入机制/v2-36dd8f6976d4c1dbc024e4af7a6a4ad9_720w.png)</p><p>  TF是一种上行接入的传输框架，其定义了一个很简单的过程：</p><ul><li>AP发送Trigger frame，宣称这一轮接入开始。Trigger frame中，包含了节点上传所使用的时频资源（RU）信息。</li><li>根据Trigger frame中的指示，节点选择其对应的RU位置，进行OFDMA的接入。多个节点同时向AP发送上行PPDU。</li><li>AP接收完全部数据后，反馈ACK，结束这一轮传输。</li></ul><p>  TF帧不仅仅指定了什么节点发，还指定了节点的发送一系列参数，如下图：</p><p>  ![TF帧](802.11AX MAC层接入机制/v2-40798acd9390959006eb515d18831499_720w.png)</p><p>  其中第一列是该RU被分配给那个用户（具体是指定用户的AID），如果AID设置为RA（协议中RA的AID号还没给定，即TBD），那么该RU就是供节点竞争的。后面的几列包含了比如Coding Type以及MCS值，这一块细节较多，暂时不展开。</p><p>  以上就是一个TF的接入框架，对比传统的802.11有以下不同：</p><ul><li><strong>单节点接入和多节点接入：</strong>传统的802.11中，都是单个节点占据整个信道的。在TF中，多个节点基于OFDMA，同时接入信道。</li><li><strong>发起者不同</strong>：在传统的802.11中，节点只要竞争到信道，就可以立刻发起传输。而在TF中，只有当AP发送了TF帧之后，节点才可以发起上行接入竞争。</li><li><strong>ACK反馈时机不同</strong>：在传统802.11中，ACK是在发送完之后，立刻被反馈的。而在TF中，ACK实际上是等所有用户都传输完之后，再一次反馈给所有接受者的。由于每一个发送者可能发送的数据包长短不一，所以先发送完的，需要等待后发送完的。这一点实际上也是多用户接入协议一个设计的公共问题。</li><li><strong>使用场景不同</strong>：基于以上的几点不同，我们还可以理解，TF机制本身就是在假定网络是工作在基础架构的情况下，进行的设计，其不好在IBSS网络情况下工作。而传统802.11中的DCF设计，是既可以在基础架构模式下，也可以在IBSS模式下工作的。</li></ul><blockquote><p>注：802.11ax中不是完全把DCF删除，而是分时采用不同的模式。TF机制主要是用在上行接入这一部分的。</p></blockquote><h1 id="TF-R机制（Trigger-Frame-for-Random-access）">4 TF-R机制（Trigger Frame for Random access）</h1><p>  TF-R是基于TF的进一步扩展，是在TF机制中，引入了竞争的机制，其基本思想是Slot-Aloha。</p><p>  ![TF-R接入机制](802.11AX MAC层接入机制/v2-c5996e9a2c4a167b20f559a9e1483238_720w.png)</p><p>  TF-R是将原来时域竞争转为频域竞争（如左边红色竖线上所示）。</p><p>  TF-R是在前面所述的TF过程之前执行的，在每一次接入时，AP首先发送TF-R帧，在该帧中的部分RU其相应AID=X，这个X代表这个RU是供节点竞争接入的。节点在识别到TF-R帧之后，具体是采用OBO（UL-OFDMA Backoff）的机制竞争（TF-R的接入思想是基于Aloha而不是CSMA的主要原因也在这里）。</p><blockquote><p>注：Aloha和CSMA的核心区别在于LBT（Listen Before Talk）机制上：Aloha是没有LBT的，而CSMA是基于LBT的。</p></blockquote><p>  在OBO中，每一个节点首先从CWO（Contention Window for UL-OFDMA）窗口中，选择一个随机数并放入Backoff counter中。</p><p>  如上图，STA1选择的是10，STA2选择的是4，STA3选择的是0。</p><p>  然后节点比较，这一轮TF-R帧中，可供竞争的RU slot的数目，比如上图RU数目为3。若Backoff counter小于RU的总数（比如STA3选择为0，其小于3），那么节点就可以发送数据，反之不行。那么该节点就随机选择一个RU（比如上图，从3个中随机选择1个，即RU=3），然后在该RU上进行数据传输。</p><p>  当RU=3被竞争之后，开始下一个的TF-R。此时节点首先要进行Backoff过程，即本地的Backoff counter要减去上一轮总的竞争RU数目（比如STA2选择为4，那么要减去3，即将Backoff counter设置为1）。若新的一轮中节点的Backoff counter小于这一轮的可供竞争的RU数目（比如STA2现在Backoff counter为1，RU数目为2），那么该节点竞争胜利，可以任意选择一个RU（比如选择RU=1）。</p><p>  只有当TF帧中，有被用来Random Access的RU的时候（即TF-R帧），其才会触发OBO的过程，若该TF帧中没有这种RU，那么不会进行Backoff。</p><p>  当RU资源被竞争好以后，AP发送TF帧，节点正式向AP反馈上行数据，其过程就和我们之前所述的TF过程一样了。</p><blockquote><p>注：Slot-Aloha的思想是用来判断节点在这个时刻可不可以发送，并没有包含在哪个位置具体传输的机制。故OBO主要是用来判断，节点能不能发的，至于使用哪个信道具体发送，那么这里是随机的。这一块可能有性能评估的问题，不过目前协议是这样设定的。</p></blockquote><h1 id="TF帧">5 TF帧</h1><p>  当进行上行（UL-OFDMA）或者下行（DL-OFDMA）传输时，都需要触发帧（Trigger Frame）来实现多用户通信间，调度信息的交换。触发帧也用户MU-MIMO间帧的交换。例如，AP使用触发帧将OFDMA RU分配给WiFi6客户端。</p><p>  ![Trigger Type subfield encoding](802.11AX MAC层接入机制/image-20210413145008785.png)</p><p>  触发帧包含了多种子类型，其在802.11ax中提供了很多重要的功能。上图列举了802.11ax中触发帧具体对应的子类型。</p><p>  触发帧中包含了有关RU资源分配的信息，RU分配信息分别存放在PHY和MAC层来发送给客户端。</p><p>  在物理层，可以在触发帧的HE-SIG-B字段中找到RU分配信息，HE-SIG-B字段用于将RU分配信息传达给客户端。</p><p>  如下图所示，HE-SIG-B由两个字段组成：公共字段（common filed）和用户特定字段(user specific filed)。公共字段用于指示如何将信道划分为各种RU。例如，一个20MHZ的信道可能被细分为一个106-tone的RU和四个26-tone的RU。用户特定字段包括多个用户字段，用于表示将哪些用户分配给每个单独的RU。</p><p>  ![RU allocation at the PHY layer](802.11AX MAC层接入机制/image-20210412222340737.png)</p><p>  在MAC层，RU分配信息存在触发帧的用户信息字段中。如下图显示了如何在MAC层传递RU分配信息。</p><p>  ![RU allocation at the MAC layer](802.11AX MAC层接入机制/image-20210412225905723.png)</p><p>  在下图中，触发帧将特定的RU分配给三个客户，以在20MHZ OFDMA信道上同时进行上行链路传输。</p><p>  ![RU allocation with trigger frames](802.11AX MAC层接入机制/image-20210412232604536.png)</p><p>  对于UL-OFDMA，AP发送的触发帧还用于告诉客户端在其分配的RU上传输上行链路时要使用多少空间流以及要使用那种调制和编码方案（MCS）。这些信息分布在触发帧的Payload中的user information字段（即其中SS Allocation和UL-MCS）内。</p><p>  ![User Info field format](802.11AX MAC层接入机制/image-20210413145356572.png)</p><p>  AP还可以通过触发帧来调整802.11ax终端的发送功率。在触发帧内的UL Target RSSI子字段上，其按照dBm标注了AP所期待的接收功率（通过所有天线接收到的总功率）。这个功率也是根据RU来分配的，每一个RU分配的字段都有对应的UL Targer RSSI字段。UL Target RSSI字段采用0-90的数值来映射-110dBm到-20dBm，并且其数值127代表其时采用最大功率来发送的。基于触发帧的信息，802.11ax终端在其能力范围内调整功率，由于终端的能力不同，所以这个功率时一个期望功率，当终端的硬件或者地方监管限制（比如说法定的无线电的发射功率限制），那么可能终端就无法调节。</p>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11AX MU-MIMO</title>
      <link href="posts/7394c9cb.html"/>
      <url>posts/7394c9cb.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="简介">1 简介</h1><p>MU-MIMO是基于多天线技术的，这个技术的物理层是多天线技术。多天线可以实现多种技术，不仅仅是MU-MIMO，如下图所示：</p><p><img "" class="lazyload placeholder" data-original="https://pic2.zhimg.com/80/v2-7b82d624afda64bdea78879ad6778095_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img">参考：aruba的802.11ax白皮书</p><p>上图中，我们可以看到多天线可以做CSD，TxBF，STBC，SDM，MRC等等，这些技术全部在802.11协议中都有应用。这里细节很多，本文不展开了，相关技术我可能会在该技术用到地方再提到。</p><p>MU-MIMO的实现是结合波束成型的，波束成型有两种实现方式，一种是智能天线波束成型，一种是基于全向天线的波束成型。在CWNA一书中，已经给出了其定义。</p><p>具体描述如原文：</p><p><img "" class="lazyload placeholder" data-original="https://pic4.zhimg.com/80/v2-64e5de8582d187bdf1c3e1eff95959bf_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><p>翻译版：</p><p><img "" class="lazyload placeholder" data-original="https://pic2.zhimg.com/80/v2-81e50acb85a337098fd811a4501e81fd_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><p>MIMO包含2D-MIMO和3D-MIMO两种，目前5G NR已经有3D-MIMO的波束了，Wi-Fi 6里面还停留在2D-MIMO上。打个比方就是说利用定向天线，天线辐射可以参考手电筒打光，波束的概念就是从光束来的，手电筒打的光就是定向的光束，同理，定向天线辐射的信号就是定向的波束。如果发送和接收方同时用两个手电筒打信号，那么一次性就可以传递更多的信息，这种多天线的发送方式就是MIMO。</p><p>MIMO和全双工存在区别，MIMO模式下两根天线，只能够同时处于发送，或者接收状态。而全双工可以一根天线是发送状态，一根是接收状态。（PS：全双工也可以通过EBD之类的设备，一根天线实现全双工，这里不加以讨论）</p><p>MIMO的概念比较多，是针对多根天线而言的，主要是两个概念分集和复用。如果有多个通路的时候，比如有两个通路。我们可以简单理解如下，如果两个通路传同一个信息，那么就是分集。如果两个通路传两个不同的信息，那么就是复用。在802.11协议的相关培训书籍里面，这个概念实际上给的是比较粗的解释，MIMO 实际上是分集和复用结合的技术，波束成型是发送分集。</p><p>在我们常用的路由器中都是配备了全向天线。利用全向天线实现定向天线实际上是基于干涉抵消的机制来做的，通过预编码，让数据流通过两根天线具有一定的相位差发送出去，达到接收方接收功率叠加，或者干扰方接收功率抵消的效果。</p><p>预编码可以通过数字编码的形式添加相位差，目前Wi-Fi就是采用这一种。移动通信（比如LTE或者5G NR）里面方式多了一种是电相位差，是通过基带连接到RF这一段的线路上，通过线路的长度差异来做相位差。总之，有了相位差就可以做波束成型了。2维平面上的干涉抵消就是2D-MIMO，3维平面就是3D-MIMO了。</p><p>然后需要回顾下，基于MIMO技术，可以做到多发多收。基本的MIMO就是，一个发送者有两根天线，一个接受者有两根天线，发送者一次用两根天线发，接受者用两根天线收，然后两倍传输速率，这个就是802.11n时代做的MIMO技术。</p><p><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/80/v2-ed1f8f95958911e0579449cd1906e21e_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img">WRT54M路由</p><p>多天线不等于MIMO，在802.11g时代，就有多天线了，Cisco当时的经典路由WRT54M就是多天线的，但是这个不是做MIMO，是做天线选择（实际上也是分集的一种），一次只用一根天线发，但是有可能用左天线，有可能用右天线，也有可能交替（技术上这属于发送分集）。在DD-WRT下我们还可以看到这个选项，如下图</p><p><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/80/v2-793005cf8a37fcc70c933f571ca2443e_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img">DD-WRT的配置界面</p><p>MIMO是两根天线同时发，同时在物理上两根天线需要差半个波长距离，另外两根天线不能够发送相同的信息，要编码之后，否则就会存在默认的干涉效果，对通信无意义。经过预编码后，两根天线才可以同时发送（编码后的对应两根天线上的数据不同）。</p><p>LTE，5G NR和Wi-Fi相比，在波束这一块思想差不多，不过具体实现的时候取目标函数会有点区别，前两者可能偏向波束追踪，也就是目标接收功率最大化，Wi-Fi里面是偏向对其他人的干扰最小化（比如interference nulling技术），用干扰抵消的原理来说明，就是前两者偏向干涉叠加最大，后者偏向干涉抵消最强，这会影响一些预编码结构的设计。所以Wi-Fi强调的是多个波束覆盖到多个用户，各个用户之间不会进行干扰。</p><p>在Wi-Fi中，802.11ac仅仅支持下行的MU-MIMO传输。到802.11ax，也就是wi-fi 6以后才支持上行的MU-MIMO传输。</p><h1 id="MU-MIMO和OFDMA">2 MU-MIMO和OFDMA</h1><p>在MAC层协议部分，MU-MIMO的传输和OFDMA传输的过程很像，都是一开始一个TF帧，然后开始一个传输。两个可以叠加，不过先导过程不一样。</p><ul><li>OFDMA过程的先导是BSRP,BSR过程，就是问缓存情况，然后做OFDMA资源分配。如果没有先导过程的话就是UORA，基于随机接入的竞争模式。协议中还有一个BQRP，类似于BSRP但是关注的参数不一样，这也是用来做资源分配预判的，这里就不展开了。</li><li>MU-MIMO的先导过程是NDPA,NDP,beamforming reporting，这样的过程是一个测量过程，测量每一个节点的信道状态，也就是CSI，然后基于该CSI做预编码（协议里面要旋转矩阵）。</li></ul><p>同时我们需要注意的是，这两个先导机制都包含了主动模式和被动模式（也就是隐式反馈的模式），这也说明了两者在MAC层协议上的类似性。</p><p><img "" class="lazyload placeholder" data-original="https://pic1.zhimg.com/80/v2-a6f2cf307f37c45d32e1c538306c12ec_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img">NDP过程</p><p>另外这两个先导的过程，NDP和BSR过程也可以结合起来一起使用，如下图</p><p><img "" class="lazyload placeholder" data-original="https://pic1.zhimg.com/80/v2-7ba685ee6b0c0c4bb624693650913d18_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img">参考：Aruba的802.11ax白皮书</p><p>有了测量矩阵才可以做编码，所以MI-MIMO会做这样的过程。协议没有给定BSR，NDP这样的测量过程和传输过程的关系，所以不是每一次传输都需要测量一次，可选，也可不选。测量周期也是给开发商自己搞定的。关于NDP过程而言，其实与应用场景有关，Wi-Fi大概是100ms左右就可以了，这个从理论上有一个概念，叫做海森堡时间。</p><p><img "" class="lazyload placeholder" data-original="https://pic2.zhimg.com/80/v2-9b6638ec2f970435122174f0bdcf87a9_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img">参考：802.11ac: A Survival Guide</p><p>然后有了BSP和NDP过程后，就可以执行一次传输了。这个传输过程内，可以做MU-MIMO，可以做OFDMA，也可以做OFDMA+MU-MIMO，协议不规定，给开发商自己折腾的。但是前提是要先导过程，有获取了足够信息。</p><p>还有点需要注意的是，目前Wi-Fi协议都是任意长数据帧的，不像LTE，5G NR一样，始终是按照一个小资源片的时间封帧，也就是其帧，半帧之类大小都是固定的，所以没有帧长度不等的问题。</p><p>Wi-Fi中只有一个最大帧传输时间和最大帧长度的限制，这个大小随着协议演进过程中是有变化的。下图所示是截至802.11ac目前的最大值：</p><p><img "" class="lazyload placeholder" data-original="https://pic1.zhimg.com/80/v2-91f9ce48c6ffd8c1174b1608636a92a0_720w.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img">参考：802.11-2016版本</p><p>在Wi-Fi中，由于是多用户同时传输，无论上行还是下行，都是存在帧长度不等的。一个基本思想是补，补随机的东西弄到长度相等。在802.11ac里面，由于只有下行发送，所以发送时间是按照最长帧来的，其他短的不够就补。在802.11ax里面，由于引入上行传输，那么传输时间是AP猜的，根据BSR之类的信息来猜的，所以这段时间有可能会长，长就补0，如果短的话，那么引入了一个新概念，就是动态帧切片，把帧给切短了，然后发送。以上这点在动态帧切换中我们已经讨论过了，所以这里就不展开了。</p>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11AX OFDMA</title>
      <link href="posts/792c3209.html"/>
      <url>posts/792c3209.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="序言">1 序言</h1><p>参考资料：</p><p><a href="https://www.extremenetworks.com/extreme-networks-blog/">What are OFDMA Resource Units in 802.11ax?</a></p><p><a href="/books/Wi-Fi_6_FD_Extreme_Networks_Special_Edition.pdf">Wi-Fi_6_FD_Extreme_Networks_Special_Edition</a></p><p><a href="/books/Draft_P802.11ax_D8.0.pdf">Draft P802.11ax_D8.0.pdf</a>第27.3.2节(Subcarrier and resource allocation)</p><p><a href="https://www.extremenetworks.com/extreme-networks-blog/ofdm-and-ofdma-subcarriers-what-are-the-differences/">OFDM and OFDMA Subcarriers – What Are the Differences?</a></p><h1 id="简介">2 简介</h1><p>无线和有线通信不同。有线通信中信息是承载在线缆上，通过高低电平来标识不同的信息010010。但是在无线通信中，信息的载体就变成了高频信号，这种将信息加载到某个高频信号进行传播的过程就叫做载波调制，而承载着信息的高频信号，我们也称之为载波。拿日常生活中的例子来说，Wi-Fi通信类似快递送货，载波就像是送货的小车，发送方通过载波调制将货物(信息)放到小车上再送达到接收方。</p><img "" class="lazyload placeholder" data-original="/posts/792c3209/093931auljualk348u3gik.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="载波调制" style="zoom:50%;"><p>不过这些频段不仅Wi-Fi可以用，其他短距无线传输技术比如RFID、蓝牙等，也都可以使用，所以干扰也很多。</p><p>在Wi-Fi 4/5，载波调制用的是正交频分复用OFDM（Orthogonal Frequency Division Multiplexing）技术。</p><p>OFDMA技术是802.11ax引入了新的物层机制，其可以让多个用户并行进行接入。</p><p>由于引入了OFDMA技术，所以需要定义时频资源块（Resource Unit）的概念，这些时频资源块都是彼此正交的。802.11ax中的OFDMA实际上是借鉴LTE的，但是没有LTE资源块那么复杂（比如RE，RB，CP，REG，CCE这些），802.11ax中仅仅有RU（Resource unit）的概念。</p><p><img "" class="lazyload placeholder" data-original="/posts/792c3209/v2-87a082c97fe8b36c6bd5332b36366737_720w.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="OFDMA"></p><p>以上图为例，左图是OFDM的工作模式，右图是OFDMA的工作模式。图中一共有4个节点，分别以4种颜色进行标识。图中横轴为时域，纵轴为频域（即对应不同的子载波）。</p><ul><li><strong>OFDM工作模式</strong>（左图）：用户是通过不同时间区分出来的。每一个时间片段，一个用户完整占据全部的子载波，并且发送一个完整的数据包（如图中红色部分标出的WLAN Packet）。</li><li><strong>OFDMA工作模式</strong>（右图）：用户是根据时频资源块RU区分出来的。首先将整个信道的资源分成一个个小的固定大小的时频资源块，这个时频资源块也就是RU（Resource unit）。在该模式下，用户的数据是承载在每一个RU上的，故从总的时频资源上来看，每一个时间片上，有可能有多个用户同时发送。</li></ul><p>OFDMA相比OFDM一般有两点好处：</p><ul><li><strong>资源的更细腻分配</strong>。特别是在部分节点信道状态不太好的情况下，可以根据注水定理的思想（即根据信道质量分配发送功率），来更细腻化的分配信道时频资源</li><li><strong>能够更好的提供QOS</strong>。因为初始的802.11是占据整个信道的，如果有一个QOS数据包需要发送，其一定要等之前的发送者释放完整个信道才行，所以会存在较长的延迟。在OFDMA的情况下，由于一个发送者只占据部分信道，所以能够减少QOS节点接入的延迟。</li></ul><p>拿小车来举例，OFDMA相当于在小车中划出专门的隔间，通过调度每个隔间放置不同用户的货物，这样一次可以为多个接收方送货。</p><img "" class="lazyload placeholder" data-original="/posts/792c3209/093958hy2qj6spsqo4akzj.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="OFDMA比喻" style="zoom:50%;"><p>OFDMA没有多天线的要求，在单天线条件下，也可以做到OFDMA。</p><p>资源片段会根据需求被分配到各个用户上。这里要区分上下行，如果是下行的话，那么AP直接发送一个数据帧即可，当然，该帧内部的资源映射关系是提前告知用户的，Wi-Fi帧中是通过Trigger帧告知。用户实际上可以解调所有的信息，即全部片段都可以解调，然后根据映射关系，选取自己的信息即可。安全性是通过数据层的加密完成的。</p><p>上行的话，Wi-Fi是允许上行的OFDMA。OFDM有一个问题就是PAPR，峰均比，也就是所有的子载波由于是周期成倍数关系的，所以如果所有子载波都是加载相同数据的时候，出来的峰值就是所有子载波上单位峰值的叠加。如果大家都是1，那么这个1冲到很高，如果大家都是0，那么就是0，换言之是0（打个比方，虽然传输的时候是用双极性的，所以不会有0的存在）。（这样峰值和均值的区间很大，就会对放大器的工作区有要求)</p><ul><li>LTE子载波多，一共2048个，所以峰均比空间大，最后就没有采用OFDMA做上行。LTE的上行是SC-FDMA。主要原因是PAPR高，但是不是技术不可行，是相应实现时候，PA需要更高的成本，以及会产生更高的功耗。</li><li>Wi-Fi子载波最多256个（上述都是在20MHz信道带宽下），所以峰均比还可以承受，所以上行可以允许OFDMA。</li></ul><p>目前OFDMA在Wi-Fi 6里面是一次性添加了上行和下行，下行在整个接入过程中很简单，AP抢到的信道，然后发送即可。上行接入的时候包含了有两种接入方式，一共是基于竞争的（就是UORA），一种是基于非竞争的，也就是基于BSR的，缓存情况，根据节点的缓存情况，AP进行资源分配，然后告知。其实搞两种接入方式也是和LTE类似的，LTE中在PRACH信道上也有两种接入模式，基于竞争和基于非竞争，基于竞争的是随机选择竞争序列（也就是竞争所采用的Code），而非竞争的则是通过eNodeB指定。这点上LTE和WiFi 6在框架上是类似的。</p><p>在这里还需要注意的一个是，OFDMA和CDMA一样，存在远近效应。其含义是接收方，也就是AP，在接收信号的时候，需要所有节点发送到AP处的信号功率，近似相等。如果功率差异过大，那么就不能够很好解调了。（功率差异大就是用SIC技术，而不是OFDMA技术了）。</p><p>所以在上行发送的时候，触发帧实际上包含了三个重要信息，1）资源分配，2）发送速率指定，3）功率指定。通过以上技术，在OFDMA的场景下，Wi-Fi基本和LTE能够做到的差不多了，精准的频谱资源分配。</p><h1 id="子载波">3 子载波</h1><p>在传统的802.11a/g/n/ac中，采用了正交频分复用（OFDM，Orthogonal Frequency Division Multiplexing）作为单用户传输的物理层技术。</p><p>在802.11ax中，引入了一种新型的基于OFDM的OFDMA技术，其是OFDMA对应的多用户版本，其将信道划分成更小的时频资源单元，即RU（Resource Unit）。</p><p>通过OFMDA的划分，多个用户可以并行进行传输，提高信道利用率。</p><p>每一个RU内的数据和导频，在OFDMA子信道内都是相邻而且连续的。</p><p>OFDM和OFDMA技术的实现是通过快速傅里叶变换（FFT）和快速傅里叶逆变换（IFFT）来构成的。</p><p>在OFDM中，信道被分成了多个子载波，每一个子载波是正交的，不会互相干扰，所以其子载波之间是没有保护间隔的。</p><p>在OFDM中，也会分配一个子载波作为Null子载波，其不承载任何数据，用来防止载波间干扰（Inter-Carrier Interference ，ICI）。</p><p>OFDM和OFDMA都通过一个数学函数（快速傅里叶逆变换）IFFT将信道划分为子载波。</p><p>如下图所示，802.11n/ac 20MHZ信道带宽包含64个子载波。其中52个子载波用于承载调制数据（data subcarriers），4个用于导频载波（pilot subcarriers），8个作为保护频带（grard bands）。每个OFDM子载波间隔为312.5KHZ，也就是3.2us。OFDM子载波可以称为OFDM subcarriers或者OFDM tones。</p><p><img "" class="lazyload placeholder" data-original="/posts/792c3209/image-20210412161728872.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="802.11n/ac 20 MHz channel – OFDM subcarriers"></p><p>在802.11ax中，相同的信道带宽采用的FFT的点数增加4倍。比如原来20M信道采用64点的FFT（即64个子载波），现在就变成了256点的FFT（即256个子载波）。</p><p>OFDMA子载波间隔为78.125KHZ，也就是12.8us。因此如下图所示，由于存在78.125KHZ的间隔，OFDMA 20MHZ通道总共包含256个子载波（tone）。</p><blockquote><p>更窄的子载波间隔，允许会提供更高的频域分辨率，提升均衡能力，并且增强信道鲁棒性</p></blockquote><p><img "" class="lazyload placeholder" data-original="/posts/792c3209/image-20210412163150100.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="OFDM and OFDMA subcarrier spacing"></p><p>类似于OFDM一样，OFDMA存在三种类型的子载波：</p><ul><li><strong>数据子载波</strong>（Data subcarriers）：这些子载波用于承载数据，其传输速率是在802.11ac的基础上（即在802.11ac的MCS上），引入了两个新的MCS（Modulation and Coding Schemes），包含1024-QAM这种更高的调制阶数。</li><li><strong>导频子载波</strong>（Pilot subcarriers）：这些子载波用于发射器和接收器之间的同步，并且不携带任何调制数据。</li><li><strong>未使用的子载波</strong>（Unused subcarriers）：剩余未使用的载波主要用于保护子载波（gard carriers）或者空子载波（null carriers），以抵抗来自相邻信道或相邻子信道的干扰（即抵抗ICI）。</li></ul><p>利用OFDMA，这些子载波组合在一起成为分区子信道，也成为资源单元（RU）。通过将信道进行进一步的细分，发送到多个用户的比较小帧可以同时传输。在OFDMA信道内，每个资源单元内的数据和导频子载波既相邻又连续。</p><blockquote><p>为了兼容早期的其他802.11协议，802.11ax仍将支持OFDM。在802.11ax中，管理帧和控制帧仍将使用802.11a/g/n/ac的OFDM技术，以及以基本的传输速率进行传输（一般就是最低传输速率），这保证了其他早期的802.11终端能够互相理解。此时管理帧和控制帧都是采用整个20MHz信道，利用整个64个子载波进行传输。OFDMA技术仅仅用于802.11ax AP和802.11ax终端之间的数据帧交互。</p></blockquote><p>在802.11ax中，20M信道一共有256个子载波，而实际资源块RU总共只使用了234个，两者相差了22个子载波。这些子载波是用来做保护间隔的：包含了DC，Null Sub-carriers以及Guard Sub-carriers，如下图：</p><p><img "" class="lazyload placeholder" data-original="/posts/792c3209/image-20210412143049142.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="RU locations in a 20 MHz HE PPDU"></p><p>图中分别列举了RU为26,52,106个子载波的情况，我们具体解释如下：</p><ul><li><p><strong>DC保护</strong>：以<strong>中心子载波</strong>为核心，一共有7个子载波作为DC保护的，即DC的保护带宽一共是7*78.125kHz=546.875kHz，与原来的一个DC保护（即312.5kHz）是比较接近的。</p></li><li><p><strong>Guard Sub-carriers</strong>：保护子载波这里指的是<strong>信道之间的保护子载波</strong>了（比如20MHz信道之间的保护），如上图所示，其选取了左边的6个子载波以及右边的5个子载波作为保护，这点设计是和802.11a的载波设计是一样的，只是子载波的带宽不一样而已。</p></li><li><p><strong>Null Sub-carriers</strong>：在一些早期的书里面，比如《MIMO-OFDM Wireless Communications with MATLAB》，其中是将Guard Sub-carriers和Null Sub-carriers等价看待的。不过在802.11ax中，Null子载波是指的<strong>RU之间的保护间隔</strong>，一般是1个子载波。</p></li></ul><p>下面这张彩图可能更清晰一些：</p><p><img "" class="lazyload placeholder" data-original="https://pic2.zhimg.com/80/v2-b954e40221673d43b26dbde3c69958c1_720w.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="RU locations in a 20 MHz HE PPDU"></p><p>以RU为26所示，这里一共损耗了6+1+1+7+1+1+5=22个子载波。</p><p>最后介绍一下在802.11ax中，导频子载波（Pilot）的设计。</p><ul><li><p>导频子载波是用来做信道估计的，利用估计出的信道系数完成解调的工作。</p></li><li><p>由于802.11ax还是一个分布式接入的工作，所以<strong>Pilot是包含在每一个RU内部的</strong>。</p></li><li><p>在802.11中，始终是用特定的子载波作为导频子载波，从而完成信道估计的功能，在802.11ax中，导频子载波的分配如下：</p></li></ul><p><img "" class="lazyload placeholder" data-original="https://pic2.zhimg.com/80/v2-57e6b71de33ab680e7c40b4438b7e0f1_720w.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="pilot subcarriers"></p><p>其中红色的直线即代表导频子载波的位置，代表的是子载波序号，其导频资源是均匀分布在整个信道上的。</p><p><img "" class="lazyload placeholder" data-original="/posts/792c3209/image-20210412181104053.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Data and pilot subcarrier indices for RUs in a 20 MHz HE PPDU and in a non-OFDMA 20 MHz HE PPDU"></p><p>如上图所示带宽为20MHZ，RU为26时，-116号子载波为导频子载波，102号子载波为导频子载波。也就是每个RU的第6个子载波为导频子载波，倒数第七个为导频子载波。</p><p>在RU为26个子载波的情况下，每一个RU中都包含了2个pilot，在RU为52个子载波的情况下，每一个RU包含4个pilot。通过这些pilot的设置，在传输过程中，接收方才可以有效地估计信道，并完成解调的工作。</p><h1 id="OFDMA资源块RU（Resource-unit）">4 OFDMA资源块RU（Resource unit）</h1><p>在802.11ax中，一个最小的时频单位为RU。与LTE中的RE（Resource Element）和RB（Resource Block）不同，LTE中的RE和RB都是一个固定值。</p><p>在802.11ax中RU是一个相对的概念，即存在很多种不同大小的RU，如下图所示：</p><p><img "" class="lazyload placeholder" data-original="/posts/792c3209/image-20210412142128738.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Maximum number of RUs for each channel width"></p><p>图中，一共定义了6中RU类型，分别是26，52，106，242，484以及996个子载波。</p><p>正交频分多址（Orthogonal Frequency-Division Multiple Access<em>，</em>OFDMA）作为主要的802.11ax增强功能，其是OFDM数字调制技术的多用户版本。 OFDMA将信道细分为较小的资源单元RU。通过OFDMA的资源细分，多个客户端可以通过占据不同的RU资源进行并行传输。</p><p><img "" class="lazyload placeholder" data-original="/posts/792c3209/image-20210412145820774.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="OFDMA RUs – 20MHz信道带宽"></p><p>一个20MHz的OFDMA信道包含了256个子载波（Subcarriers，或者称为Tones）组成。这些子载波组成了一些子信道，我们称一个子信道为一个资源单元（RU）。如上图所示，当20MHz信道时被细分时，802.11ax终端可以使用4种不同大小的RU单元，分别包含26个子载波，52个子载波，106个子载波和242子载波，大约相当于2MHz，4MHz，8MHz和20MHz信道带宽的分别。802.11ax的AP决定了在一个20MHz信道内可以使用多少个RU，以及RU形成的不同组合。</p><blockquote><p>本人理解的是存在不同类似RU共存的情况，比如在20M带宽情况下，2个52-subcarrier RU和1个106-subcarrier RU是可以共存的。这样设计的好处在于可以更有效的分配频率资源，比如在20M的信道条件下，一共可以存在9个26-subcarrier的RU，故需要9个人竞争才可以占据全部信道，否则就会有资源浪费（在802.11ax中，每一个发送者每次只能够竞争一个信道）。所以在发送者数量不足的情况下，只有通过不均等的分配，才可以更加有效的利用信道资源。</p></blockquote><p>802.11ax AP可以将整个信道分配给一个客户端，也可以利用OFDMA技术将信道分给多个终端同时接入。</p><p>例如，802.11ax AP可以使用8 MHz的带宽与一个802.11ax终端通信，同时使用4 MHz的带宽与另外三个802.11ax终端通信。</p><p>这些通信过程可以是下行链路，也可以是上行链路。</p><p><img "" class="lazyload placeholder" data-original="/posts/792c3209/image-20210412150306471.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="OFDMA传输过程"></p><p>在上图示例中，802.11ax AP首先向Client 1和Client 2发送下行数据。</p><p>在第一时刻，20MHz的信道通过OFDMA技术被划分成了两个子信道。在OFDMA技术中，20MHz信道包含了256个子载波，Client 1和Client 2分别占据106个子载波，这些子载波互相没有交叠。</p><p>在第二时刻，802.11ax AP向Client 3，Client 4，Client 5和Client 6发送下行信息。在此时，信道被划分成4个子信道，分别占据52个子载波。</p><p>在第三时刻，802.11ax AP使用整个信道发送下行数据帧给Client 5，此时一共使用了242个数据子载波，其可以有效的利用整个20MHz的信道。</p><p>在第四时刻，AP使用两个子信道，分别是106个子载波向Client 4和Client 6发送数据。</p><p>在第五时刻，AP在此向单个终端（即Client 1）发送下行数据，其占据整个20MHz信道，包含242个数据子载波。</p><p>在第六时刻，AP同时向Client 3，Client 4和Client 6发送下行数据。此时，信道被划分成3个不等大小的子信道，其中Client 3和Client 4分别占据52个子载波，Client 6占据106个子载波。</p>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11AX协议简介</title>
      <link href="posts/49182bdb.html"/>
      <url>posts/49182bdb.html</url>
      
        <content type="html"><![CDATA[<h1 id="序言">1 序言</h1><p>参考资料：</p><p><a href="https://www.ni.com/zh-cn/innovations/white-papers/16/introduction-to-802-11ax-high-efficiency-wireless.html">Introduction to 802.11ax High-Efficiency Wireless</a></p><p><a href="https://forum.huawei.com/enterprise/zh/forum.php?mod=viewthread&tid=639329">WLAN从入门到精通-WIFI6</a></p><p><a href="https://www.extremenetworks.com/wifi6/what-is-80211ax/">What is 802.11ax (Wi-Fi 6)?</a></p><h1 id="什么是wifi6">2 什么是wifi6</h1><p>说起Wi-Fi 6，其实是Wi-Fi联盟对IEEE的最新一代无线局域网标准802.11ax的命名。<br>这里面讲到了2个组织IEEE和Wi-Fi联盟。</p><p>首先介绍一下电气和电子工程师协会IEEE（Institute of Electrical and Electronics Engineers）。</p><p><img "" class="lazyload placeholder" data-original="/posts/49182bdb/151355ph5nyjtdkb8frbxt.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Institute of Electrical and Electronics Engineers"></p><p>IEEE作为标准组织，通信人应该非常了解，有兴趣可以百度一下。在该组织制定的一系列标准中，通信人最熟悉802.3标准对应以太网，而属于无线局域网的就是802.11。早在1990年，IEEE就已经成了802.11工作组用来制定无线局域网的相关标准，并在1997年发布了第一个标准802.11-1997。之后的每4-5年，802.11标准就会升级换代一次，至今已有6代。</p><p><img "" class="lazyload placeholder" data-original="/posts/49182bdb/151043pqg616mmve8a3q1j.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="802.11升级过程"></p><p>而另一个组织，Wi-Fi联盟（英语全称Wi-Fi Alliance，简称WFA），其实是一个商业组织，这个联盟最初的目的是为了推动802.11b标准的制定，并在全球范围内推行Wi-Fi产品的兼容认证。兼容认证其实非常重要，因为802.11标准是很理论化，一旦产品化，每家厂商有可能会做的五花八门，所以Wi-Fi联盟所要解决的就是不同厂家的兼容性，此外Wi-Fi联盟还负责产品测试等工作。</p><p><img "" class="lazyload placeholder" data-original="/posts/49182bdb/152808aef9ogfirof0r5hc.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Wi-Fi Alliance"></p><p>我们现在熟悉的大部分手机厂商、部分运营商都是这个联盟的成员。<br>而我们常常说的Wi-Fi，实际上就是来自Wi-Fi联盟的商标。Wi-Fi联盟把符合802.11标准技术统一称为Wi-Fi。</p><p>2018年，为了方便记忆和理解，Wi-Fi联盟终于决定抛弃之前802.11n、802.11ac等专业标准名称，仿照移动通信中代际3G、4G、5G的划分，将现有标准简化为数字命名。</p><p><img "" class="lazyload placeholder" data-original="/posts/49182bdb/151136t23q4r4mx21b2tq3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="WiFi数字命名"></p><h1 id="802-11ax简介">3 802.11ax简介</h1><p>802.11ax是在802.11ac以后，无线局域网协议本身的进一步扩展，可以当做ac以后的一个直系版本。其初始的命名代号为HEW（High Efficiency WLAN ），该起始于2013年。</p><p>802.11ax的使用场景关注于密集用户环境（Dense User Environments），与之前的协议有所不同。根据香农定理<img "" class="lazyload placeholder" data-original="https://www.zhihu.com/equation?tex=C=Blog_%7B2%7D+%5Cleft(+1+SNR+%5Cright)+" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="香农定理">而言，当SNR不变的情况下（由于发送机总功率是固定的），只要适当的增加带宽，就可以获得更高的物理层吞吐量。所以802.11a/b/g/n/ac的演进，一般都是关注在单AP的网络中，提高物理层的吞吐量，以提高网络的整体速率。</p><p>802.11ax的设计场景初始关注的就是密集环境，换言之，其初始设计思想就会和传统的802.11存在一定的区别。而且802.11ax的设计也并没有在当前802.11ac的160M带宽以上，新增更大的带宽（其实也是在2.4G和5G频谱资源下，无法找到更大带宽的信道）。所以协议命名的HEW，其关注的效率，也是希望更加有效的使用当前的频段资源，从而提供更高的实际网络速率。我们可以简单总结802.11ax的以下特点：</p><h2 id="协议兼容性">3.1 协议兼容性</h2><p>802.11ax要求与以往的802.11a/b/h/n/ac都进行兼容，这也证明了其是第二款同时能工作在2.4G和5G频段下的协议（802.11ac仅工作在5G频段）。故在其数据帧结构和MAC接入协议上，都需要兼容设计，以便于传统协议兼容。</p><h2 id="更高的速率">3.2 更高的速率</h2><p>过去每一代Wi-Fi的标准，一直致力于提升速率。</p><p><img "" class="lazyload placeholder" data-original="/posts/49182bdb/151155agcncgezdghaappp-7762481.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="WiFi不同版本的最高速率"></p><p>经过20多年的发展，Wi-Fi 6（802.11ax）在160MHz信道宽度下，理论最大速率已经达到9.6Gbps，是802.11b的近900倍。</p><p>而Wi-Fi 6速率的提升是因为采用了更高阶的1024-QAM、更多的子载波等技术。</p><p>① <strong>提供更高阶的编码组合</strong>（MCS10和MCS11）。其中主要是QAM-1024的引入，在802.11ac中，最高阶是256QAM。</p><p><img "" class="lazyload placeholder" data-original="/posts/49182bdb/v2-23e7a0aea03ab5cf9979acfe80272789_720w.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="QAM-1024"></p><p>  ② <strong>在相同带宽下，802.11ax采用点数更多的FFT</strong>（即原始的FFT的4倍大小）。FFT点数越多，说明其子载波数越多，以及子载波的带宽也就越小（带宽从312.5kHz降到78.125kHz。其对应的symbol时间也增加了4倍），从而可以覆盖更远的范围。（覆盖范围与相干带宽有关。只要信道的带宽小于相干带宽的话，那么就是平坦衰落，信号不会受到多径的影响。所以越小的信道带宽，可以覆盖更远的范围）</p><p><img "" class="lazyload placeholder" data-original="/posts/49182bdb/v2-693acb951a420a431164d2b9eac7c78b_720w.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="fft"></p><h2 id="高并发">3.3 高并发</h2><p>  ① <strong>引入上行MU-MIMO</strong>。</p><p>Wi-Fi 6引入了5G中的OFDMA和上行MU-MIMO等多用户技术，进一步提升了频谱利用率，使得Wi-Fi 6相比于Wi-Fi 5，并发用户数提升了<strong>4倍</strong>。</p><p><img "" class="lazyload placeholder" data-original="/posts/49182bdb/151218yltjwjnt116ry6gr.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="WiFi5和WiFi6的并发性"></p><p>在802.11ac中，协议只规定了下行的MU-MIMO。上行还是单个节点独立传输的，而在802.11ax中，上下行都需要支持MU-MIMO。</p><p><img "" class="lazyload placeholder" data-original="/posts/49182bdb/v2-c38c6eac16d6a23c4deeacdbbb34808c_720w.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="MU-MIMO"></p><p>  ② <strong>引入OFDMA技术</strong>。802.11ax设计中参考了LTE中OFDMA的使用，可以让多个用户通过不同子载波资源同时接入信道，提高信道的利用率。不过因为802.11是一个分布式接入的场景，所以802.11ax中的OFDMA实际是比LTE中复杂度要低一些。</p><p><img "" class="lazyload placeholder" data-original="/posts/49182bdb/v2-8a40e3e461980dd315b5d08ce8d88894_720w.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="OFDMA"></p><p>至于其中一些具体的介绍和一些其他的特性，建议参考NI的文章：<a href="https://www.ni.com/zh-cn/innovations/white-papers/16/introduction-to-802-11ax-high-efficiency-wireless.html">Introduction to 802.11ax High-Efficiency Wireless</a>。</p><h2 id="更好的节能性">3.4 更好的节能性</h2><p>用以增加移动设备的续航能力</p><p>随着IoT设备广泛应用，除了提升终端速率外，Wi-Fi 6更是关注了终端的耗电情况。</p><p>Wi-Fi 6采用TWT技术，按需唤醒终端Wi-Fi，加上20MHz-Only技术，使得终端的功耗降低**30%**。</p><p><img "" class="lazyload placeholder" data-original="/posts/49182bdb/151248d0fxmtavpramxrty.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="功耗对比"></p><h2 id="降低时延">3.5 降低时延</h2><p>在低时延场景，例如VR/AR-互动操作模拟、全景直播、互动式游戏、沉浸式会议、高清无线投屏等，Wi-Fi 5的30ms时延已经无法满足需求，而Wi-Fi因为引入了OFDMA和空间复用技术BSS Coloring，令时延降低至<strong>20ms</strong>。</p><p><img "" class="lazyload placeholder" data-original="/posts/49182bdb/151234uza8ce4hd7mvz8ha.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="WiFi5和WiFi6时延"></p>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IMX6ULL芯片简介</title>
      <link href="posts/6bcb34f8.html"/>
      <url>posts/6bcb34f8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Cortex-A-处理器运行模型">1 Cortex-A 处理器运行模型</h1><p>以前的 ARM 处理器有 7 中运行模型：User、FIQ、IRQ、Supervisor(SVC)、Abort、Undef和 System，其中 User 是非特权模式，其余 6 中都是特权模式。但新的 Cortex-A 架构加入了TrustZone 安全扩展，所以就新加了一种运行模式：Monitor，新的处理器架构还支持虚拟化扩展，因此又加入了另一个运行模式：Hyp，所以 Cortex-A7 处理器有 9 种处理模式，如下表所示：</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>User(USR)</td><td>用户模式，非特权模式，大部分程序运行的时候就处于此模式</td></tr><tr><td>FIQ</td><td>快速中断模式，进入 FIQ 中断异常</td></tr><tr><td>IRQ</td><td>一般中断模式</td></tr><tr><td>Supervisor(SVC)</td><td>超级管理员模式，特权模式，供操作系统使用</td></tr><tr><td>Monitor(MON)</td><td>监视模式？这个模式用于安全扩展模式</td></tr><tr><td>Abort(ABT)</td><td>数据访问终止模式，用于虚拟存储以及存储保护</td></tr><tr><td>Hyp(HYP)</td><td>超级监视模式？用于虚拟化扩展</td></tr><tr><td>Undef(UND)</td><td>未定义指令终止模式</td></tr><tr><td>System(SYS)</td><td>系统模式，用于运行特权级的操作系统任务</td></tr></tbody></table><p>除了 User(USR)用户模式以外，其它 8 种运行模式都是特权模式。这几个运行模式可以通过软件进行任意切换，也可以通过中断或者异常来进行切换。大多数的程序都运行在用户模式，用户模式下是不能访问系统所有资源的，有些资源是受限的，要想访问这些受限的资源就必须进行模式切换。但是用户模式是不能直接进行切换的，用户模式下需要借助异常来完成模式切换，当要切换模式的时候，应用程序可以产生异常，在异常的处理过程中完成处理器模式切换。</p><p>当中断或者异常发生以后，处理器就会进入到相应的异常模式种，每一种模式都有一组寄存器供异常处理程序使用，这样的目的是为了保证在进入异常模式以后，用户模式下的寄存器不会被破坏。</p><h1 id="Cortex-A-寄存器组">2 Cortex-A 寄存器组</h1><p>ARM 架构提供了 16 个 32 位的通用寄存器(R0<del>R15)供软件使用，前 15 个(R0</del>R14)可以用作通用的数据存储，R15 是程序计数器 PC，用来保存将要执行的指令。ARM 还提供了一个当前程序状态寄存器 CPSR 和一个备份程序状态寄存器 SPSR，SPSR 寄存器就是 CPSR 寄存器的备份。这 18 个寄存器如下所示：</p><p><img "" class="lazyload placeholder" data-original="/posts/6bcb34f8/image-20210614223245870.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210614223245870"></p><p>每一种模式可见的寄存器包括 15 个通用寄存器(R0~R14)、一两个程序状态寄存器和一个程序计数器 PC。在这些寄存器中，有些是所有模式所共用的同一个物理寄存器，有一些是各模式自己所独立拥有的，各个模式所拥有的寄存器如下所示：</p><img "" class="lazyload placeholder" data-original="/posts/6bcb34f8/image-20210614223532481.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210614223532481" style="zoom:50%;"><p>其中浅色字体的是与 User 模式所共有的寄存器，蓝绿色背景的是各个模式所独有的寄存器。可以看出，在所有的模式中，低寄存器组(R0<del>R7)是共享同一组物理寄存器的，只是一些高寄存器组在不同的模式有自己独有的寄存器，比如 FIQ 模式下 R8</del>R14 是独立的物理寄存器。假如某个程序在 FIQ 模式下访问 R13 寄存器，那它实际访问的是寄存器 R13_fiq，如果程序处于 SVC 模式下访问 R13 寄存器，那它实际访问的是寄存器 R13_svc。总结一下，Cortex-A 内核寄存器组成如下：</p><p>①、34 个通用寄存器，包括 R15 程序计数器(PC)，这些寄存器都是 32 位的。</p><p>②、8 个状态寄存器，包括 CPSR 和 SPSR。</p><p>③、Hyp 模式下独有一个 ELR_Hyp 寄存器。</p><h2 id="通用寄存器">2.1 通用寄存器</h2><p>R0~R15 就是通用寄存器，通用寄存器可以分为以下三类：</p><p>①、未备份寄存器，即 R0~R7。</p><p>②、备份寄存器，即 R8~R14。</p><p>③、程序计数器 PC，即 R15。</p><h3 id="未备份寄存器-R0-R7">2.1.1 未备份寄存器 R0-R7</h3><p>未备份寄存器指的是 R0~R7 这 8 个寄存器，因为在所有的处理器模式下这 8 个寄存器都是同一个物理寄存器，在不同的模式下，这 8 个寄存器中的数据就会被破坏。所以这 8 个寄存器并没有被用作特殊用途。</p><h3 id="备份寄存器-R8-R14">2.1.2 备份寄存器 R8-R14</h3><p>R8<del>R12 这 5 个寄存器有两种物理寄存器，在快速中断模式下(FIQ)它们对应着 Rx_fiq(x=8</del>12)物理寄存器，其他模式下对应着 Rx(8~12)物理寄存器。</p><p>FIQ 是快速中断模式，看名字就是知道这个中断模式要求快速执行！ FIQ 模式下中断处理程序可以使用 R8<del>R12寄存器，因为 FIQ 模式下的 R8</del>R12 是独立的，因此中断处理程序可以不用执行保存和恢复中断现场的指令，从而加速中断的执行过程。</p><p>R13 一共有 8 个物理寄存器，其中一个是用户模式(User)和系统模式(Sys)共用的，剩下的 7 个分别对应 7 种不同的模式。R13 也叫做 SP，用来做为栈指针。基本上每种模式都有一个自己的 R13 物理寄存器，应用程序会初始化 R13，使其指向该模式专用的栈地址，这就是常说的初始化 SP 指针。</p><p>R14 一共有 7 个物理寄存器，其中一个是用户模式(User)、系统模式(Sys)和超级监视模式(Hyp)所共有的，剩下的 6 个分别对应 6 种不同的模式。R14 也称为连接寄存器(LR)，LR 寄存器在 ARM 中主要用作如下两种用途：</p><p>①、每种处理器模式使用 R14(LR)来存放当前子程序的返回地址，如果使用 BL 或者 BLX 来调用子函数的话，R14(LR)被设置成该子函数的返回地址，在子函数中，将 R14(LR)中的值赋给 R15(PC)即可完成子函数返回，比如在子程序中可以使用如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV PC, LR       @ 寄存器 LR 中的值赋值给 PC，实现跳转</span><br></pre></td></tr></table></figure><p>或者可以在子函数的入口出将 LR 入栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH &#123;LR&#125;        @ 将 LR 寄存器压栈</span><br></pre></td></tr></table></figure><p>在子函数的最后面出栈即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POP &#123;PC&#125;         @ 将上面压栈的 LR 寄存器数据出栈给 PC 寄存器，严格意义上来讲应该是将</span><br><span class="line">                 @ LR-4 赋给 PC，因为 3 级流水线，这里只是演示代码。</span><br></pre></td></tr></table></figure><p>②、当异常发生以后，该异常模式对应的 R14 寄存器被设置成该异常模式将要返回的地址，R14 也可以当作普通寄存器使用。</p><h3 id="程序计数器-R15-PC">2.1.3 程序计数器 R15/PC</h3><p>程序计数器 R15 也叫做 PC，R15 保存着当前执行的指令地址值加 8 个字节，这是因为 ARM的流水线机制导致的。ARM 处理器 3 级流水线：取指-&gt;译码-&gt;执行，这三级流水线循环执行，比如当前正在执行第一条指令的同时也对第二条指令进行译码，第三条指令也同时被取出存放在 R15(PC)中。我们喜欢以当前正在执行的指令作为参考点，也就是以第一条指令为参考点，那么 R15(PC)中存放的就是第三条指令，换句话说就是 R15(PC)总是指向当前正在执行的指令地址再加上 2 条指令的地址。对于 32 位的 ARM 处理器，每条指令是 4 个字节，所以: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R15 (PC)值 &#x3D; 当前执行的程序位置 + 8 个字节。</span><br></pre></td></tr></table></figure><h3 id="程序状态寄存器-CPSR">2.1.4 程序状态寄存器 CPSR</h3><p>所有的处理器模式都共用一个 CPSR 物理寄存器，因此 CPSR 可以在任何模式下被访问。CPSR 是当前程序状态寄存器，该寄存器包含了条件标志位、中断禁止位、当前处理器模式标志等一些状态位以及一些控制位。所有的处理器模式都共用一个 CPSR 必然会导致冲突，为此，除了 User 和 Sys 这两个模式以外，其他 7 个模式每个都配备了一个专用的物理状态寄存器，叫做 SPSR(备份程序状态寄存器)，当特定的异常中断发生时，SPSR 寄存器用来保存当前程序状态寄存器(CPSR)的值，当异常退出以后可以用 SPSR 中保存的值来恢复 CPSR。</p><p>因为 User 和 Sys 这两个模式不是异常模式，所以并没有配备 SPSR，因此不能在 User 和 Sys 模式下访问 SPSR，会导致不可预知的结果。由于 SPSR 是 CPSR 的备份，因此 SPSR 和 CPSR 的寄存器结构相同，如下图所示：</p><img "" class="lazyload placeholder" data-original="/posts/6bcb34f8/image-20210615000837909.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="CPSR 寄存器" style="zoom: 33%;"><p>**N(bit31)**：当两个补码表示的 有符号整数运算的时候，N=1 表示运算对的结果为负数，N=0 表示结果为正数。</p><p>**Z(bit30)**：Z=1 表示运算结果为零，Z=0 表示运算结果不为零，对于 CMP 指令，Z=1 表示进行比较的两个数大小相等。</p><p>**C(bit29)**：在加法指令中，当结果产生了进位，则 C=1，表示无符号数运算发生上溢，其它情况下 C=0。在减法指令中，当运算中发生借位，则 C=0，表示无符号数运算发生下溢，其它情况下 C=1。对于包含移位操作的非加/减法运算指令，C 中包含最后一次溢出的位的数值，对于其它非加/减运算指令，C 位的值通常不受影响。</p><p>**V(bit28)**：对于加/减法运算指令，当操作数和运算结果表示为二进制的补码表示的带符号数时，V=1 表示符号位溢出，通常其他位不影响 V 位。</p><p>**Q(bit27)**：仅 ARM v5TE_J 架构支持，表示饱和状态，Q=1 表示累积饱和，Q=0 表示累积不饱和。</p><p>**IT[1:0] (bit26:25)**：和 IT[7:2] (bit15:bit10)一起组成 IT[7:0]，作为 IF-THEN 指令执行状态。</p><p>**J(bit24)**：仅 ARM_v5TE-J 架构支持，J=1 表示处于 Jazelle 状态，此位通常和 T(bit5)位一起表示当前所使用的指令集，如下表所示：</p><table><thead><tr><th>J</th><th>T</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>ARM</td></tr><tr><td>0</td><td>1</td><td>Thumb</td></tr><tr><td>1</td><td>1</td><td>ThumbEE</td></tr><tr><td>1</td><td>0</td><td>Jazelle</td></tr></tbody></table><p>**GE[3:0] (bit19:16)**：SIMD 指令有效，大于或等于。</p><p>**IT[7:2] (bit15:10)**：参考 IT[1:0]。</p><p>**E(bit9)**：大小端控制位，E=1 表示大端模式，E=0 表示小端模式。</p><p>**A(bit8)**：禁止异步中断位，A=1 表示禁止异步中断。</p><p>**I(bit7)**：I=1 禁止 IRQ，I=0 使能 IRQ。</p><p>**F(bit6)**：F=1 禁止 FIQ，F=0 使能 FIQ。</p><p>**T(bit5)**：控制指令执行状态，表明本指令是 ARM 指令还是 Thumb 指令，通常和 J(bit24)一起表明指令类型，参考 J(bit24)位。</p><p>**M[4:0]**：处理器模式控制位，含义下表所示：</p><table><thead><tr><th>M[4:0]</th><th>处理器模式</th></tr></thead><tbody><tr><td>10000</td><td>User 模式</td></tr><tr><td>10001</td><td>FIQ 模式</td></tr><tr><td>10010</td><td>IRQ 模式</td></tr><tr><td>10011</td><td>Supervisor(SVC)模式</td></tr><tr><td>10110</td><td>Monitor(MON)模式</td></tr><tr><td>10111</td><td>Abort(ABT)模式</td></tr><tr><td>11010</td><td>Hyp(HYP)模式</td></tr><tr><td>11011</td><td>Undef(UND)模式</td></tr><tr><td>11111</td><td>System(SYS)模式</td></tr></tbody></table><h1 id="协处理器">3 协处理器</h1><h2 id="引言">3.1 引言</h2><p>参考资料：</p><p>关 于 CP15 协处理 器和其 相关寄存 器的详细 内容 请参考下 面两份文 档：<a href="/books/ARM_ArchitectureReference_Manual_ARMv7-A_and_ARMv7-R_edition.pdf">ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf</a>第 1469 页“B3.17 Oranization of the CP15 registers in a VMSA implementation”。<a href="/books/Cortex-A7_Technical_ReferenceManua.pdf">Cortex-A7 Technical ReferenceManua.pdf</a>第55 页“Capter 4 System Control”。</p><p>CP15 协处理器一般用于存储系统管理，但是在中断中也会使用到，CP15 协处理器一共有16 个 32 位寄存器。CP15 协处理器的访问通过如下另个指令完成：</p><p><strong>MRC:</strong> 将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中。</p><p><strong>MCR:</strong> 将 ARM 寄存器的数据写入到 CP15 协处理器寄存器中。</p><p>MRC 就是读 CP15 寄存器，MCR 就是写 CP15 寄存器，MCR 指令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MCR&#123;cond&#125; p15, &lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;, &lt;opc2&gt;</span><br><span class="line"></span><br><span class="line">mcr     p15, 0, r0, c1, c0, 0    &#x2F;* 将r0寄存器中的值写入到CP15的C1寄存器中 *&#x2F;</span><br></pre></td></tr></table></figure><p><strong>cond:</strong> 指令执行的条件码，如果忽略的话就表示无条件执行。</p><p><strong>opc1</strong>：协处理器要执行的操作码。</p><p><strong>Rt</strong>：ARM 源寄存器，要写入到 CP15 寄存器的数据就保存在此寄存器中。</p><p><strong>CRn</strong>：CP15 协处理器的目标寄存器。</p><p><strong>CRm</strong>：协处理器中附加的目标寄存器或者源操作数寄存器，如果不需要附加信息就将 CRm 设置为 C0，否则结果不可预测。</p><p><strong>opc2</strong>：可选的协处理器特定操作码，当不需要的时候要设置为 0。</p><p>MRC 的指令格式和 MCR 一样，只不过在 MRC 指令中 Rt 就是目标寄存器，也就是从 CP15 指定寄存器读出来的数据会保存在 Rt 中。而 CRn 就是源寄存器，也就是要读取的写处理器寄存器。</p><p>假如我们要将 CP15 中 C0 寄存器的值读取到 R0 寄存器中，那么就可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRC p15, 0, r0, c0, c0, 0</span><br></pre></td></tr></table></figure><p>CP15 协处理器有 16 个 32 位寄存器，c0~c15，本章来看一下 c0、c1、c12 和 c15 这四个寄存器，因为我们本章实验要用到这四个寄存器，其他的寄存器大家参考上面的两个文档即可。</p><h2 id="c0-寄存器">3.2 c0 寄存器</h2><p>CP15 协处理器有 16 个 32 位寄存器，c0~c15，在使用 MRC 或者 MCR 指令访问这 16 个寄存器的时候，指令中的 CRn、opc1、CRm 和 opc2 通过不同的搭配，其得到的寄存器含义是不同的。比如 c0 在不同的搭配情况下含义如下图所示：</p><p><img "" class="lazyload placeholder" data-original="/posts/6bcb34f8/image-20210616162344564.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210616162344564"></p><p>当 MRC/MCR 指令中的 CRn=c0，opc1=0，CRm=c0，opc2=0 的时候就表示此时的 c0 就是 MIDR 寄存器，也就是主 ID 寄存器，这个也是 c0 的基本作用。对于 Cortex-A7内核来说，c0 作为 MDIR 寄存器的时候其含义如下图所示：</p><p><img "" class="lazyload placeholder" data-original="/posts/6bcb34f8/image-20210616162513612.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210616162513612"></p><p><strong>bit31:24</strong>：厂商编号，0X41，ARM。</p><p><strong>bit23:20</strong>：内核架构的主版本号，ARM 内核版本一般使用 rnpn 来表示，比如 r0p1，其中 r0 后面的 0 就是内核架构主版本号。</p><p><strong>bit19:16</strong>：架构代码，0XF，ARMv7 架构。</p><p><strong>bit15:4</strong>：内核版本号，0XC07，Cortex-A7 MPCore 内核。</p><p><strong>bit3:0</strong>：内核架构的次版本号，rnpn 中的 pn，比如 r0p1 中 p1 后面的 1 就是次版本号。</p><h2 id="c1-寄存器">3.3 c1 寄存器</h2><p>c1 寄存器同样通过不同的配置，其代表的含义也不同，如下图所示：</p><p><img "" class="lazyload placeholder" data-original="/posts/6bcb34f8/image-20210616162726657.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210616162726657"></p><p>当 MRC/MCR 指令中的 CRn=c1，opc1=0，CRm=c0，opc2=0 的时候就表示此时的 c1 就是 SCTLR 寄存器，也就是系统控制寄存器，这个是 c1 的基本作用。SCTLR 寄存器主要是完成控制功能的，比如使能或者禁止 MMU、I/D Cache 等，c1 作为 SCTLR 寄存器的时候其含义如下图所示：</p><p><img "" class="lazyload placeholder" data-original="/posts/6bcb34f8/image-20210616162818821.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210616162818821"></p><p>SCTLR 的位比较多，我们就只看本章会用到的几个位：</p><p><strong>bit13</strong>：V , 中断向量表基地址选择位，为 0 的话中断向量表基地址为 0X00000000，软件可以使用 VBAR 来重映射此基地址，也就是中断向量表重定位。为 1 的话中断向量表基地址为0XFFFF0000，此基地址不能被重映射。</p><p><strong>bit12</strong>：I，I Cache 使能位，为 0 的话关闭 I Cache，为 1 的话使能 I Cache。</p><p><strong>bit11</strong>：Z，分支预测使能位，如果开启 MMU 的话，此位也会使能。</p><p><strong>bit10</strong>：SW，SWP 和 SWPB 使能位，当为 0 的话关闭 SWP 和 SWPB 指令，当为 1 的时候就使能 SWP 和 SWPB 指令。</p><p><strong>bit9:3</strong>：未使用，保留。</p><p><strong>bit2</strong>：C，D Cache 和缓存一致性使能位，为 0 的时候禁止 D Cache 和缓存一致性，为 1 时使能。</p><p><strong>bit1</strong>：A，内存对齐检查使能位，为 0 的时候关闭内存对齐检查，为 1 的时候使能内存对齐检查。</p><p><strong>bit0</strong>：M，MMU 使能位，为 0 的时候禁止 MMU，为 1 的时候使能 MMU。</p><p>如果要读写 SCTLR 的话，就可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MRC p15, 0, &lt;Rt&gt;, c1, c0, 0 ;读取 SCTLR 寄存器，数据保存到 Rt 中。</span><br><span class="line">MCR p15, 0, &lt;Rt&gt;, c1, c0, 0 ;将 Rt 中的数据写到 SCTLR(c1)寄存器中。</span><br></pre></td></tr></table></figure><h2 id="c12-寄存器">3.4 c12 寄存器</h2><p>c12 寄存器通过不同的配置，其代表的含义也不同，如下图所示：</p><p><img "" class="lazyload placeholder" data-original="/posts/6bcb34f8/image-20210616171056605.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210616171056605"></p><p>在上图中当 MRC/MCR 指令中的 CRn=c12，opc1=0，CRm=c0，opc2=0 的时候就表示此时 c12 为 VBAR 寄存器，也就是向量表基地址寄存器。设置中断向量表偏移的时候就需要将新的中断向量表基地址写入 VBAR 中，比如在前面的例程中，代码链接的起始地址为0X87800000，而中断向量表肯定要放到最前面，也就是 0X87800000 这个地址处。所以就需要设置 VBAR 为 0X87800000，设置命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldr r0, &#x3D;0X87800000          ; r0&#x3D;0X87800000</span><br><span class="line">MCR p15, 0, r0, c12, c0, 0   ;将 r0 里面的数据写入到 c12 中，即 c12&#x3D;0X87800000</span><br></pre></td></tr></table></figure><h2 id="c15-寄存器">3.5 c15 寄存器</h2><p>c15 寄存器也可以通过不同的配置得到不同的含义，参考文档<a href="/books/Cortex-A7_Technical_ReferenceManua.pdf">Cortex-A7 Technical ReferenceManua</a>第 68 页“4.2.16 c15 registers”，其配置如下图所示：</p><p><img "" class="lazyload placeholder" data-original="/posts/6bcb34f8/image-20210616171714606.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210616171714606"></p><p>在上图中，我们需要 c15 作为 CBAR 寄存器，因为 GIC 的基地址就保存在 CBAR 中，我们可以通过如下命令获取到 GIC 基地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRC p15, 4, r1, c15, c0, 0 ; 获取 GIC 基础地址，基地址保存在 r1 中。</span><br></pre></td></tr></table></figure><p>获取到 GIC 基地址以后就可以设置 GIC 相关寄存器了，比如我们可以读取当前中断 ID，当前中断 ID 保存在 GICC_IAR 中，寄存器 GICC_IAR 属于 CPU 接口端寄存器，寄存器地址相对于 CPU 接口端起始地址的偏移为 0XC，因此获取当前中断 ID 的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MRC p15, 4, r1, c15, c0, 0 ;获取 GIC 基地址</span><br><span class="line">ADD r1, r1, #0X2000 ;GIC 基地址加 0X2000 得到 CPU 接口端寄存器起始地址</span><br><span class="line">LDR r0, [r1, #0XC] ;读取 CPU 接口端起始地址+0XC 处的寄存器值，也就是寄存器</span><br><span class="line">                   ;GIC_IAR 的值</span><br></pre></td></tr></table></figure><p>关于 CP15 协处理器就讲解到这里，简单总结一下，通过 c0 寄存器可以获取到处理器内核信息；通过 c1 寄存器可以使能或禁止 MMU、I/D Cache 等；通过 c12 寄存器可以设置中断向量偏移；通过 c15 寄存器可以获取 GIC 基地址。关于 CP15 的其他寄存器，大家自行查阅本节前面列举的 2 份 ARM 官方资料。</p>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编</title>
      <link href="posts/d147e7fa.html"/>
      <url>posts/d147e7fa.html</url>
      
        <content type="html"><![CDATA[<h1 id="汇编基本格式">1 汇编基本格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label：instruction @ comment</span><br></pre></td></tr></table></figure><p><strong>label</strong> 即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意 label 后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号。</p><p><strong>instruction</strong> 即指令，也就是汇编指令或伪指令。</p><p><strong>@<strong>符号，表示后面的是注释，就跟 C 语言里面的“/<em>”和“</em>/”一样，其实在 GNU 汇编文件中我们也可以使用</strong>“/*”**和</strong>“*/”**来注释。</p><p><strong>comment</strong> 就是注释内容。</p><p>比如如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add:</span><br><span class="line">MOVS R0, #0X12 @设置 R0&#x3D;0X12</span><br></pre></td></tr></table></figure><p>上面代码中“add:”就是标号，“MOVS R0,#0X12”就是指令，最后的“@设置 R0=0X12”就是注释。</p><blockquote><p>注意！ARM 中的指令、伪指令、伪操作、寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用。</p></blockquote><h1 id="汇编段">2 汇编段</h1><p>用户可以使用.section 伪操作来定义一个段，汇编系统预定义了一些段名。</p><table><thead><tr><th align="center">段名</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">.text</td><td align="center">代码段</td></tr><tr><td align="center">.data</td><td align="center">初始化的数据段</td></tr><tr><td align="center">.bss</td><td align="center">未初始化的数据段</td></tr><tr><td align="center">.rodata</td><td align="center">只读数据段</td></tr></tbody></table><p>也可以使用.section 来定义一个段，每个段以段名开始，以下一段名或者文件结尾结束，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.section .testsection @定义一个 testsetcion 段</span><br></pre></td></tr></table></figure><p>汇编程序的默认入口标号是 <strong>_start</strong>，不过我们也可以在链接脚本中使用 ENTRY 来指明其它的入口点，下面的代码就是使用**_start** 作为入口标号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.global _start </span><br><span class="line">_start:</span><br><span class="line">ldr r0, &#x3D;0x12 @r0&#x3D;0x12</span><br></pre></td></tr></table></figure><p>上面代码中.global 是伪操作，表示_start 是一个全局标号，类似 C 语言里面的全局变量一样，常见的伪操作有：</p><table><thead><tr><th align="center">段名</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">.byte</td><td align="center">定义单字节数据，比如.byte 0x12</td></tr><tr><td align="center">.short</td><td align="center">定义双字节数据，比如.short 0x1234</td></tr><tr><td align="center">.long</td><td align="center">定义一个 4 字节数据，比如.long 0x12345678</td></tr><tr><td align="center">.equ</td><td align="center">赋值语句，格式为：.equ 变量名，表达式，比如.equ num, 0x12，表示 num=0x12</td></tr><tr><td align="center">.align</td><td align="center">数据字节对齐，比如：.align 4 表示 4 字节对齐</td></tr><tr><td align="center">.end</td><td align="center">表示源文件结束</td></tr><tr><td align="center">.global</td><td align="center">定义一个全局符号，格式为：.global symbol，比如：.global _start</td></tr></tbody></table><p>GNU 汇编还有其它的伪操作，但是最常见的就是上面这些，如果想详细的了解全部的伪操作，可以参考《ARM Cortex-A(armV7)编程手册 V4.0.pdf》的 57 页</p><h1 id="函数">3 函数</h1><p>GNU 汇编同样也支持函数，函数格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数名:</span><br><span class="line">函数体</span><br><span class="line">返回语句</span><br></pre></td></tr></table></figure><p>GNU 汇编函数返回语句不是必须的，如下代码就是用汇编写的 Cortex-A7 中断服务函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 未定义中断 *&#x2F;</span><br><span class="line">Undefined_Handler:</span><br><span class="line">ldr r0, &#x3D;Undefined_Handler</span><br><span class="line">bx r0</span><br><span class="line"></span><br><span class="line">&#x2F;* SVC 中断 *&#x2F;</span><br><span class="line">SVC_Handler:</span><br><span class="line">ldr r0, &#x3D;SVC_Handler</span><br><span class="line">bx r0</span><br><span class="line"></span><br><span class="line">&#x2F;* 预取终止中断 *&#x2F;</span><br><span class="line">PrefAbort_Handler:</span><br><span class="line">ldr r0, &#x3D;PrefAbort_Handler </span><br><span class="line">bx r0</span><br></pre></td></tr></table></figure><p>上述代码中定义了三个汇编函数：Undefined_Handler、SVC_Handler 和PrefAbort_Handler。以函数 Undefined_Handler 为例我们来看一下汇编函数组成，“Undefined_Handler”就是函数名，“ldr r0, =Undefined_Handler”是函数体，“bx r0”是函数返回语句，“bx”指令是返回指令，函数返回语句不是必须的。</p><h1 id="常用汇编指令">4 常用汇编指令</h1><p>本节我们将介绍一些常用的 Cortex-A7 汇编指令，如果想系统的了解 Cortex-A7 的所有汇编指令请参考《ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf》的 A4章节。</p><h2 id="处理器内部数据传输指令">4.1 处理器内部数据传输指令</h2><p>①、将数据从一个寄存器传递到另外一个寄存器。</p><p>②、将数据从一个寄存器传递到特殊寄存器，如 CPSR 和 SPSR 寄存器。</p><p>③、将立即数传递到寄存器。</p><p>数据传输常用的指令有三个：MOV、MRS 和 MSR，这三个指令的用法如表所示：</p><table><thead><tr><th>指令</th><th>目的</th><th>源</th><th>描述</th></tr></thead><tbody><tr><td>MOV</td><td>R0</td><td>R1</td><td>将 R1 里面的数据复制到 R0 中</td></tr><tr><td>MRS</td><td>R0</td><td>CPRS</td><td>将特殊寄存器 CPSR 里面的数据复制到 R0 中</td></tr><tr><td>MSR</td><td>CPRS</td><td>R0</td><td>将 R1 里面的数据复制到特殊寄存器 CPSR 里中</td></tr></tbody></table><h3 id="MOV-指令">4.1.1 MOV 指令</h3><p>MOV 指令用于将数据从一个寄存器拷贝到另外一个寄存器，或者将一个立即数传递到寄存器里面，使用示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R0，R1       @将寄存器 R1 中的数据传递给 R0，即 R0&#x3D;R1</span><br><span class="line">MOV R0, #0X12    @将立即数 0X12 传递给 R0 寄存器，即 R0&#x3D;0X12</span><br></pre></td></tr></table></figure><h3 id="MRS-指令">4.1.2 MRS 指令</h3><p>MRS 指令用于将特殊寄存器(如 CPSR 和 SPSR)中的数据传递给通用寄存器，要读取特殊寄存器的数据只能使用 MRS 指令！使用示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRS R0, CPSR    @将特殊寄存器 CPSR 里面的数据传递给 R0，即 R0&#x3D;CPSR</span><br></pre></td></tr></table></figure><h3 id="MSR-指令">4.1.3 MSR 指令</h3><p>MSR 指令和 MRS 刚好相反，MSR 指令用来将普通寄存器的数据传递给特殊寄存器，也就是写特殊寄存器，写特殊寄存器只能使用 MSR，使用示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSR CPSR, R0     @将 R0 中的数据复制到 CPSR 中，即 CPSR&#x3D;R0</span><br></pre></td></tr></table></figure><h2 id="存储器访问指令">4.2 存储器访问指令</h2><p>ARM 不能直接访问存储器，比如 RAM 中的数据，I.MX6UL 中的寄存器就是 RAM 类型的，我们用汇编来配置 I.MX6UL 寄存器的时候需要借助存储器访问指令，一般先将要配置的值写入到 Rx(x=0~12)寄存器中，然后借助存储器访问指令将 Rx 中的数据写入到 I.MX6UL 寄存器中。读取 I.MX6UL 寄存器也是一样的，只是过程相反。常用的存储器访问指令有两种：LDR 和 STR，用法如表所示：</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>LDR Rd, [Rn , #offset]</td><td>从存储器 Rn+offset 的位置读取数据存放到 Rd 中</td></tr><tr><td>STR Rd, [Rn, #offset]</td><td>将 Rd 中的数据写入到存储器中的 Rn+offset 位置</td></tr></tbody></table><h3 id="LDR-指令">4.2.1 LDR 指令</h3><p>LDR 主要用于从存储加载数据到寄存器 Rx 中，LDR 也可以将一个立即数加载到寄存器 Rx中，LDR 加载立即数的时候要使用“=”，而不是“#”。</p><p>在嵌入式开发中，LDR 最常用的就是读取 CPU 的寄存器值，比如 I.MX6UL 有个寄存器 GPIO1_GDIR，其地址为 0X0209C004，我们现在要读取这个寄存器中的数据，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, &#x3D;0X0209C004   @将寄存器地址 0X0209C004 加载到 R0 中，即 R0&#x3D;0X0209C004</span><br><span class="line">LDR R1, [R0]          @读取地址 0X0209C004 中的数据到 R1 寄存器中</span><br></pre></td></tr></table></figure><p>上述代码就是读取寄存器 GPIO1_GDIR 中的值，读取到的寄存器值保存在 R1 寄存器中，上面代码中 offset 是 0，也就是没有用到 offset。</p><h3 id="STR-指令">4.2.2 STR 指令</h3><p>LDR 是从存储器读取数据，STR 就是将数据写入到存储器中，同样以 I.MX6UL 寄存器 GPIO1_GDIR 为例，现在我们要配置寄存器 GPIO1_GDIR 的值为 0X20000002，示例代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, &#x3D;0X0209C004    @将寄存器地址 0X0209C004 加载到 R0 中，即 R0&#x3D;0X0209C004</span><br><span class="line">LDR R1, &#x3D;0X20000002    @R1 保存要写入到寄存器的值，即 R1&#x3D;0X20000002</span><br><span class="line">STR R1, [R0]           @将 R1 中的值写入到 R0 中所保存的地址中</span><br></pre></td></tr></table></figure><p>LDR 和 STR 都是按照字进行读取和写入的，也就是操作的 32 位数据，如果要按照字节、半字进行操作的话可以在指令“LDR”后面加上 B 或 H，比如按字节操作的指令就是 LDRB 和 STRB，按半字操作的指令就是 LDRH 和 STRH。</p><h3 id="压栈和出栈指令">4.2.3 压栈和出栈指令</h3><p>我们通常会在 A 函数中调用 B 函数，当 B 函数执行完以后再回到 A 函数继续执行。要想再跳回 A 函数以后代码能够接着正常运行，那就必须在跳到 B 函数之前将当前处理器状态保存起来(就是保存 R0<del>R15 这些寄存器值)，当 B 函数执行完成以后再用前面保存的寄存器值恢复R0</del>R15 即可。保存 R0<del>R15 寄存器的操作就叫做现场保护，恢复 R0</del>R15 寄存器的操作就叫做恢复现场。在进行现场保护的时候需要进行压栈(入栈)操作，恢复现场就要进行出栈操作。压栈的指令为 PUSH，出栈的指令为 POP，PUSH 和 POP 是一种多存储和多加载指令，即可以一次操作多个寄存器数据，他们利用当前的栈指针 SP 来生成地址，PUSH 和 POP 的用法如表所示：</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>PUSH <reg list></reg></td><td>将寄存器列表存入栈中</td></tr><tr><td>POP <reg list></reg></td><td>从栈中恢复寄存器列表</td></tr></tbody></table><p>假如我们现在要将 R0~R3 和 R12 这 5 个寄存器压栈，当前的 SP 指针指向 0X80000000，处理器的堆栈是向下增长的，使用的汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH &#123;R0~R3, R12&#125;     @将 R0~R3 和 R12 压栈</span><br></pre></td></tr></table></figure><p><img "" class="lazyload placeholder" data-original="/posts/d147e7fa/image-20210607155925414.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="压栈以后的堆栈"></p><p>上图就是对R0~R3,R12进行压栈以后的堆栈示意图，此时的SP指向了0X7FFFFFEC，假如我们现在要再将 LR 进行压栈，汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH &#123;LR&#125;           @将 LR 进行压栈</span><br></pre></td></tr></table></figure><p><img "" class="lazyload placeholder" data-original="/posts/d147e7fa/image-20210607160045887.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="LR压栈以后的堆栈"></p><p>上图就是分两步对 R0~R3,R12 和 LR 进行压栈以后的堆栈模型，如果我们要出栈的话就是使用如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POP &#123;LR&#125;              @先恢复 LR </span><br><span class="line">POP &#123;R0~R3,R12&#125;       @再恢复 R0~R3,R12</span><br></pre></td></tr></table></figure><p>出栈的就是从栈顶，也就是 SP 当前执行的位置开始，地址依次减小来提取堆栈中的数据到要恢复的寄存器列表中。PUSH 和 POP 的另外一种写法是“STMFD SP！”和“LDMFD SP!”，因此上面的汇编代码可以改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STMFD SP!, &#123;R0~R3, R12&#125;    @R0~R3,R12 入栈</span><br><span class="line">STMFD SP!, &#123;LR&#125;            @LR 入栈 34 </span><br><span class="line">LDMFD SP!, &#123;LR&#125;            @先恢复 LR</span><br><span class="line">LDMFD SP!, &#123;R0~R3, R12&#125;    @再恢复 R0~R3, R12</span><br></pre></td></tr></table></figure><p>STMFD 可以分为两部分：STM 和 FD，同理，LDMFD 也可以分为 LDM 和 FD。看到 STM和 LDM 有没有觉得似曾相识，前面讲了 LDR 和 STR，这两个是数据加载和存储指令，但是每次只能读写存储器中的一个数据。STM 和 LDM 就是多存储和多加载，可以连续的读写存储器中的多个连续数据。</p><p>FD 是 Full Descending 的缩写，即满递减的意思。根据 ATPCS 规则,ARM 使用的 FD 类型的堆栈，SP 指向最后一个入栈的数值，堆栈是由高地址向下增长的，也就是前面说的向下增长的堆栈，因此最常用的指令就是 STMFD 和 LDMFD。STM 和 LDM 的指令寄存器列表中编号小的对应低地址，编号高的对应高地址。</p><h2 id="跳转指令">4.3 跳转指令</h2><p>有多种跳转操作，比如：</p><p>①、直接使用跳转指令 B、BL、BX 等。</p><p>②、直接向 PC 寄存器里面写入数据。</p><p>上述两种方法都可以完成跳转操作，但是一般常用的还是 B、BL 或 BX</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>B <label></label></td><td>跳转到 label，如果跳转范围超过了+/-2KB，可以指定 B.W <label>使用 32 位版本的跳转指令， 这样可以得到较大范围的跳转</label></td></tr><tr><td>BX <rm></rm></td><td>间接跳转，跳转到存放于 Rm 中的地址处，并且切换指令集</td></tr><tr><td>BL <label></label></td><td>跳转到标号地址，并将返回地址保存在 LR 中。</td></tr><tr><td>BLX <rm></rm></td><td>结合 BX 和 BL 的特点，跳转到 Rm 指定的地址，并将返回地址保存在 LR 中，切换指令集</td></tr></tbody></table><p>我们重点来看一下 B 和 BL 指令，因为这两个是我们用的最多的，如果要在汇编中进行函数调用使用的就是 B 和 BL 指令：</p><h3 id="B-指令">4.3.1 B 指令</h3><p>这是最简单的跳转指令，B 指令会将 PC 寄存器的值设置为跳转目标地址， 一旦执行 B 指令，ARM 处理器就会立即跳转到指定的目标地址。如果要调用的函数不会再返回到原来的执行处，那就可以用 B 指令，如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_start: </span><br><span class="line"></span><br><span class="line">ldr sp,&#x3D;0X80200000  @设置栈指针</span><br><span class="line">b main              @跳转到 main 函数</span><br></pre></td></tr></table></figure><p>上述代码就是典型的在汇编中初始化 C 运行环境，然后跳转到 C 文件的 main 函数中运行，上述代码只是初始化了 SP 指针，有些处理器还需要做其他的初始化，比如初始化 DDR 等等。因为跳转到 C 文件以后再也不会回到汇编了，所以在第 4 行使用了 B 指令来完成跳转。</p><h3 id="BL-指令">4.3.2 BL 指令</h3><p>BL 指令相比 B 指令，在跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值，所以可以通过将 LR 寄存器中的值重新加载到 PC 中来继续从跳转之前的代码处运行，这是子程序调用一个基本但常用的手段。比如 Cortex-A 处理器的 irq 中断服务函数都是汇编写的，主要用汇编来实现现场的保护和恢复、获取中断号等。但是具体的中断处理过程都是 C 函数，所以就会存在汇编中调用 C 函数的问题。而且当 C 语言版本的中断处理函数执行完成以后是需要返回到 irq 汇编中断服务函数，因为还要处理其他的工作，一般是恢复现场。这个时候就不能直接使用B 指令了，因为 B 指令一旦跳转就再也不会回来了，这个时候要使用 BL 指令，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">push &#123;r0, r1&#125;          @保存 r0,r1</span><br><span class="line">cps #0x13              @进入 SVC 模式，允许其他中断再次进去</span><br><span class="line"></span><br><span class="line">bl system_irqhandler   @加载 C 语言中断处理函数到 r2 寄存器中</span><br><span class="line"></span><br><span class="line">cps #0x12              @进入 IRQ 模式</span><br><span class="line">pop &#123;r0, r1&#125;</span><br><span class="line">str r0, [r1, #0X10]    @中断执行完成，写 EOIR</span><br></pre></td></tr></table></figure><h2 id="算数运算指令">4.4 算数运算指令</h2><p><img "" class="lazyload placeholder" data-original="/posts/d147e7fa/image-20210607163056639.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210607163056639"></p><p>在嵌入式开发中最常会用的就是加减指令，乘除基本用不到</p><h2 id="逻辑运算指令">4.5 逻辑运算指令</h2><p>我们用 C 语言进行 CPU 寄存器配置的时候常常需要用到逻辑运算符号，比如“&amp;”、“|”等逻辑运算符。使用汇编语言的时候也可以使用逻辑运算指令，常用的运算指令用法如表所示：</p><p><img "" class="lazyload placeholder" data-original="/posts/d147e7fa/image-20210607163303269.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210607163303269"></p><p>逻辑运算指令都很好理解，后面时候汇编配置 I.MX6UL 的外设寄存器的时候可能会用到，ARM 汇编就讲解到这里，本节主要讲解了一些最常用的指令，还有很多不常用的指令没有讲解，但是够我们后续学习用了。要想详细的学习 ARM 的所有指令请参考《 ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf》和《ARM Cortex-A(armV7)编程手册 V4.0.pdf》这两份文档。</p>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux WiFi 内核源码</title>
      <link href="posts/ead4f553.html"/>
      <url>posts/ead4f553.html</url>
      
        <content type="html"><![CDATA[<h1 id="发包过程俯瞰">1 发包过程俯瞰</h1><p>本文将拿<strong>Intel I350</strong>网卡的 <code>igb</code> 驱动作为参考，网卡的 data sheet 这里可以下载 <a href="http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/ethernet-controller-i350-datasheet.pdf">PDF</a> （警告：文件很大）。</p><p>从比较高的层次看，一个数据包从用户程序到达硬件网卡的整个过程如下：</p><ol><li>使用<strong>系统调用</strong>（如 <code>sendto</code>，<code>sendmsg</code> 等）写数据</li><li>数据穿过<strong>socket 子系统</strong>，进入<strong>socket 协议族</strong>（protocol family）系统（在我们的例子中为 <code>AF_INET</code>）</li><li>协议族处理：数据穿过<strong>协议层</strong>，这一过程（在许多情况下）会将<strong>数据</strong>（data）转换成<strong>数据包</strong>（packet）</li><li>数据穿过<strong>路由层</strong>，这会涉及路由缓存和 ARP 缓存的更新；如果目的 MAC 不在 ARP 缓存表中，将触发一次 ARP 广播来查找 MAC 地址</li><li>穿过协议层，packet 到达<strong>设备无关层</strong>（device agnostic layer）</li><li>使用 XPS（如果启用）或散列函数<strong>选择发送队列</strong></li><li>调用网卡驱动的<strong>发送函数</strong></li><li>数据传送到网卡的 <code>qdisc</code>（queue discipline，排队规则）</li><li>qdisc 会直接<strong>发送数据</strong>（如果可以），或者将其放到队列，下次触发**<code>NET_TX</code> 类型软中断**（softirq）的时候再发送</li><li>数据从 qdisc 传送给驱动程序</li><li>驱动程序创建所需的<strong>DMA 映射</strong>，以便网卡从 RAM 读取数据</li><li>驱动向网卡发送信号，通知<strong>数据可以发送了</strong></li><li><strong>网卡从 RAM 中获取数据并发送</strong></li><li>发送完成后，设备触发一个<strong>硬中断</strong>（IRQ），表示发送完成</li><li><strong>硬中断处理函数</strong>被唤醒执行。对许多设备来说，这会<strong>触发 <code>NET_RX</code> 类型的软中断</strong>，然后 NAPI poll 循环开始收包</li><li>poll 函数会调用驱动程序的相应函数，<strong>解除 DMA 映射</strong>，释放数据</li></ol><p>接下来会详细介绍整个过程。</p><h1 id="协议层注册">2 协议层注册</h1><p>协议层分析我们将会关注 IP 和 UDP 层，其他协议层可参考这个过程。</p><p>我们首先来看协议族是如何注册到内核，并被 socket 子系统使用的。</p><p>当用户程序像下面这样创建 UDP socket 时会发生什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)</span><br></pre></td></tr></table></figure><p>简单来说，内核会去查找由 UDP 协议栈导出的一组函数（其中包括用于发送和接收网络数据 的函数），并赋给 socket 的相应字段。准确理解这个过程需要查看 <code>AF_INET</code> 地址族的 代码。</p><p>内核初始化的很早阶段就执行了 <code>inet_init</code> 函数，这个函数会注册 <code>AF_INET</code> 协议族 ，以及该协议族内的各协议栈（TCP，UDP，ICMP 和 RAW），并调用初始化函数使协议栈准备 好处理网络数据。<code>inet_init</code> 定义在 <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/af_inet.c#L1678-L1804">net/ipv4/af_inet.c</a> 。</p><p><code>AF_INET</code> 协议族导出一个包含 <code>create</code> 方法的 <code>struct net_proto_family</code> 类型实例。当从 用户程序创建 socket 时，内核会调用此方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> =</span> &#123;</span><br><span class="line">    .family = PF_INET,</span><br><span class="line">    .create = inet_create,</span><br><span class="line">    .owner  = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>inet_create</code> 根据传递的 socket 参数，在已注册的协议中查找对应的协议。我们来看一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* Look for the requested type/protocol pair. */</span></span><br><span class="line">lookup_protocol:</span><br><span class="line">        err = -ESOCKTNOSUPPORT;</span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="built_in">list</span>) &#123;</span><br><span class="line"></span><br><span class="line">                err = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">/* Check the non-wild match. */</span></span><br><span class="line">                <span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (protocol != IPPROTO_IP)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* Check for the two wild cases. */</span></span><br><span class="line">                        <span class="keyword">if</span> (IPPROTO_IP == protocol) &#123;</span><br><span class="line">                                protocol = answer-&gt;protocol;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                err = -EPROTONOSUPPORT;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后，将该协议的回调方法（集合）赋给这个新创建的 socket：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock-&gt;ops = answer-&gt;ops;</span><br></pre></td></tr></table></figure><p>可以在 <code>af_inet.c</code> 中看到所有协议的初始化参数。 下面是<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/af_inet.c#L998-L1020">TCP 和 UDP</a>的初始化参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Upon startup we insert all the elements in inetsw_array[] into</span></span><br><span class="line"><span class="comment"> * the linked list inetsw.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] =</span></span><br><span class="line">&#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .type =       SOCK_STREAM,</span><br><span class="line">                .protocol =   IPPROTO_TCP,</span><br><span class="line">                .prot =       &amp;tcp_prot,</span><br><span class="line">                .ops =        &amp;inet_stream_ops,</span><br><span class="line">                .no_check =   <span class="number">0</span>,</span><br><span class="line">                .flags =      INET_PROTOSW_PERMANENT |</span><br><span class="line">                              INET_PROTOSW_ICSK,</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">                .type =       SOCK_DGRAM,</span><br><span class="line">                .protocol =   IPPROTO_UDP,</span><br><span class="line">                .prot =       &amp;udp_prot,</span><br><span class="line">                .ops =        &amp;inet_dgram_ops,</span><br><span class="line">                .no_check =   UDP_CSUM_DEFAULT,</span><br><span class="line">                .flags =      INET_PROTOSW_PERMANENT,</span><br><span class="line">       &#125;,</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* .... more protocols ... */</span></span><br></pre></td></tr></table></figure><p><code>IPPROTO_UDP</code> 协议类型有一个 <code>ops</code> 变量，包含<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/af_inet.c#L935-L960">很多信息 </a>，包 括用于发送和接收数据的回调函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">inet_dgram_ops</span> =</span> &#123;</span><br><span class="line">  .family          = PF_INET,</span><br><span class="line">  .owner           = THIS_MODULE,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  .sendmsg     = inet_sendmsg,</span><br><span class="line">  .recvmsg     = inet_recvmsg,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(inet_dgram_ops);</span><br></pre></td></tr></table></figure><p><code>prot</code> 字段指向一个协议相关的变量（的地址），对于 UDP 协议，其中包含了 UDP 相关的 回调函数。 UDP 协议对应的 <code>prot</code> 变量为 <code>udp_prot</code>，定义在 <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/udp.c#L2171-L2203">net/ipv4/udp.c</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">udp_prot</span> =</span> &#123;</span><br><span class="line">  .name        = <span class="string">&quot;UDP&quot;</span>,</span><br><span class="line">  .owner           = THIS_MODULE,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  .sendmsg     = udp_sendmsg,</span><br><span class="line">  .recvmsg     = udp_recvmsg,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(udp_prot);</span><br></pre></td></tr></table></figure><p>现在，让我们转向发送 UDP 数据的用户程序，看看 <code>udp_sendmsg</code> 是如何在内核中被调用的。</p><h1 id="通过-socket-发送网络数据">3 通过 socket 发送网络数据</h1><p>用户程序想发送 UDP 网络数据，因此它使用 <code>sendto</code> 系统调用，看起来可能是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = sendto(socket, buffer, buflen, <span class="number">0</span>, &amp;dest, <span class="keyword">sizeof</span>(dest));</span><br></pre></td></tr></table></figure><p>该系统调用穿过<a href="https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/">Linux 系统调用（system call）层</a>，最后到达<a href="https://github.com/torvalds/linux/blob/v3.13/net/socket.c#L1756-L1803">net/socket.c</a>中的这个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE6(sendto, <span class="keyword">int</span>, fd, <span class="keyword">void</span> __user *, buff, <span class="keyword">size_t</span>, len,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>, flags, struct sockaddr __user *, addr,</span><br><span class="line"><span class="keyword">int</span>, addr_len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __sys_sendto(fd, buff, len, flags, addr, addr_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SYSCALL_DEFINE6</code> 宏会展开成一堆宏，后者经过一波复杂操作创建出一个带 6 个参数的系统 调用（因此叫 <code>DEFINE6</code>）。作为结果之一，你会看到内核中的所有系统调用都带 <code>sys_</code>前 缀。</p><p><code>__sys_sendto</code> 代码会先将数据整理成底层可以处理的格式，然后调用 <code>sock_sendmsg</code>。特别地， 它将传递给 <code>sendto</code> 的地址放到另一个变量（<code>msg</code>）中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Send a datagram to a given address. We move the address into kernel</span></span><br><span class="line"><span class="comment"> *space and check the user space data area is readable before invoking</span></span><br><span class="line"><span class="comment"> *the protocol.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> __sys_sendto(<span class="keyword">int</span> fd, <span class="keyword">void</span> __user *buff, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span><br><span class="line"> struct sockaddr __user *addr,  <span class="keyword">int</span> addr_len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line"><span class="keyword">int</span> fput_needed;</span><br><span class="line"></span><br><span class="line">err = import_single_range(WRITE, buff, len, &amp;iov, &amp;msg.msg_iter);</span><br><span class="line"><span class="keyword">if</span> (unlikely(err))</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line"><span class="keyword">if</span> (!sock)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">msg.msg_control = <span class="literal">NULL</span>;</span><br><span class="line">msg.msg_controllen = <span class="number">0</span>;</span><br><span class="line">msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (addr) &#123;</span><br><span class="line">err = move_addr_to_kernel(addr, addr_len, &amp;address);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_put;</span><br><span class="line">msg.msg_name = (struct sockaddr *)&amp;address;</span><br><span class="line">msg.msg_namelen = addr_len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">flags |= MSG_DONTWAIT;</span><br><span class="line">msg.msg_flags = flags;</span><br><span class="line">err = sock_sendmsg(sock, &amp;msg);</span><br><span class="line"></span><br><span class="line">out_put:</span><br><span class="line">fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将用户程序传入到内核的（存放待发送数据的）地址，作为 <code>msg_name</code> 字段嵌入到 <code>struct msghdr</code> 类型变量中。这和用户程序直接调用 <code>sendmsg</code> 而不是 <code>sendto</code> 发送 数据差不多，这之所以可行，是因为 <code>sendto</code> 和 <code>sendmsg</code> 底层都会调用 <code>sock_sendmsg</code>。</p><h2 id="sock-sendmsg-sock-sendmsg-sock-sendmsg-nosec">3.1 sock_sendmsg, sock_sendmsg, __sock_sendmsg_nosec</h2><p><code>sock_sendmsg</code> 做一些错误检查，然后调用<code>__sock_sendmsg</code>；后者做一些自己的错误检查 ，然后调用<code>__sock_sendmsg_nosec</code>。<code>__sock_sendmsg_nosec</code> 将数据传递到 socket 子系统 的更深处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err = security_socket_sendmsg(sock, msg,</span><br><span class="line">  msg_data_left(msg));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err ?: sock_sendmsg_nosec(sock, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sock_sendmsg_nosec</span><span class="params">(struct socket *sock, struct msghdr *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = INDIRECT_CALL_INET(sock-&gt;ops-&gt;sendmsg, inet6_sendmsg,</span><br><span class="line">     inet_sendmsg, sock, msg,</span><br><span class="line">     msg_data_left(msg));</span><br><span class="line">BUG_ON(ret == -EIOCBQUEUED);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __sock_sendmsg_nosec(struct kiocb *iocb, struct socket *sock,</span><br><span class="line">                                       struct msghdr *msg, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_iocb</span> *<span class="title">si</span> =</span>  ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* other code ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sock-&gt;ops-&gt;sendmsg(iocb, sock, msg, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过我们前面介绍的 socket 创建过程，你应该能看懂，注册到这里的 <code>sendmsg</code> 方法就是 <code>inet_sendmsg</code>。</p><h2 id="inet-sendmsg">3.2 inet_sendmsg</h2><p>从名字可以猜到，这是 <code>AF_INET</code> 协议族提供的通用函数。 此函数首先调用 <code>sock_rps_record_flow</code> 来记录最后一个处理该（数据所属的）flow 的 CPU; Receive Packet Steering 会用到这个信息。接下来，调用 socket 的协议类型（本例是 UDP）对应的 <code>sendmsg</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int inet_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,</span><br><span class="line">                 size_t size)</span><br><span class="line">&#123;</span><br><span class="line">      struct sock *sk &#x3D; sock-&gt;sk;</span><br><span class="line"></span><br><span class="line">      sock_rps_record_flow(sk);</span><br><span class="line"></span><br><span class="line">      &#x2F;* We may need to bind the socket. *&#x2F;</span><br><span class="line">      if (!inet_sk(sk)-&gt;inet_num &amp;&amp; !sk-&gt;sk_prot-&gt;no_autobind &amp;&amp; inet_autobind(sk))</span><br><span class="line">              return -EAGAIN;</span><br><span class="line"></span><br><span class="line">      return sk-&gt;sk_prot-&gt;sendmsg(iocb, sk, msg, size);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(inet_sendmsg);</span><br></pre></td></tr></table></figure><p>本例是 UDP 协议，因此上面的 <code>sk-&gt;sk_prot-&gt;sendmsg</code> 指向的是我们之前看到的（通过 <code>udp_prot</code> 导出的）<code>udp_sendmsg</code> 函数。</p><p><strong>sendmsg()函数作为分界点，处理逻辑从 <code>AF_INET</code> 协议族通用处理转移到具体的 UDP 协议的处理。</strong></p><h1 id="UDP-协议层">4 UDP 协议层</h1><h2 id="udp-sendmsg">4.1 udp_sendmsg</h2><p>这个函数定义在 <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/udp.c#L845-L1088">net/ipv4/udp.c</a> ，函数非常长，我们分段来看。</p><h3 id="UDP-corking（软木塞）">4.1.1 UDP corking（软木塞）</h3><p>在变量声明和基本错误检查之后，<code>udp_sendmsg</code> 所做的第一件事就是检查 socket 是否“ 塞住”了（corked）。 UDP corking 是一项优化技术，允许内核将多次数据累积成单个数据报发 送。在用户程序中有两种方法可以启用此选项：</p><ol><li>使用 <code>setsockopt</code> 系统调用设置 socket 的 <code>UDP_CORK</code> 选项</li><li>程序调用 <code>send</code>，<code>sendto</code> 或 <code>sendmsg</code> 时，带 <code>MSG_MORE</code> 参数</li></ol><p>详细信息参考 <a href="http://man7.org/linux/man-pages/man7/udp.7.html">UDP man page</a>和 <a href="http://man7.org/linux/man-pages/man2/send.2.html"><code>send/sendto/sendmsg</code> man page</a>。</p><p><code>udp_sendmsg</code> 代码检查 <code>up-&gt;pending</code> 以确定 socket 当前是否已被塞住(corked)，如果是， 则直接跳到 <code>do_append_data</code> 进行数据追加(append)。 我们将在稍后看到如何追加数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,</span><br><span class="line">                size_t len)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;* variables and error checking ... *&#x2F;</span><br><span class="line"></span><br><span class="line">  fl4 &#x3D; &amp;inet-&gt;cork.fl.u.ip4;</span><br><span class="line">  if (up-&gt;pending) &#123;</span><br><span class="line">          &#x2F;*</span><br><span class="line">           * There are pending frames.</span><br><span class="line">           * The socket lock must be held while it&#39;s corked.</span><br><span class="line">           *&#x2F;</span><br><span class="line">          lock_sock(sk);</span><br><span class="line">          if (likely(up-&gt;pending)) &#123;</span><br><span class="line">                  if (unlikely(up-&gt;pending !&#x3D; AF_INET)) &#123;</span><br><span class="line">                          release_sock(sk);</span><br><span class="line">                          return -EINVAL;</span><br><span class="line">                  &#125;</span><br><span class="line">                  goto do_append_data;</span><br><span class="line">          &#125;</span><br><span class="line">          release_sock(sk);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="获取目的-IP-地址和端口">4.1.2 获取目的 IP 地址和端口</h3><p>接下来获取目标地址和端口，有两个可能的来源：</p><ol><li>如果之前 socket 已经建立连接，那 socket 本身就存储了目标地址</li><li>地址通过辅助结构（<code>struct msghdr</code>）传入，正如我们在 <code>sendto</code> 的内核代码中看到的那样</li></ol><p>具体逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *      Get and verify the address.</span><br><span class="line"> *&#x2F;</span><br><span class="line">  if (msg-&gt;msg_name) &#123;</span><br><span class="line">          struct sockaddr_in *usin &#x3D; (struct sockaddr_in *)msg-&gt;msg_name;</span><br><span class="line">          if (msg-&gt;msg_namelen &lt; sizeof(*usin))</span><br><span class="line">                  return -EINVAL;</span><br><span class="line">          if (usin-&gt;sin_family !&#x3D; AF_INET) &#123;</span><br><span class="line">                  if (usin-&gt;sin_family !&#x3D; AF_UNSPEC)</span><br><span class="line">                          return -EAFNOSUPPORT;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          daddr &#x3D; usin-&gt;sin_addr.s_addr;</span><br><span class="line">          dport &#x3D; usin-&gt;sin_port;</span><br><span class="line">          if (dport &#x3D;&#x3D; 0)</span><br><span class="line">                  return -EINVAL;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">          if (sk-&gt;sk_state !&#x3D; TCP_ESTABLISHED)</span><br><span class="line">                  return -EDESTADDRREQ;</span><br><span class="line">          daddr &#x3D; inet-&gt;inet_daddr;</span><br><span class="line">          dport &#x3D; inet-&gt;inet_dport;</span><br><span class="line">          &#x2F;* Open fast path for connected socket.</span><br><span class="line">             Route will not be used, if at least one option is set.</span><br><span class="line">           *&#x2F;</span><br><span class="line">          connected &#x3D; 1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>是的，你没看错，UDP 代码中出现了 <code>TCP_ESTABLISHED</code>！UDP socket 的状态使用了 TCP 状态 来描述，不知道是好是坏。</p><p>回想前面我们看到用户程序调用 <code>sendto</code> 时，内核如何替用户初始化一个 <code>struct msghdr</code> 变量。上面的代码显示了内核如何解析该变量以便设置 <code>daddr</code> 和 <code>dport</code>。</p><p>如果没有 <code>struct msghdr</code> 变量，内核函数到达 <code>udp_sendmsg</code> 函数时，会从 socket 本身检索 目标地址和端口，并将 socket 标记为“已连接”。</p><h3 id="Socket-发送：bookkeeping-和打时间戳">4.1.3 Socket 发送：bookkeeping 和打时间戳</h3><p>接下来，获取存储在 socket 上的源地址、设备索引（device index）和时间戳选项（例 如 <code>SOCK_TIMESTAMPING_TX_HARDWARE</code>, <code>SOCK_TIMESTAMPING_TX_SOFTWARE</code>, <code>SOCK_WIFI_STATUS</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ipc.addr &#x3D; inet-&gt;inet_saddr;</span><br><span class="line"></span><br><span class="line">ipc.oif &#x3D; sk-&gt;sk_bound_dev_if;</span><br><span class="line"></span><br><span class="line">sock_tx_timestamp(sk, &amp;ipc.tx_flags);</span><br></pre></td></tr></table></figure><h3 id="辅助消息（Ancillary-messages）">4.1.4 辅助消息（Ancillary messages）</h3><p>除了发送或接收数据包之外，<code>sendmsg</code> 和 <code>recvmsg</code> 系统调用还允许用户设置或请求辅助数 据。用户程序可以通过将请求信息组织成 <code>struct msghdr</code> 类型变量来利用此辅助数据。一些辅 助数据类型记录在<a href="http://man7.org/linux/man-pages/man7/ip.7.html">IP man page</a>中 。</p><p>辅助数据的一个常见例子是 <code>IP_PKTINFO</code>。对于 <code>sendmsg</code>，<code>IP_PKTINFO</code> 允许程序在发送 数据时设置一个 <code>in_pktinfo</code> 变量。程序可以通过填写 <code>struct in_pktinfo</code> 变量中的字段 来指定要在 packet 上使用的源地址。如果程序是监听多个 IP 地址的服务端程序，那这是一个 很有用的选项。在这种情况下，服务端可能想使用客户端连接服务端的那个 IP 地址来回复客 户端，<code>IP_PKTINFO</code> 非常适合这种场景。</p><p><code>setsockopt</code> 可以在<strong>socket 级别</strong>设置发送包的 <a href="https://en.wikipedia.org/wiki/Time_to_live#IP_packets">IP_TTL</a>和 <a href="https://en.wikipedia.org/wiki/Type_of_service">IP_TOS</a>。而辅助消息允 许在每个<strong>数据包级别</strong>设置 TTL 和 TOS 值。Linux 内核会使用一个<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/route.c#L179-L197">数组 </a>将 TOS 转换为优先级，后者会影响数据包如何以及合适从 qdisc 中发送出去。我们稍后会了解到这 意味着什么。</p><p>我们可以看到内核如何在 UDP socket 上处理 <code>sendmsg</code> 的辅助消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (msg-&gt;msg_controllen) &#123;</span><br><span class="line">        err &#x3D; ip_cmsg_send(sock_net(sk), msg, &amp;ipc,</span><br><span class="line">                           sk-&gt;sk_family &#x3D;&#x3D; AF_INET6);</span><br><span class="line">        if (err)</span><br><span class="line">                return err;</span><br><span class="line">        if (ipc.opt)</span><br><span class="line">                free &#x3D; 1;</span><br><span class="line">        connected &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析辅助消息的工作是由 <code>ip_cmsg_send</code> 完成的，定义在 <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/ip_sockglue.c#L190-L241">net/ipv4/ip_sockglue.c</a> 。注意，传递一个未初始化的辅助数据，将会把这个 socket 标记为“未建立连接的”（译者注 ：因为从 5.1.2 的代码可以看出，有辅助消息时优先处理辅助消息，没有辅助消息才从 socket 里面拿信息）。</p><h3 id="设置自定义-IP-选项">4.1.5 设置自定义 IP 选项</h3><p>接下来，<code>sendmsg</code> 将检查用户是否通过辅助消息设置了的任何自定义 IP 选项。如果设置了 ，将使用这些自定义值；如果没有，那就使用 socket 中（已经在用）的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (!ipc.opt) &#123;</span><br><span class="line">        struct ip_options_rcu *inet_opt;</span><br><span class="line"></span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        inet_opt &#x3D; rcu_dereference(inet-&gt;inet_opt);</span><br><span class="line">        if (inet_opt) &#123;</span><br><span class="line">                memcpy(&amp;opt_copy, inet_opt,</span><br><span class="line">                       sizeof(*inet_opt) + inet_opt-&gt;opt.optlen);</span><br><span class="line">                ipc.opt &#x3D; &amp;opt_copy.opt;</span><br><span class="line">        &#125;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，该函数检查是否设置了源记录路由（source record route, SRR）IP 选项。 SRR 有两种类型：<a href="https://en.wikipedia.org/wiki/Loose_Source_Routing">宽松源记录路由和严格源记录路由</a>。 如果设置了此选项，则会记录第一跳地址并将其保存到 <code>faddr</code>，并将 socket 标记为“未连接”。 这将在后面用到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ipc.addr &#x3D; faddr &#x3D; daddr;</span><br><span class="line"></span><br><span class="line">if (ipc.opt &amp;&amp; ipc.opt-&gt;opt.srr) &#123;</span><br><span class="line">        if (!daddr)</span><br><span class="line">                return -EINVAL;</span><br><span class="line">        faddr &#x3D; ipc.opt-&gt;opt.faddr;</span><br><span class="line">        connected &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理完 SRR 选项后，将处理 TOS 选项，这可以从辅助消息中获取，或者从 socket 当前值中获取。 然后检查：</p><ol><li>是否（使用 <code>setsockopt</code>）在 socket 上设置了 <code>SO_DONTROUTE</code>，或</li><li>是否（调用 <code>sendto</code> 或 <code>sendmsg</code> 时）指定了 <code>MSG_DONTROUTE</code> 标志，或</li><li>是否已设置了 <code>is_strictroute</code>，表示需要严格的 <a href="http://www.networksorcery.com/enp/protocol/ip/option009.htm">SRR</a></li></ol><p>任何一个为真，<code>tos</code> 字段的 <code>RTO_ONLINK</code> 位将置 1，并且 socket 被视为“未连接”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tos &#x3D; get_rttos(&amp;ipc, inet);</span><br><span class="line">if (sock_flag(sk, SOCK_LOCALROUTE) ||</span><br><span class="line">    (msg-&gt;msg_flags &amp; MSG_DONTROUTE) ||</span><br><span class="line">    (ipc.opt &amp;&amp; ipc.opt-&gt;opt.is_strictroute)) &#123;</span><br><span class="line">        tos |&#x3D; RTO_ONLINK;</span><br><span class="line">        connected &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多播或单播（Multicast-or-unicast）">4.1.6 多播或单播（Multicast or unicast）</h3><p>接下来代码开始处理 multicast。这有点复杂，因为用户可以通过 <code>IP_PKTINFO</code> 辅助消息 来指定发送包的源地址或设备号，如前所述。</p><p>如果目标地址是多播地址：</p><ol><li>将多播设备（device）的索引（index）设置为发送（写）这个 packet 的设备索引，并且</li><li>packet 的源地址将设置为 multicast 源地址</li></ol><p>如果目标地址不是一个组播地址，则发送 packet 的设备制定为 <code>inet-&gt;uc_index</code>（单播）， 除非用户使用 <code>IP_PKTINFO</code> 辅助消息覆盖了它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (ipv4_is_multicast(daddr)) &#123;</span><br><span class="line">        if (!ipc.oif)</span><br><span class="line">                ipc.oif &#x3D; inet-&gt;mc_index;</span><br><span class="line">        if (!saddr)</span><br><span class="line">                saddr &#x3D; inet-&gt;mc_addr;</span><br><span class="line">        connected &#x3D; 0;</span><br><span class="line">&#125; else if (!ipc.oif)</span><br><span class="line">        ipc.oif &#x3D; inet-&gt;uc_index;</span><br></pre></td></tr></table></figure><h3 id="路由">4.1.7 路由</h3><p>现在开始路由！</p><p>UDP 层中处理路由的代码以<strong>快速路径</strong>（fast path）开始。 如果 socket 已连接，则直接尝试获取路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (connected)</span><br><span class="line">        rt &#x3D; (struct rtable *)sk_dst_check(sk, 0);</span><br></pre></td></tr></table></figure><p>如果 socket 未连接，或者虽然已连接，但路由辅助函数 <code>sk_dst_check</code> 认定路由已过期，则代码将进入<strong>慢速路径</strong>（slow path）以生成一条路由记录。首先调用 <code>flowi4_init_output</code> 构造一个描述此 UDP 流的变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (rt &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        struct net *net &#x3D; sock_net(sk);</span><br><span class="line"></span><br><span class="line">        fl4 &#x3D; &amp;fl4_stack;</span><br><span class="line">        flowi4_init_output(fl4, ipc.oif, sk-&gt;sk_mark, tos,</span><br><span class="line">                           RT_SCOPE_UNIVERSE, sk-&gt;sk_protocol,</span><br><span class="line">                           inet_sk_flowi_flags(sk)|FLOWI_FLAG_CAN_SLEEP,</span><br><span class="line">                           faddr, saddr, dport, inet-&gt;inet_sport);</span><br></pre></td></tr></table></figure><p>然后，socket 及其 flow 实例会传递给安全子系统，这样<a href="https://en.wikipedia.org/wiki/Security-Enhanced_Linux">SELinux</a>或<a href="https://en.wikipedia.org/wiki/Smack_(software)">SMACK</a>这样的系统就可以在 flow 实例上设置安全 ID。 接下来，<code>ip_route_output_flow</code> 将调用 IP 路由代码，创建一个路由实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">security_sk_classify_flow(sk, flowi4_to_flowi(fl4));</span><br><span class="line">rt &#x3D; ip_route_output_flow(net, fl4, sk);</span><br></pre></td></tr></table></figure><p>如果创建路由实例失败，并且返回码是 <code>ENETUNREACH</code>, 则 <code>OUTNOROUTES</code> 计数器将会加 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (IS_ERR(rt)) &#123;</span><br><span class="line">  err &#x3D; PTR_ERR(rt);</span><br><span class="line">  rt &#x3D; NULL;</span><br><span class="line">  if (err &#x3D;&#x3D; -ENETUNREACH)</span><br><span class="line">    IP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES);</span><br><span class="line">  goto out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些统计计数器所在的源文件、其他可用的计数器及其含义，将将在下面的 UDP 监控部分讨 论。</p><p>接下来，如果是广播路由，但 socket 的 <code>SOCK_BROADCAST</code> 选项未设置，则处理过程终止。 如果 socket 被视为“已连接”，则路由实例将缓存到 socket 上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err &#x3D; -EACCES;</span><br><span class="line">if ((rt-&gt;rt_flags &amp; RTCF_BROADCAST) &amp;&amp;</span><br><span class="line">    !sock_flag(sk, SOCK_BROADCAST))</span><br><span class="line">        goto out;</span><br><span class="line">if (connected)</span><br><span class="line">        sk_dst_set(sk, dst_clone(&amp;rt-&gt;dst));</span><br></pre></td></tr></table></figure><h3 id="MSG-CONFIRM-阻止-ARP-缓存过期">4.1.8 MSG_CONFIRM: 阻止 ARP 缓存过期</h3><p>如果调用 <code>send</code>, <code>sendto</code> 或 <code>sendmsg</code> 的时候指定了 <code>MSG_CONFIRM</code> 参数，UDP 协议层将会如下处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  if (msg-&gt;msg_flags&amp;MSG_CONFIRM)</span><br><span class="line">          goto do_confirm;</span><br><span class="line">back_from_confirm:</span><br></pre></td></tr></table></figure><p>该标志提示系统去确认一下 ARP 缓存条目是否仍然有效，防止其被垃圾回收。 <code>do_confirm</code> 标签位于此函数末尾处，很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do_confirm:</span><br><span class="line">        dst_confirm(&amp;rt-&gt;dst);</span><br><span class="line">        if (!(msg-&gt;msg_flags&amp;MSG_PROBE) || len)</span><br><span class="line">                goto back_from_confirm;</span><br><span class="line">        err &#x3D; 0;</span><br><span class="line">        goto out;</span><br></pre></td></tr></table></figure><p><code>dst_confirm</code> 函数只是在相应的缓存条目上设置一个标记位，稍后当查询邻居缓存并找到 条目时将检查该标志，我们后面一些会看到。此功能通常用于 UDP 网络应用程序，以减少 不必要的 ARP 流量。</p><p>此代码确认缓存条目然后跳回 <code>back_from_confirm</code> 标签。</p><p>一旦 <code>do_confirm</code> 代码跳回到 <code>back_from_confirm</code>（或者之前就没有执行到 <code>do_confirm</code> ），代码接下来将处理 UDP cork 和 uncorked 情况。</p><h3 id="uncorked-UDP-sockets-快速路径：准备待发送数据">4.1.9 uncorked UDP sockets 快速路径：准备待发送数据</h3><p>如果不需要 corking，数据就可以封装到一个 <code>struct sk_buff</code> 实例中并传递给 <code>udp_send_skb</code>，离 IP 协议层更进了一步。这是通过调用 <code>ip_make_skb</code> 来完成的。</p><p>注意，先前通过调用 <code>ip_route_output_flow</code> 生成的路由条目也会一起传进来， 它将保存到 skb 里，稍后在 IP 协议层中被使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Lockless fast path for the non-corking case. *&#x2F;</span><br><span class="line">if (!corkreq) &#123;</span><br><span class="line">        skb &#x3D; ip_make_skb(sk, fl4, getfrag, msg-&gt;msg_iov, ulen,</span><br><span class="line">                          sizeof(struct udphdr), &amp;ipc, &amp;rt,</span><br><span class="line">                          msg-&gt;msg_flags);</span><br><span class="line">        err &#x3D; PTR_ERR(skb);</span><br><span class="line">        if (!IS_ERR_OR_NULL(skb))</span><br><span class="line">                err &#x3D; udp_send_skb(skb, fl4);</span><br><span class="line">        goto out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ip_make_skb</code> 函数将创建一个 skb，其中需要考虑到很多的事情，例如：</p><ol><li><a href="https://blog.packagecloud.io/eng/2017/02/06/monitoring-tuning-linux-networking-stack-sending-data/Maximum_transmission_unit">MTU</a></li><li>UDP corking（如果启用）</li><li>UDP Fragmentation Offloading（<a href="https://wiki.linuxfoundation.org/networking/ufo">UFO</a>）</li><li>Fragmentation（分片）：如果硬件不支持 UFO，但是要传输的数据大于 MTU，需要软件做分片</li></ol><p>大多数网络设备驱动程序不支持 UFO，因为网络硬件本身不支持此功能。我们来看下这段代码，先看 corking 禁用的情况，启用的情况我们更后面再看。</p><h4 id="ip-make-skb">4.1.9.1 ip_make_skb</h4><p>定义在<a href="http://arthurchiao.art/blog/tuning-stack-tx-zh/">net/ipv4/ip_output.c</a>，这个函数有点复杂。</p><p>构建 skb 的时候，<code>ip_make_skb</code> 依赖的底层代码需要使用一个 corking 变量和一个 queue 变量 ，skb 将通过 queue 变量传入。如果 socket 未被 cork，则会传入一个假的 corking 变量和一个 空队列。</p><p>我们来看看假 corking 变量和空队列是如何初始化的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct sk_buff *ip_make_skb(struct sock *sk, &#x2F;* more args *&#x2F;)</span><br><span class="line">&#123;</span><br><span class="line">        struct inet_cork cork;</span><br><span class="line">        struct sk_buff_head queue;</span><br><span class="line">        int err;</span><br><span class="line"></span><br><span class="line">        if (flags &amp; MSG_PROBE)</span><br><span class="line">                return NULL;</span><br><span class="line"></span><br><span class="line">        __skb_queue_head_init(&amp;queue);</span><br><span class="line"></span><br><span class="line">        cork.flags &#x3D; 0;</span><br><span class="line">        cork.addr &#x3D; 0;</span><br><span class="line">        cork.opt &#x3D; NULL;</span><br><span class="line">        err &#x3D; ip_setup_cork(sk, &amp;cork, &#x2F;* more args *&#x2F;);</span><br><span class="line">        if (err)</span><br><span class="line">                return ERR_PTR(err);</span><br></pre></td></tr></table></figure><p>如上所示，cork 和 queue 都是在栈上分配的，<code>ip_make_skb</code> 根本不需要它。 <code>ip_setup_cork</code> 初始化 cork 变量。接下来，调用<code>__ip_append_data</code> 并传入 cork 和 queue 变 量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">err &#x3D; __ip_append_data(sk, fl4, &amp;queue, &amp;cork,</span><br><span class="line">                       &amp;current-&gt;task_frag, getfrag,</span><br><span class="line">                       from, length, transhdrlen, flags);</span><br></pre></td></tr></table></figure><p>我们将在后面看到这个函数是如何工作的，因为不管 socket 是否被 cork，最后都会执行它。</p><p>现在，我们只需要知道<code>__ip_append_data</code> 将创建一个 skb，向其追加数据，并将该 skb 添加 到传入的 queue 变量中。如果追加数据失败，则调用<code>__ip_flush_pending_frame</code> 丢弃数据 并向上返回错误（指针类型）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (err) &#123;</span><br><span class="line">        __ip_flush_pending_frames(sk, &amp;queue, &amp;cork);</span><br><span class="line">        return ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，如果没有发生错误，<code>__ip_make_skb</code> 将 skb 出队，添加 IP 选项，并返回一个准备好传 递给更底层发送的 skb：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return __ip_make_skb(sk, fl4, &amp;queue, &amp;cork);</span><br></pre></td></tr></table></figure><h4 id="发送数据">4.1.9.2 发送数据</h4><p>如果没有错误，skb 就会交给 <code>udp_send_skb</code>，后者会继续将其传给下一层协议，IP 协议：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err &#x3D; PTR_ERR(skb);</span><br><span class="line">if (!IS_ERR_OR_NULL(skb))</span><br><span class="line">        err &#x3D; udp_send_skb(skb, fl4);</span><br><span class="line">goto out;</span><br></pre></td></tr></table></figure><p>如果有错误，错误计数就会有相应增加。后面的“错误计数”部分会详细介绍。</p><h3 id="没有被-cork-的数据时的慢路径">4.1.10 没有被 cork 的数据时的慢路径</h3><p>如果使用了 UDP corking，但之前没有数据被 cork，则慢路径开始：</p><ol><li>对 socket 加锁</li><li>检查应用程序是否有 bug：已经被 cork 的 socket 是否再次被 cork</li><li>设置该 UDP flow 的一些参数，为 corking 做准备</li><li>将要发送的数据追加到现有数据</li></ol><p><code>udp_sendmsg</code> 代码继续向下看，就是这一逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  lock_sock(sk);</span><br><span class="line">  if (unlikely(up-&gt;pending)) &#123;</span><br><span class="line">          &#x2F;* The socket is already corked while preparing it. *&#x2F;</span><br><span class="line">          &#x2F;* ... which is an evident application bug. --ANK *&#x2F;</span><br><span class="line">          release_sock(sk);</span><br><span class="line"></span><br><span class="line">          LIMIT_NETDEBUG(KERN_DEBUG pr_fmt(&quot;cork app bug 2\n&quot;));</span><br><span class="line">          err &#x3D; -EINVAL;</span><br><span class="line">          goto out;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;*</span><br><span class="line">   *      Now cork the socket to pend data.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  fl4 &#x3D; &amp;inet-&gt;cork.fl.u.ip4;</span><br><span class="line">  fl4-&gt;daddr &#x3D; daddr;</span><br><span class="line">  fl4-&gt;saddr &#x3D; saddr;</span><br><span class="line">  fl4-&gt;fl4_dport &#x3D; dport;</span><br><span class="line">  fl4-&gt;fl4_sport &#x3D; inet-&gt;inet_sport;</span><br><span class="line">  up-&gt;pending &#x3D; AF_INET;</span><br><span class="line"></span><br><span class="line">do_append_data:</span><br><span class="line">  up-&gt;len +&#x3D; ulen;</span><br><span class="line">  err &#x3D; ip_append_data(sk, fl4, getfrag, msg-&gt;msg_iov, ulen,</span><br><span class="line">                       sizeof(struct udphdr), &amp;ipc, &amp;rt,</span><br><span class="line">                       corkreq ? msg-&gt;msg_flags|MSG_MORE : msg-&gt;msg_flags);</span><br></pre></td></tr></table></figure><h4 id="ip-append-data">4.1.10.1 ip_append_data</h4><p>这个函数简单封装了<code>__ip_append_data</code>，在调用后者之前，做了两件重要的事情：</p><ol><li>检查是否从用户传入了 <code>MSG_PROBE</code> 标志。该标志表示用户不想真正发送数据，只是做路 径探测（例如，确定<a href="https://en.wikipedia.org/wiki/Path_MTU_Discovery">PMTU</a>）</li><li>检查 socket 的发送队列是否为空。如果为空，意味着没有 cork 数据等待处理，因此调用 <code>ip_setup_cork</code> 来设置 corking</li></ol><p>一旦处理了上述条件，就调用<code>__ip_append_data</code> 函数，该函数包含用于将数据处理成数据 包的大量逻辑。</p><h4 id="ip-append-data-1">4.1.10.2 __ip_append_data</h4><p>如果 socket 是 corked，则从 <code>ip_append_data</code> 调用此函数；如果 socket 未被 cork，则从 <code>ip_make_skb</code> 调用此函数。在任何一种情况下，函数都将分配一个新缓冲区来存储传入 的数据，或者将数据附加到现有数据中。</p><p>这种工作的方式围绕 socket 的发送队列。等待发送的现有数据（例如，如果 socket 被 cork） 将在队列中有一个对应条目，可以被追加数据。</p><p>这个函数很复杂;它执行很多计算以确定如何构造传递给下面的网络层的 skb。</p><p>该函数的重点包括：</p><ol><li>如果硬件支持，则处理 UDP Fragmentation Offload（UFO）。绝大多数网络硬件不支持 UFO。如果你的网卡驱动程序支持它，它将设置 <code>NETIF_F_UFO</code> 标记位</li><li>处理支持分散/收集（ <a href="https://en.wikipedia.org/wiki/Vectored_I/O">scatter/gather</a>）IO 的网卡。许多 卡都支持此功能，并使用 <code>NETIF_F_SG</code> 标志进行通告。支持该特性的网卡可以处理数据 被分散到多个 buffer 的数据包;内核不需要花时间将多个缓冲区合并成一个缓冲区中。避 免这种额外的复制会提升性能，大多数网卡都支持此功能</li><li>通过调用 <code>sock_wmalloc</code> 跟踪发送队列的大小。当分配新的 skb 时，skb 的大小由创建它 的 socket 计费（charge），并计入 socket 发送队列的已分配字节数。如果发送队列已经 没有足够的空间（超过计费限制），则 skb 并分配失败并返回错误。我们将在下面的调优 部分中看到如何设置 socket 发送队列大小（txqueuelen）</li><li>更新错误统计信息。此函数中的任何错误都会增加“discard”计数。我们将在下面的监控部分中 看到如何读取此值</li></ol><p>函数执行成功后返回 0，以及一个适用于网络设备传输的 skb。</p><p>在 unorked 情况下，持有 skb 的 queue 被作为参数传递给上面描述的<code>__ip_make_skb</code>，在那里 它被出队并通过 <code>udp_send_skb</code> 发送到更底层。</p><p>在 cork 的情况下，<code>__ip_append_data</code> 的返回值向上传递。数据位于发送队列中，直到 <code>udp_sendmsg</code> 确定是时候调用 <code>udp_push_pending_frames</code> 来完成 skb，后者会进一步调用 <code>udp_send_skb</code>。</p><h4 id="Flushing-corked-sockets">4.1.10.3 Flushing corked sockets</h4><p>现在，<code>udp_sendmsg</code> 会继续，检查<code>__ip_append_skb</code> 的返回值（错误码）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (err)</span><br><span class="line">        udp_flush_pending_frames(sk);</span><br><span class="line">else if (!corkreq)</span><br><span class="line">        err &#x3D; udp_push_pending_frames(sk);</span><br><span class="line">else if (unlikely(skb_queue_empty(&amp;sk-&gt;sk_write_queue)))</span><br><span class="line">        up-&gt;pending &#x3D; 0;</span><br><span class="line">release_sock(sk);</span><br></pre></td></tr></table></figure><p>我们来看看每个情况：</p><ol><li>如果出现错误（错误为非零），则调用 <code>udp_flush_pending_frames</code>，这将取消 cork 并从 socket 的发送队列中删除所有数据</li><li>如果在未指定 <code>MSG_MORE</code> 的情况下发送此数据，则调用 <code>udp_push_pending_frames</code>，它将数据传递到更下面的网络层</li><li>如果发送队列为空，请将 socket 标记为不再 cork</li></ol><p>如果追加操作完成并且有更多数据要进入 cork，则代码将做一些清理工作，并返回追加数据的长度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip_rt_put(rt);</span><br><span class="line">if (free)</span><br><span class="line">        kfree(ipc.opt);</span><br><span class="line">if (!err)</span><br><span class="line">        return len;</span><br></pre></td></tr></table></figure><p>这就是内核如何处理 corked UDP sockets 的。</p><h3 id="Error-accounting">4.1.11 Error accounting</h3><p>如果：</p><ol><li>non-corking 快速路径创建 skb 失败，或 <code>udp_send_skb</code> 返回错误，或</li><li><code>ip_append_data</code> 无法将数据附加到 corked UDP socket，或</li><li>当 <code>udp_push_pending_frames</code> 调用 <code>udp_send_skb</code> 发送 corked skb 时后者返回错误</li></ol><p>仅当返回的错误是 <code>ENOBUFS</code>（内核无可用内存）或 socket 已设置 <code>SOCK_NOSPACE</code>（发送队 列已满）时，<code>SNDBUFERRORS</code> 统计信息才会增加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * ENOBUFS &#x3D; no kernel mem, SOCK_NOSPACE &#x3D; no sndbuf space.  Reporting</span><br><span class="line"> * ENOBUFS might not be good (it&#39;s not tunable per se), but otherwise</span><br><span class="line"> * we don&#39;t have a good statistic (IpOutDiscards but it can be too many</span><br><span class="line"> * things).  We could add another new stat but at least for now that</span><br><span class="line"> * seems like overkill.</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (err &#x3D;&#x3D; -ENOBUFS || test_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags)) &#123;</span><br><span class="line">        UDP_INC_STATS_USER(sock_net(sk),</span><br><span class="line">                        UDP_MIB_SNDBUFERRORS, is_udplite);</span><br><span class="line">&#125;</span><br><span class="line">return err;</span><br></pre></td></tr></table></figure><p>我们接下来会在监控小节里看到如何读取这些计数。</p><h2 id="udp-send-skb">4.2 udp_send_skb</h2><p><code>udp_sendmsg</code> 通过调用 <code>udp_send_skb</code> 函数将 skb 送到下一网络层，在本例中是 IP 协议层。 这个函数做了一些重要的事情：</p><ol><li>向 skb 添加 UDP 头</li><li>处理校验和：软件校验和，硬件校验和或无校验和（如果禁用）</li><li>调用 <code>ip_send_skb</code> 将 skb 发送到 IP 协议层</li><li>更新发送成功或失败的统计计数器</li></ol><p>让我们来看看。首先，创建 UDP 头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static int udp_send_skb(struct sk_buff *skb, struct flowi4 *fl4)</span><br><span class="line">&#123;</span><br><span class="line">                &#x2F;* useful variables ... *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Create a UDP header</span><br><span class="line">         *&#x2F;</span><br><span class="line">        uh &#x3D; udp_hdr(skb);</span><br><span class="line">        uh-&gt;source &#x3D; inet-&gt;inet_sport;</span><br><span class="line">        uh-&gt;dest &#x3D; fl4-&gt;fl4_dport;</span><br><span class="line">        uh-&gt;len &#x3D; htons(len);</span><br><span class="line">        uh-&gt;check &#x3D; 0;</span><br></pre></td></tr></table></figure><p>接下来，处理校验和。有几种情况：</p><ol><li>首先处理<a href="https://en.wikipedia.org/wiki/UDP-Lite">UDP-Lite</a>校验和</li><li>接下来，如果 socket 校验和选项被关闭（<code>setsockopt</code> 带 <code>SO_NO_CHECK</code> 参数），它将被标记为校 验和关闭</li><li>接下来，如果硬件支持 UDP 校验和，则将调用 <code>udp4_hwcsum</code> 来设置它。请注意，如果数 据包是分段的，内核将在软件中生成校验和，你可以在 <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/udp.c#L720-L763">udp4_hwcsum</a> 的源代码中看到这一点</li><li>最后，通过调用 <code>udp_csum</code> 生成软件校验和</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (is_udplite)                                  &#x2F;*     UDP-Lite      *&#x2F;</span><br><span class="line">        csum &#x3D; udplite_csum(skb);</span><br><span class="line"></span><br><span class="line">else if (sk-&gt;sk_no_check &#x3D;&#x3D; UDP_CSUM_NOXMIT) &#123;   &#x2F;* UDP csum disabled *&#x2F;</span><br><span class="line"></span><br><span class="line">        skb-&gt;ip_summed &#x3D; CHECKSUM_NONE;</span><br><span class="line">        goto send;</span><br><span class="line"></span><br><span class="line">&#125; else if (skb-&gt;ip_summed &#x3D;&#x3D; CHECKSUM_PARTIAL) &#123; &#x2F;* UDP hardware csum *&#x2F;</span><br><span class="line"></span><br><span class="line">        udp4_hwcsum(skb, fl4-&gt;saddr, fl4-&gt;daddr);</span><br><span class="line">        goto send;</span><br><span class="line"></span><br><span class="line">&#125; else</span><br><span class="line">        csum &#x3D; udp_csum(skb);</span><br></pre></td></tr></table></figure><p>接下来，添加了<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol#IPv4_Pseudo_Header">伪头 </a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uh-&gt;check &#x3D; csum_tcpudp_magic(fl4-&gt;saddr, fl4-&gt;daddr, len,</span><br><span class="line">                              sk-&gt;sk_protocol, csum);</span><br><span class="line">if (uh-&gt;check &#x3D;&#x3D; 0)</span><br><span class="line">        uh-&gt;check &#x3D; CSUM_MANGLED_0;</span><br></pre></td></tr></table></figure><p>如果校验和为 0，则根据<a href="https://tools.ietf.org/html/rfc768">RFC 768</a>，校验为全 1（ transmitted as all ones (the equivalent in one’s complement arithmetic)）。最 后，将 skb 传递给 IP 协议层并增加统计计数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">send:</span><br><span class="line">  err &#x3D; ip_send_skb(sock_net(sk), skb);</span><br><span class="line">  if (err) &#123;</span><br><span class="line">          if (err &#x3D;&#x3D; -ENOBUFS &amp;&amp; !inet-&gt;recverr) &#123;</span><br><span class="line">                  UDP_INC_STATS_USER(sock_net(sk),</span><br><span class="line">                                     UDP_MIB_SNDBUFERRORS, is_udplite);</span><br><span class="line">                  err &#x3D; 0;</span><br><span class="line">          &#125;</span><br><span class="line">  &#125; else</span><br><span class="line">          UDP_INC_STATS_USER(sock_net(sk),</span><br><span class="line">                             UDP_MIB_OUTDATAGRAMS, is_udplite);</span><br><span class="line">  return err;</span><br></pre></td></tr></table></figure><p>如果 <code>ip_send_skb</code> 成功，将更新 <code>OUTDATAGRAMS</code> 统计。如果 IP 协议层报告错误，并且错误 是 <code>ENOBUFS</code>（内核缺少内存）而且错误 queue（<code>inet-&gt;recverr</code>）没有启用，则更新 <code>SNDBUFERRORS</code>。</p><p>在继续讨论 IP 协议层之前，让我们先看看如何在 Linux 内核中监视和调优 UDP 协议层。</p><h2 id="监控：UDP-层统计">4.3 监控：UDP 层统计</h2><p>两个非常有用的获取 UDP 协议统计文件：</p><ul><li><code>/proc/net/snmp</code></li><li><code>/proc/net/udp</code></li></ul><h3 id="proc-net-snmp">4.3.1 /proc/net/snmp</h3><p>监控 UDP 协议层统计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;proc&#x2F;net&#x2F;snmp | grep Udp\:</span><br><span class="line">Udp: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors</span><br><span class="line">Udp: 16314 0 0 17161 0 0</span><br></pre></td></tr></table></figure><p>要准确地理解这些计数，你需要仔细地阅读内核代码。一些类型的错误计数并不是只出现在 一种计数中，而可能是出现在多个计数中。</p><ul><li><code>InDatagrams</code>: Incremented when recvmsg was used by a userland program to read datagram. Also incremented when a UDP packet is encapsulated and sent back for processing.</li><li><code>NoPorts</code>: Incremented when UDP packets arrive destined for a port where no program is listening.</li><li><code>InErrors</code>: Incremented in several cases: no memory in the receive queue, when a bad checksum is seen, and if sk_add_backlog fails to add the datagram.</li><li><code>OutDatagrams</code>: Incremented when a UDP packet is handed down without error to the IP protocol layer to be sent.</li><li><code>RcvbufErrors</code>: Incremented when sock_queue_rcv_skb reports that no memory is available; this happens if sk-&gt;sk_rmem_alloc is greater than or equal to sk-&gt;sk_rcvbuf.</li><li><code>SndbufErrors</code>: Incremented if the IP protocol layer reported an error when trying to send the packet and no error queue has been setup. Also incremented if no send queue space or kernel memory are available.</li><li><code>InCsumErrors</code>: Incremented when a UDP checksum failure is detected. Note that in all cases I could find, InCsumErrors is incremented at the same time as InErrors. Thus, InErrors - InCsumErros should yield the count of memory related errors on the receive side.</li></ul><p>注意，UDP 协议层发现的某些错误会出现在其他协议层的统计信息中。一个例子：路由错误 。 <code>udp_sendmsg</code> 发现的路由错误将导致 IP 协议层的 <code>OutNoRoutes</code> 统计增加。</p><h3 id="proc-net-udp">4.3.2 /proc/net/udp</h3><p>监控 UDP socket 统计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;proc&#x2F;net&#x2F;udp</span><br><span class="line">  sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode ref pointer drops</span><br><span class="line">  515: 00000000:B346 00000000:0000 07 00000000:00000000 00:00000000 00000000   104        0 7518 2 0000000000000000 0</span><br><span class="line">  558: 00000000:0371 00000000:0000 07 00000000:00000000 00:00000000 00000000     0        0 7408 2 0000000000000000 0</span><br><span class="line">  588: 0100007F:038F 00000000:0000 07 00000000:00000000 00:00000000 00000000     0        0 7511 2 0000000000000000 0</span><br><span class="line">  769: 00000000:0044 00000000:0000 07 00000000:00000000 00:00000000 00000000     0        0 7673 2 0000000000000000 0</span><br><span class="line">  812: 00000000:006F 00000000:0000 07 00000000:00000000 00:00000000 00000000     0        0 7407 2 0000000000000000 0</span><br></pre></td></tr></table></figure><p>每一列的意思：</p><ul><li><code>sl</code>: Kernel hash slot for the socket</li><li><code>local_address</code>: Hexadecimal local address of the socket and port number, separated by :.</li><li><code>rem_address</code>: Hexadecimal remote address of the socket and port number, separated by :.</li><li><code>st</code>: The state of the socket. Oddly enough, the UDP protocol layer seems to use some TCP socket states. In the example above, 7 is TCP_CLOSE.</li><li><code>tx_queue</code>: The amount of memory allocated in the kernel for outgoing UDP datagrams.</li><li><code>rx_queue</code>: The amount of memory allocated in the kernel for incoming UDP datagrams.</li><li><code>tr</code>, tm-&gt;when, retrnsmt: These fields are unused by the UDP protocol layer.</li><li><code>uid</code>: The effective user id of the user who created this socket.</li><li><code>timeout</code>: Unused by the UDP protocol layer.</li><li><code>inode</code>: The inode number corresponding to this socket. You can use this to help you determine which user process has this socket open. Check /proc/[pid]/fd, which will contain symlinks to socket[:inode].</li><li><code>ref</code>: The current reference count for the socket.</li><li><code>pointer</code>: The memory address in the kernel of the struct sock.</li><li><code>drops</code>: The number of datagram drops associated with this socket. Note that this does not include any drops related to sending datagrams (on corked UDP sockets or otherwise); this is only incremented in receive paths as of the kernel version examined by this blog post.</li></ul><p>打印这些计数的代码在<a href="https://github.com/torvalds/linux/blob/master/net/ipv4/udp.c#L2396-L2431">net/ipv4/udp.c</a>。</p><h2 id="调优：socket-发送队列内存大小">4.4 调优：socket 发送队列内存大小</h2><p>发送队列（也叫“写队列”）的最大值可以通过设置 <code>net.core.wmem_max sysctl</code> 进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysctl -w net.core.wmem_max&#x3D;8388608</span><br></pre></td></tr></table></figure><p><code>sk-&gt;sk_write_queue</code> 用 <code>net.core.wmem_default</code> 初始化， 这个值也可以调整。</p><p>调整初始发送 buffer 大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysctl -w net.core.wmem_default&#x3D;8388608</span><br></pre></td></tr></table></figure><p>也可以通过从应用程序调用 <code>setsockopt</code> 并传递 <code>SO_SNDBUF</code> 来设置 <code>sk-&gt;sk_write_queue</code> 。通过 <code>setsockopt</code> 设置的最大值是 <code>net.core.wmem_max</code>。</p><p>不过，可以通过 <code>setsockopt</code> 并传递 <code>SO_SNDBUFFORCE</code> 来覆盖 <code>net.core.wmem_max</code> 限制， 这需要 <code>CAP_NET_ADMIN</code> 权限。</p><p>每次调用<code>__ip_append_data</code> 分配 skb 时，<code>sk-&gt;sk_wmem_alloc</code> 都会递增。正如我们所看到 的，UDP 数据报传输速度很快，通常不会在发送队列中花费太多时间。</p><h1 id="IP-协议层">5 IP 协议层</h1><p>UDP 协议层通过调用 <code>ip_send_skb</code> 将 skb 交给 IP 协议层，所以我们从这里开始，探索一下 IP 协议层。</p><h2 id="ip-send-skb">5.1 ip_send_skb</h2><p><code>ip_send_skb</code> 函数定义在 <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/ip_output.c#L1367-L1380">net/ipv4/ip_output.c</a> 中，非常简短。它只是调用 <code>ip_local_out</code>，如果调用失败，就更新相应的错误计数。让 我们来看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int ip_send_skb(struct net *net, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">        int err;</span><br><span class="line"></span><br><span class="line">        err &#x3D; ip_local_out(skb);</span><br><span class="line">        if (err) &#123;</span><br><span class="line">                if (err &gt; 0)</span><br><span class="line">                        err &#x3D; net_xmit_errno(err);</span><br><span class="line">                if (err)</span><br><span class="line">                        IP_INC_STATS(net, IPSTATS_MIB_OUTDISCARDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>net_xmit_errno</code> 函数将低层错误转换为 IP 和 UDP 协议层所能理解的错误。如果发生错误， IP 协议计数器 <code>OutDiscards</code> 会递增。稍后我们将看到读取哪些文件可以获取此统计信 息。现在，让我们继续，看看 <code>ip_local_out</code> 带我们去哪。</p><h2 id="ip-local-out-and-ip-local-out">5.2 ip_local_out and __ip_local_out</h2><p>幸运的是，<code>ip_local_out</code> 和<code>__ip_local_out</code> 都很简单。<code>ip_local_out</code> 只需调用 <code>__ip_local_out</code>，如果返回值为 1，则调用路由层 <code>dst_output</code> 发送数据包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int ip_local_out(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">        int err;</span><br><span class="line"></span><br><span class="line">        err &#x3D; __ip_local_out(skb);</span><br><span class="line">        if (likely(err &#x3D;&#x3D; 1))</span><br><span class="line">                err &#x3D; dst_output(skb);</span><br><span class="line"></span><br><span class="line">        return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看<code>__ip_local_out</code> 的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int __ip_local_out(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">        struct iphdr *iph &#x3D; ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">        iph-&gt;tot_len &#x3D; htons(skb-&gt;len);</span><br><span class="line">        ip_send_check(iph);</span><br><span class="line">        return nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT, skb, NULL,</span><br><span class="line">                       skb_dst(skb)-&gt;dev, dst_output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该函数首先做了两件重要的事情：</p><ol><li>设置 IP 数据包的长度</li><li>调用 <code>ip_send_check</code> 来计算要写入 IP 头的校验和。<code>ip_send_check</code> 函数将进一步调用 名为 <code>ip_fast_csum</code> 的函数来计算校验和。在 x86 和 x86_64 体系结构上，此函数用汇编实 现，代码：<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/checksum_64.h#L40-L73">64 位实现</a> 和<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/checksum_32.h#L63-L98">32 位实现</a> 。</li></ol><p>接下来，IP 协议层将通过调用 <code>nf_hook</code> 进入 netfilter，其返回值将传递回 <code>ip_local_out</code> 。 如果 <code>nf_hook</code> 返回 1，则表示允许数据包通过，并且调用者应该自己发送数据包。这正 是我们在上面看到的情况：<code>ip_local_out</code> 检查返回值 1 时，自己通过调用 <code>dst_output</code> 发 送数据包。</p><h2 id="netfilter-and-nf-hook">5.3 netfilter and nf_hook</h2><p>简洁起见，我决定跳过对 netfilter，iptables 和 conntrack 的深入研究。如果你想深入了解 netfilter 的代码实现，可以从 <code>include/linux/netfilter.h</code><a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/netfilter.h#L142-L147">这里 </a>和 <code>net/netfilter/core.c</code><a href="https://github.com/torvalds/linux/blob/v3.13/net/netfilter/core.c#L168-L209">这里 </a>开 始。</p><p>简短版本是：<code>nf_hook</code> 只是一个 wrapper，它调用 <code>nf_hook_thresh</code>，首先检查是否有为这 个<strong>协议族</strong>和<strong>hook 类型</strong>（这里分别为 <code>NFPROTO_IPV4</code> 和 <code>NF_INET_LOCAL_OUT</code>）安装 的过滤器，然后将返回到 IP 协议层，避免深入到 netfilter 或更下面，比如 iptables 和 conntrack。</p><p>请记住：如果你有非常多或者非常复杂的 netfilter 或 iptables 规则，那些规则将在触发 <code>sendmsg</code> 系统调的用户进程的上下文中执行。如果对这个用户进程设置了 CPU 亲和性，相应 的 CPU 将花费系统时间（system time）处理出站（outbound）iptables 规则。如果你在做性 能回归测试，那可能要考虑根据系统的负载，将相应的用户进程绑到到特定的 CPU，或者是 减少 netfilter/iptables 规则的复杂度，以减少对性能测试的影响。</p><p>出于讨论目的，我们假设 <code>nf_hook</code> 返回 1，表示调用者（在这种情况下是 IP 协议层）应该 自己发送数据包。</p><h2 id="目的（路由）缓存">5.4 目的（路由）缓存</h2><p>dst 代码在 Linux 内核中实现<strong>协议无关</strong>的目标缓存。为了继续学习发送 UDP 数据报的流程 ，我们需要了解 dst 条目是如何被设置的，首先来看 dst 条目和路由是如何生成的。 目标缓 存，路由和邻居子系统，任何一个都可以拿来单独详细的介绍。我们不深入细节，只是快速 地看一下它们是如何组合到一起的。</p><p>我们上面看到的代码调用了 <code>dst_output(skb)</code>。 此函数只是查找关联到这个 skb 的 dst 条目 ，然后调用 <code>output</code> 方法。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Output packet to network from transport.  *&#x2F;</span><br><span class="line">static inline int dst_output(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">        return skb_dst(skb)-&gt;output(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来很简单，但是 <code>output</code> 方法之前是如何关联到 dst 条目的？</p><p>首先很重要的一点，目标缓存条目是以多种不同方式添加的。到目前为止，我们已经在代码 中看到的一种方法是从 <code>udp_sendmsg</code> 调用 <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/route.c#L2252-L2267">ip_route_output_flow</a> 。<code>ip_route_output_flow</code> 函数调用 <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/route.c#L1990-L2173">__ip_route_output_key</a> ，后者进而调用 <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/route.c#L1868-L1988">__mkroute_output</a> 。 <code>__mkroute_output</code> 函数创建路由和目标缓存条目。当它执行创建操作时，它会判断哪 个 <code>output</code> 方法适合此 dst。大多数时候，这个函数是 <code>ip_output</code>。</p><h2 id="ip-output">5.5 ip_output</h2><p>在 UDP IPv4 情况下，上面的 <code>output</code> 方法指向的是 <code>ip_output</code>。<code>ip_output</code> 函数很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int ip_output(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">        struct net_device *dev &#x3D; skb_dst(skb)-&gt;dev;</span><br><span class="line"></span><br><span class="line">        IP_UPD_PO_STATS(dev_net(dev), IPSTATS_MIB_OUT, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">        skb-&gt;dev &#x3D; dev;</span><br><span class="line">        skb-&gt;protocol &#x3D; htons(ETH_P_IP);</span><br><span class="line"></span><br><span class="line">        return NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING, skb, NULL, dev,</span><br><span class="line">                            ip_finish_output,</span><br><span class="line">                            !(IPCB(skb)-&gt;flags &amp; IPSKB_REROUTED));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，更新 <code>IPSTATS_MIB_OUT</code> 统计计数。<code>IP_UPD_PO_STATS</code> 宏将更新字节数和包数统计。 我们将在后面的部分中看到如何获取 IP 协议层统计信息以及它们各自的含义。接下来，设置 要发送此 skb 的设备，以及协议。</p><p>最后，通过调用 <code>NF_HOOK_COND</code> 将控制权交给 netfilter。查看 <code>NF_HOOK_COND</code> 的函数原型 有助于更清晰地解释它如何工作。来自 <a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/netfilter.h#L177-L188">include/linux/netfilter.h</a> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline int</span><br><span class="line">NF_HOOK_COND(uint8_t pf, unsigned int hook, struct sk_buff *skb,</span><br><span class="line">             struct net_device *in, struct net_device *out,</span><br><span class="line">             int (*okfn)(struct sk_buff *), bool cond)</span><br></pre></td></tr></table></figure><p><code>NF_HOOK_COND</code> 通过检查传入的条件来工作。在这里条件是<code>!(IPCB(skb)-&gt;flags &amp; IPSKB_REROUTED</code>。如果此条件为真，则 skb 将发送给 netfilter。如果 netfilter 允许包通过 ，<code>okfn</code> 回调函数将被调用。在这里，<code>okfn</code> 是 <code>ip_finish_output</code>。</p><h2 id="ip-finish-output">5.6 ip_finish_output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static int ip_finish_output(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">#if defined(CONFIG_NETFILTER) &amp;&amp; defined(CONFIG_XFRM)</span><br><span class="line">        &#x2F;* Policy lookup after SNAT yielded a new policy *&#x2F;</span><br><span class="line">        if (skb_dst(skb)-&gt;xfrm !&#x3D; NULL) &#123;</span><br><span class="line">                IPCB(skb)-&gt;flags |&#x3D; IPSKB_REROUTED;</span><br><span class="line">                return dst_output(skb);</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">        if (skb-&gt;len &gt; ip_skb_dst_mtu(skb) &amp;&amp; !skb_is_gso(skb))</span><br><span class="line">                return ip_fragment(skb, ip_finish_output2);</span><br><span class="line">        else</span><br><span class="line">                return ip_finish_output2(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果内核启用了 netfilter 和数据包转换（XFRM），则更新 skb 的标志并通过 <code>dst_output</code> 将 其发回。</p><p>更常见的两种情况是：</p><ol><li>如果数据包的长度大于 MTU 并且分片不会 offload 到设备，则会调用 <code>ip_fragment</code> 在发送之前对数据包进行分片</li><li>否则，数据包将直接发送到 ip_finish_output2</li></ol><p>在继续我们的内核之前，让我们简单地谈谈 Path MTU Discovery。</p><h3 id="Path-MTU-Discovery">5.6.1 Path MTU Discovery</h3><p>Linux 提供了一个功能，我迄今为止一直避免提及：<a href="https://en.wikipedia.org/wiki/Path_MTU_Discovery">路径 MTU 发现 </a>。此功能允许内核自动确定 路由的最大传输单元（ <a href="https://en.wikipedia.org/wiki/Maximum_transmission_unit">MTU</a> ）。发送小于或等于该路由的 MTU 的包意味着可以避免 IP 分片，这是推荐设置，因为数 据包分片会消耗系统资源，而避免分片看起来很容易：只需发送足够小的不需要分片的数据 包。</p><p>你可以在应用程序中通过调用 <code>setsockopt</code> 带 <code>SOL_IP</code> 和 <code>IP_MTU_DISCOVER</code> 选项，在 packet 级别来调整路径 MTU 发现设置，相应的合法值参考 IP 协议的<a href="http://man7.org/linux/man-pages/man7/ip.7.html">man page</a>。例如，你可能想设置的值是 ：<code>IP_PMTUDISC_DO</code>，表示“始终执行路径 MTU 发现”。更高级的网络应用程序或诊断工具可 能选择自己实现<a href="https://www.ietf.org/rfc/rfc4821.txt">RFC 4821</a>，以在应用程序启动 时针对特定的路由做 PMTU。在这种情况下，你可以使用 <code>IP_PMTUDISC_PROBE</code> 选项告诉内核 设置“Do not Fragment”位，这就会允许你发送大于 PMTU 的数据。</p><p>应用程序可以通过调用 <code>getsockopt</code> 带 <code>SOL_IP</code> 和 <code>IP_MTU</code> 选项来查看当前 PMTU。可以使 用它指导应用程序在发送之前，构造 UDP 数据报的大小。</p><p>如果已启用 PMTU 发现，则发送大于 PMTU 的 UDP 数据将导致应用程序收到 <code>EMSGSIZE</code> 错误。 这种情况下，应用程序只能减小 packet 大小重试。</p><p>强烈建议启用 PTMU 发现，因此我将不再详细描述 IP 分片的代码。当我们查看 IP 协议层统计信 息时，我将解释所有统计信息，包括与分片相关的统计信息。其中许多计数都在 <code>ip_fragment</code> 中更新的。不管分片与否，代码最后都会调到 <code>ip_finish_output2</code>，所以让 我们继续。</p><h2 id="ip-finish-output2">5.7 ip_finish_output2</h2><p>IP 分片后调用 <code>ip_finish_output2</code>，另外 <code>ip_finish_output</code> 也会直接调用它。这个函数 在将包发送到邻居缓存之前处理各种统计计数器。让我们看看它是如何工作的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static inline int ip_finish_output2(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;* variable declarations *&#x2F;</span><br><span class="line"></span><br><span class="line">        if (rt-&gt;rt_type &#x3D;&#x3D; RTN_MULTICAST) &#123;</span><br><span class="line">                IP_UPD_PO_STATS(dev_net(dev), IPSTATS_MIB_OUTMCAST, skb-&gt;len);</span><br><span class="line">        &#125; else if (rt-&gt;rt_type &#x3D;&#x3D; RTN_BROADCAST)</span><br><span class="line">                IP_UPD_PO_STATS(dev_net(dev), IPSTATS_MIB_OUTBCAST, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">        &#x2F;* Be paranoid, rather than too clever. *&#x2F;</span><br><span class="line">        if (unlikely(skb_headroom(skb) &lt; hh_len &amp;&amp; dev-&gt;header_ops)) &#123;</span><br><span class="line">                struct sk_buff *skb2;</span><br><span class="line"></span><br><span class="line">                skb2 &#x3D; skb_realloc_headroom(skb, LL_RESERVED_SPACE(dev));</span><br><span class="line">                if (skb2 &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                        kfree_skb(skb);</span><br><span class="line">                        return -ENOMEM;</span><br><span class="line">                &#125;</span><br><span class="line">                if (skb-&gt;sk)</span><br><span class="line">                        skb_set_owner_w(skb2, skb-&gt;sk);</span><br><span class="line">                consume_skb(skb);</span><br><span class="line">                skb &#x3D; skb2;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>如果与此数据包关联的路由是多播类型，则使用 <code>IP_UPD_PO_STATS</code> 宏来增加 <code>OutMcastPkts</code> 和 <code>OutMcastOctets</code> 计数。如果广播路由，则会增加 <code>OutBcastPkts</code> 和 <code>OutBcastOctets</code> 计数。</p><p>接下来，确保 skb 结构有足够的空间容纳需要添加的任何链路层头。如果空间不够，则调用 <code>skb_realloc_headroom</code> 分配额外的空间，并且新的 skb 的费用（charge）记在相关的 socket 上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rcu_read_lock_bh();</span><br><span class="line">nexthop &#x3D; (__force u32) rt_nexthop(rt, ip_hdr(skb)-&gt;daddr);</span><br><span class="line">neigh &#x3D; __ipv4_neigh_lookup_noref(dev, nexthop);</span><br><span class="line">if (unlikely(!neigh))</span><br><span class="line">        neigh &#x3D; __neigh_create(&amp;arp_tbl, &amp;nexthop, dev, false);</span><br></pre></td></tr></table></figure><p>继续，查询路由层找到下一跳，再根据下一跳信息查找邻居缓存。如果未找到，则 调用<code>__neigh_create</code> 创建一个邻居。例如，第一次将数据发送到另一 台主机的时候，就是这种情况。请注意，创建邻居缓存的时候带了 <code>arp_tbl</code>（ <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/arp.c#L160-L187">net/ipv4/arp.c</a> 中定义）参数。其他系统（如 IPv6 或 <a href="https://en.wikipedia.org/wiki/DECnet">DECnet</a>）维护自己的 ARP 表，并将不同的变量 传给<code>__neigh_create</code>。 这篇文章的目的并不是要详细介绍邻居缓存，但注意如果创建， 会导致缓存表增大。本文后面会介绍有关邻居缓存的更多详细信息。 邻居缓存会导出一组 统计信息，以便可以衡量这种增长。有关详细信息，请参阅下面的监控部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        if (!IS_ERR(neigh)) &#123;</span><br><span class="line">                int res &#x3D; dst_neigh_output(dst, neigh, skb);</span><br><span class="line"></span><br><span class="line">                rcu_read_unlock_bh();</span><br><span class="line">                return res;</span><br><span class="line">        &#125;</span><br><span class="line">        rcu_read_unlock_bh();</span><br><span class="line"></span><br><span class="line">        net_dbg_ratelimited(&quot;%s: No header cache and no neighbour!\n&quot;,</span><br><span class="line">                            __func__);</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">        return -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，如果创建邻居缓存成功，则调用 <code>dst_neigh_output</code> 继续传递 skb；否则，释放 skb 并返 回 <code>EINVAL</code>，这会向上传递，导致 <code>OutDiscards</code> 在 <code>ip_send_skb</code> 中递增。让我们继续在 <code>dst_neigh_output</code> 中接近 Linux 内核的 netdevice 子系统。</p><h2 id="dst-neigh-output">5.8 dst_neigh_output</h2><p><code>dst_neigh_output</code> 函数做了两件重要的事情。首先，回想一下之前在本文中我 们看到，如果用户调用 <code>sendmsg</code> 并通过辅助消息指定 <code>MSG_CONFIRM</code> 参数，则会设置一个标 志位以指示目标高速缓存条目仍然有效且不应进行垃圾回收。这个检查就是在这个函数里面 做的，并且邻居上的 <code>confirm</code> 字段设置为当前的 jiffies 计数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static inline int dst_neigh_output(struct dst_entry *dst, struct neighbour *n,</span><br><span class="line">                                   struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">        const struct hh_cache *hh;</span><br><span class="line"></span><br><span class="line">        if (dst-&gt;pending_confirm) &#123;</span><br><span class="line">                unsigned long now &#x3D; jiffies;</span><br><span class="line"></span><br><span class="line">                dst-&gt;pending_confirm &#x3D; 0;</span><br><span class="line">                &#x2F;* avoid dirtying neighbour *&#x2F;</span><br><span class="line">                if (n-&gt;confirmed !&#x3D; now)</span><br><span class="line">                        n-&gt;confirmed &#x3D; now;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>其次，检查邻居的状态并调用适当的 <code>output</code> 函数。让我们看一下这些条件，并尝试了解发 生了什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        hh &#x3D; &amp;n-&gt;hh;</span><br><span class="line">        if ((n-&gt;nud_state &amp; NUD_CONNECTED) &amp;&amp; hh-&gt;hh_len)</span><br><span class="line">                return neigh_hh_output(hh, skb);</span><br><span class="line">        else</span><br><span class="line">                return n-&gt;output(n, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邻居被认为是 <code>NUD_CONNECTED</code>，如果它满足以下一个或多个条件：</p><ol><li><code>NUD_PERMANENT</code>：静态路由</li><li><code>NUD_NOARP</code>：不需要 ARP 请求（例如，目标是多播或广播地址，或环回设备）</li><li><code>NUD_REACHABLE</code>：邻居是“可达的。”只要<a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/arp.c#L905-L923">成功处理了</a>ARP 请求，目标就会被标记为可达</li></ol><p>进一步，如果“硬件头”（hh）被缓存（之前已经发送过数据，并生成了缓存），将调 用 <code>neigh_hh_output</code>。</p><p>否则，调用 <code>output</code> 函数。</p><p>以上两种情况，最后都会到 <code>dev_queue_xmit</code>，它将 skb 发送给 Linux 网络设备子系统，在它 进入设备驱动程序层之前将对其进行更多处理。让我们沿着 <code>neigh_hh_output</code> 和 <code>n-&gt;output</code> 代码继续向下，直到达到 <code>dev_queue_xmit</code>。</p><h2 id="neigh-hh-output">5.9 neigh_hh_output</h2><p>如果目标是 <code>NUD_CONNECTED</code> 并且硬件头已被缓存，则将调用 <code>neigh_hh_output</code>，在将 skb 移交 给 <code>dev_queue_xmit</code> 之前执行一小部分处理。 我们来看看 <a href="https://github.com/torvalds/linux/blob/v3.13/include/net/neighbour.h#L336-L356">include/net/neighbour.h</a> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static inline int neigh_hh_output(const struct hh_cache *hh, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">        unsigned int seq;</span><br><span class="line">        int hh_len;</span><br><span class="line"></span><br><span class="line">        do &#123;</span><br><span class="line">                seq &#x3D; read_seqbegin(&amp;hh-&gt;hh_lock);</span><br><span class="line">                hh_len &#x3D; hh-&gt;hh_len;</span><br><span class="line">                if (likely(hh_len &lt;&#x3D; HH_DATA_MOD)) &#123;</span><br><span class="line">                        &#x2F;* this is inlined by gcc *&#x2F;</span><br><span class="line">                        memcpy(skb-&gt;data - HH_DATA_MOD, hh-&gt;hh_data, HH_DATA_MOD);</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                         int hh_alen &#x3D; HH_DATA_ALIGN(hh_len);</span><br><span class="line"></span><br><span class="line">                         memcpy(skb-&gt;data - hh_alen, hh-&gt;hh_data, hh_alen);</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125; while (read_seqretry(&amp;hh-&gt;hh_lock, seq));</span><br><span class="line"></span><br><span class="line">         skb_push(skb, hh_len);</span><br><span class="line">         return dev_queue_xmit(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数理解有点难，部分原因是<a href="https://en.wikipedia.org/wiki/Seqlock">seqlock</a>这 个东西，它用于在缓存的硬件头上做读/写锁。可以将上面的 <code>do &#123;&#125; while ()</code>循环想象成 一个简单的重试机制，它将尝试在循环中执行，直到成功。</p><p>循环里处理硬件头的长度对齐。这是必需的，因为某些硬件头（如<a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/ieee80211.h#L210-L218">IEEE 802.11</a> 头）大于 <code>HH_DATA_MOD</code>（16 字节）。</p><p>将头数据复制到 skb 后，<code>skb_push</code> 将更新 skb 内指向数据缓冲区的指针。最后调用 <code>dev_queue_xmit</code> 将 skb 传递给 Linux 网络设备子系统。</p><h2 id="n-gt-output">5.10 n-&gt;output</h2><p>如果目标不是 <code>NUD_CONNECTED</code> 或硬件头尚未缓存，则代码沿 <code>n-&gt;output</code> 路径向下。 neigbour 结构上的 <code>output</code> 指针指向哪个函数？这得看情况。要了解这是如何设置的，我们 需要更多地了解邻居缓存的工作原理。</p><p><code>struct neighbour</code> 包含几个重要字段：我们在上面看到的 <code>nud_state</code> 字段，<code>output</code> 函数和 <code>ops</code> 结构。回想一下，我们之前看到如果在缓存中找不到现有条目，会从 <code>ip_finish_output2</code> 调用<code>__neigh_create</code> 创建一个。当调用<code>__neigh_creaet</code> 时，将分配邻居，其 <code>output</code> 函 数<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/neighbour.c#L294">最初</a> 设置为 <code>neigh_blackhole</code>。随着<code>__neigh_create</code> 代码的进行，它将根据邻居的状态修改 <code>output</code> 值以指向适当的发送方法。</p><p>例如，当代码确定是“已连接的”邻居时，<code>neigh_connect</code> 会将 <code>output</code> 设置为 <code>neigh-&gt;ops-&gt;connected_output</code>。或者，当代码怀疑邻居可能已关闭时，<code>neigh_suspect</code> 会将 <code>output</code> 设置为 <code>neigh-&gt;ops-&gt;output</code>（例如，如果已超过 <code>/proc/sys/net/ipv4/neigh/default/delay_first_probe_time</code> 自发送探测以来的 <code>delay_first_probe_time</code> 秒）。</p><p>换句话说：<code>neigh-&gt;output</code> 会被设置为 <code>neigh-&gt;ops_connected_output</code> 或 <code>neigh-&gt;ops-&gt;output</code>，具体取决于邻居的状态。<code>neigh-&gt;ops</code> 来自哪里？</p><p>分配邻居后，调用 <code>arp_constructor</code>（ <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/arp.c#L220-L313">net/ipv4/arp.c</a> ）来设置 <code>struct neighbor</code> 的某些字段。特别是，此函数会检查与此邻居关联的设备是否 导出来一个 <code>struct header_ops</code> 实例（<a href="https://github.com/torvalds/linux/blob/v3.13/net/ethernet/eth.c#L342-L348">以太网设备是这样做的 </a>）， 该结构体有一个 <code>cache</code> 方法。</p><p><code>neigh-&gt;ops</code> 设置为 <a href="https://github.com/torvalds/linux/blob/v3.13/net/ipv4/arp.c#L138-L144">net/ipv4/arp</a> 中定义的以下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static const struct neigh_ops arp_hh_ops &#x3D; &#123;</span><br><span class="line">        .family &#x3D;               AF_INET,</span><br><span class="line">        .solicit &#x3D;              arp_solicit,</span><br><span class="line">        .error_report &#x3D;         arp_error_report,</span><br><span class="line">        .output &#x3D;               neigh_resolve_output,</span><br><span class="line">        .connected_output &#x3D;     neigh_resolve_output,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以，不管 neighbor 是不是“已连接的”，或者邻居缓存代码是否怀疑连接“已关闭”， <code>neigh_resolve_output</code> 最终都会被赋给 <code>neigh-&gt;output</code>。当执行到 <code>n-&gt;output</code> 时就会调 用它。</p><h3 id="neigh-resolve-output">5.10.1 neigh_resolve_output</h3><p>此函数的目的是解析未连接的邻居，或已连接但没有缓存硬件头的邻居。我们来看看这个 函数是如何工作的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Slow and careful. *&#x2F;</span><br><span class="line"></span><br><span class="line">int neigh_resolve_output(struct neighbour *neigh, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">        struct dst_entry *dst &#x3D; skb_dst(skb);</span><br><span class="line">        int rc &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        if (!dst)</span><br><span class="line">                goto discard;</span><br><span class="line"></span><br><span class="line">        if (!neigh_event_send(neigh, skb)) &#123;</span><br><span class="line">                int err;</span><br><span class="line">                struct net_device *dev &#x3D; neigh-&gt;dev;</span><br><span class="line">                unsigned int seq;</span><br></pre></td></tr></table></figure><p>代码首先进行一些基本检查，然后调用 <code>neigh_event_send</code>。 <code>neigh_event_send</code> 函数是 <code>__neigh_event_send</code> 的简单封装，后者干大部分脏话累活。可以在 <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/neighbour.c#L964-L1028">net/core/neighbour.c</a> 中读<code>__neigh_event_send</code> 的源代码，从大的层面看，三种情况：</p><ol><li><code>NUD_NONE</code> 状态（默认状态）的邻居：假设 <code>/proc/sys/net/ipv4/neigh/default/app_solicit</code> 和 <code>/proc/sys/net/ipv4/neigh/default/mcast_solicit</code> 配置允许发送探测（如果不是， 则将状态标记为 <code>NUD_FAILED</code>），将导致立即发送 ARP 请求。邻居状态将更新为 <code>NUD_INCOMPLETE</code></li><li><code>NUD_STALE</code> 状态的邻居：将更新为 <code>NUD_DELAYED</code> 并且将设置计时器以稍后探测它们（ 稍后是现在的时间+<code>/proc/sys/net/ipv4/neigh/default/delay_first_probe_time</code> 秒 ）</li><li>检查 <code>NUD_INCOMPLETE</code> 状态的邻居（包括上面第一种情形），以确保未解析邻居的排 队 packet 的数量小于等于<code>/proc/sys/net/ipv4/neigh/default/unres_qlen</code>。如果超过 ，则数据包会出列并丢弃，直到小于等于 proc 中的值。 统计信息中有个计数器会因此 更新</li></ol><p>如果需要 ARP 探测，ARP 将立即被发送。<code>__neigh_event_send</code> 将返回 0，表示邻居被视为“已 连接”或“已延迟”，否则返回 1。返回值 0 允许 <code>neigh_resolve_output</code> 继续：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (dev-&gt;header_ops-&gt;cache &amp;&amp; !neigh-&gt;hh.hh_len)</span><br><span class="line">        neigh_hh_init(neigh, dst);</span><br></pre></td></tr></table></figure><p>如果邻居关联的设备的协议实现（在我们的例子中是以太网）支持缓存硬件头，并且当前没 有缓存，<code>neigh_hh_init</code> 将缓存它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">        __skb_pull(skb, skb_network_offset(skb));</span><br><span class="line">        seq &#x3D; read_seqbegin(&amp;neigh-&gt;ha_lock);</span><br><span class="line">        err &#x3D; dev_hard_header(skb, dev, ntohs(skb-&gt;protocol),</span><br><span class="line">                              neigh-&gt;ha, NULL, skb-&gt;len);</span><br><span class="line">&#125; while (read_seqretry(&amp;neigh-&gt;ha_lock, seq));</span><br></pre></td></tr></table></figure><p>接下来，seqlock 锁控制对邻居的硬件地址字段（<code>neigh-&gt;ha</code>）的访问。 <code>dev_hard_header</code> 为 skb 创建以太网头时将读取该字段。</p><p>之后是错误检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        if (err &gt;&#x3D; 0)</span><br><span class="line">                rc &#x3D; dev_queue_xmit(skb);</span><br><span class="line">        else</span><br><span class="line">                goto out_kfree_skb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果以太网头写入成功，将调用 <code>dev_queue_xmit</code> 将 skb 传递给 Linux 网络设备子系统进行发 送。如果出现错误，goto 将删除 skb，设置并返回错误码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">out:</span><br><span class="line">        return rc;</span><br><span class="line">discard:</span><br><span class="line">        neigh_dbg(1, &quot;%s: dst&#x3D;%p neigh&#x3D;%p\n&quot;, __func__, dst, neigh);</span><br><span class="line">out_kfree_skb:</span><br><span class="line">        rc &#x3D; -EINVAL;</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">        goto out;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(neigh_resolve_output);</span><br></pre></td></tr></table></figure><p>在我们进入 Linux 网络设备子系统之前，让我们看看一些用于监控和转换 IP 协议层的文件。</p><h2 id="监控-IP-层">5.11 监控: IP 层</h2><h3 id="proc-net-snmp-1">5.11.1 /proc/net/snmp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;proc&#x2F;net&#x2F;snmp</span><br><span class="line">Ip: Forwarding DefaultTTL InReceives InHdrErrors InAddrErrors ForwDatagrams InUnknownProtos InDiscards InDelivers OutRequests OutDiscards OutNoRoutes ReasmTimeout ReasmReqds ReasmOKs ReasmFails FragOKs FragFails FragCreates</span><br><span class="line">Ip: 1 64 25922988125 0 0 15771700 0 0 25898327616 22789396404 12987882 51 1 10129840 2196520 1 0 0 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这个文件包扩多种协议的统计，IP 层的在最前面，每一列代表什么有说明。</p><p>前面我们已经看到 IP 协议层有一些地方会更新计数器。这些计数器的类型是 C 枚举类型，定 义在<a href="https://github.com/torvalds/linux/blob/v3.13/include/uapi/linux/snmp.h#L10-L59">include/uapi/linux/snmp.h</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">  IPSTATS_MIB_NUM &#x3D; 0,</span><br><span class="line">&#x2F;* frequently written fields in fast path, kept in same cache line *&#x2F;</span><br><span class="line">  IPSTATS_MIB_INPKTS,     &#x2F;* InReceives *&#x2F;</span><br><span class="line">  IPSTATS_MIB_INOCTETS,     &#x2F;* InOctets *&#x2F;</span><br><span class="line">  IPSTATS_MIB_INDELIVERS,     &#x2F;* InDelivers *&#x2F;</span><br><span class="line">  IPSTATS_MIB_OUTFORWDATAGRAMS,   &#x2F;* OutForwDatagrams *&#x2F;</span><br><span class="line">  IPSTATS_MIB_OUTPKTS,      &#x2F;* OutRequests *&#x2F;</span><br><span class="line">  IPSTATS_MIB_OUTOCTETS,      &#x2F;* OutOctets *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;* ... *&#x2F;</span><br></pre></td></tr></table></figure><p>一些有趣的统计：</p><ul><li><code>OutRequests</code>: Incremented each time an IP packet is attempted to be sent. It appears that this is incremented for every send, successful or not.</li><li><code>OutDiscards</code>: Incremented each time an IP packet is discarded. This can happen if appending data to the skb (for corked sockets) fails, or if the layers below IP return an error.</li><li><code>OutNoRoute</code>: Incremented in several places, for example in the UDP protocol layer (udp_sendmsg) if no route can be generated for a given destination. Also incremented when an application calls “connect” on a UDP socket but no route can be found.</li><li><code>FragOKs</code>: Incremented once per packet that is fragmented. For example, a packet split into 3 fragments will cause this counter to be incremented once.</li><li><code>FragCreates</code>: Incremented once per fragment that is created. For example, a packet split into 3 fragments will cause this counter to be incremented thrice.</li><li><code>FragFails</code>: Incremented if fragmentation was attempted, but is not permitted (because the “Don’t Fragment” bit is set). Also incremented if outputting the fragment fails.</li></ul><p>其他（接收数据部分）的统计可以见本文的姊妹篇：<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#monitoring-ip-protocol-layer-statistics">原文 </a>，<a href="http://arthurchiao.art/blog/tuning-stack-tx-zh/">中文翻译版</a>。</p><h3 id="proc-net-netstat">5.11.2 /proc/net/netstat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;proc&#x2F;net&#x2F;netstat | grep IpExt</span><br><span class="line">IpExt: InNoRoutes InTruncatedPkts InMcastPkts OutMcastPkts InBcastPkts OutBcastPkts InOctets OutOctets InMcastOctets OutMcastOctets InBcastOctets OutBcastOctets InCsumErrors InNoECTPkts InECT0Pktsu InCEPkts</span><br><span class="line">IpExt: 0 0 0 0 277959 0 14568040307695 32991309088496 0 0 58649349 0 0 0 0 0</span><br></pre></td></tr></table></figure><p>格式与前面的类似，除了每列的名称都有 <code>IpExt</code> 前缀之外。</p><p>一些有趣的统计：</p><ul><li><code>OutMcastPkts</code>: Incremented each time a packet destined for a multicast address is sent.</li><li><code>OutBcastPkts</code>: Incremented each time a packet destined for a broadcast address is sent.</li><li><code>OutOctects</code>: The number of packet bytes output.</li><li><code>OutMcastOctets</code>: The number of multicast packet bytes output.</li><li><code>OutBcastOctets</code>: The number of broadcast packet bytes output.</li></ul><p>其他（接收数据部分）的统计可以见本文的姊妹篇：<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#monitoring-ip-protocol-layer-statistics">原文 </a>，<a href="http://arthurchiao.art/blog/tuning-stack-tx-zh/">中文翻译版</a>。</p><p>注意这些计数分别在 IP 层的不同地方被更新。由于代码一直在更新，重复计数或者计数错误 的 bug 可能会引入。如果这些计数对你非常重要，强烈建议你阅读内核的相应源码，确定它 们是在哪里被更新的，以及更新的对不对，是不是有 bug。</p><h1 id="Linux-netdevice-子系统">6 Linux netdevice 子系统</h1><p>在继续跟进 <code>dev_queue_xmit</code> 发送数据包之前，让我们花点时间介绍几个将在下一部分中出 现的重要概念。</p><h2 id="Linux-traffic-control（流量控制）">6.1 Linux traffic control（流量控制）</h2><p>Linux 支持称为流量控制（<a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/intro.html">traffic control</a>）的功能。此功能 允许系统管理员控制数据包如何从机器发送出去。本文不会深入探讨 Linux 流量控制 的各个方面的细节。<a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/">这篇文档</a>对流量 控制系统、它如何控制流量，及其其特性进行了深入的介绍。</p><p>这里介绍一些值得一提的概念，使后面的代码更容易理解。</p><p>流量控制系统包含几组不同的 queue system，每种有不同的排队特征。各个排队系统通常称 为 qdisc，也称为排队规则。你可以将 qdisc 视为<strong>调度程序</strong>; qdisc 决定数据包的发送时 间和方式。</p><p>在 Linux 上，每个 device 都有一个与之关联的默认 qdisc。对于仅支持单发送队列的网卡，使 用默认的 qdisc <code>pfifo_fast</code>。支持多个发送队列的网卡使用 mq 的默认 qdisc。可以运行 <code>tc qdisc</code> 来查看系统 qdisc 信息。</p><p>某些设备支持硬件流量控制，这允许管理员将流量控制 offload 到网络硬件，节省系统的 CPU 资源。</p><p>现在已经介绍了这些概念，让我们从 <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L2890-L2894">net/core/dev.c</a> 继续 <code>dev_queue_xmit</code>。</p><h2 id="dev-queue-xmit-and-dev-queue-xmit">6.2 dev_queue_xmit and __dev_queue_xmit</h2><p><code>dev_queue_xmit</code> 简单封装了<code>__dev_queue_xmit</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int dev_queue_xmit(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">        return __dev_queue_xmit(skb, NULL);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(dev_queue_xmit);</span><br></pre></td></tr></table></figure><p><code>__dev_queue_xmit</code> 才是干脏活累活的地方。我们<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L2808-L2825">一段段 </a>来看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static int __dev_queue_xmit(struct sk_buff *skb, void *accel_priv)</span><br><span class="line">&#123;</span><br><span class="line">        struct net_device *dev &#x3D; skb-&gt;dev;</span><br><span class="line">        struct netdev_queue *txq;</span><br><span class="line">        struct Qdisc *q;</span><br><span class="line">        int rc &#x3D; -ENOMEM;</span><br><span class="line"></span><br><span class="line">        skb_reset_mac_header(skb);</span><br><span class="line"></span><br><span class="line">        &#x2F;* Disable soft irqs for various locks below. Also</span><br><span class="line">         * stops preemption for RCU.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        rcu_read_lock_bh();</span><br><span class="line"></span><br><span class="line">        skb_update_prio(skb);</span><br></pre></td></tr></table></figure><p>开始的逻辑：</p><ol><li>声明变量</li><li>调用 <code>skb_reset_mac_header</code>，准备发送 skb。这会重置 skb 内部的指针，使得 ether 头可 以被访问</li><li>调用 <code>rcu_read_lock_bh</code>，为接下来的读操作加锁。更多关于使用 RCU 安全访问数据的信 息，可以参考<a href="https://www.kernel.org/doc/Documentation/RCU/checklist.txt">这里</a></li><li>调用 <code>skb_update_prio</code>，如果启用了<a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/cgroups/net_prio.txt">网络优先级 cgroup</a>，这会设置 skb 的优先级</li></ol><p>现在，我们来看更复杂的部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txq &#x3D; netdev_pick_tx(dev, skb, accel_priv);</span><br></pre></td></tr></table></figure><p>这会选择发送队列。本文后面会看到，一些网卡支持多发送队列。我们来看这是如何工作的。</p><h3 id="netdev-pick-tx">6.2.1 netdev_pick_tx</h3><p><code>netdev_pick_tx</code> 定义在<a href="https://github.com/torvalds/linux/blob/v3.13/net/core/flow_dissector.c#L397-L417">net/core/flow_dissector.c</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct netdev_queue *netdev_pick_tx(struct net_device *dev,</span><br><span class="line">                                    struct sk_buff *skb,</span><br><span class="line">                                    void *accel_priv)</span><br><span class="line">&#123;</span><br><span class="line">        int queue_index &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        if (dev-&gt;real_num_tx_queues !&#x3D; 1) &#123;</span><br><span class="line">                const struct net_device_ops *ops &#x3D; dev-&gt;netdev_ops;</span><br><span class="line">                if (ops-&gt;ndo_select_queue)</span><br><span class="line">                        queue_index &#x3D; ops-&gt;ndo_select_queue(dev, skb,</span><br><span class="line">                                                            accel_priv);</span><br><span class="line">                else</span><br><span class="line">                        queue_index &#x3D; __netdev_pick_tx(dev, skb);</span><br><span class="line"></span><br><span class="line">                if (!accel_priv)</span><br><span class="line">                        queue_index &#x3D; dev_cap_txqueue(dev, queue_index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        skb_set_queue_mapping(skb, queue_index);</span><br><span class="line">        return netdev_get_tx_queue(dev, queue_index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，如果网络设备仅支持单个 TX 队列，则会跳过复杂的代码，直接返回单个 TX 队列。 大多高端服务器上使用的设备都有多个 TX 队列。具有多个 TX 队列的设备有两种情况：</p><ol><li>驱动程序实现 <code>ndo_select_queue</code>，以硬件或 feature-specific 的方式更智能地选择 TX 队列</li><li>驱动程序没有实现 <code>ndo_select_queue</code>，这种情况需要内核自己选择设备</li></ol><p>从 3.13 内核开始，没有多少驱动程序实现 <code>ndo_select_queue</code>。bnx2x 和 ixgbe 驱动程序实 现了此功能，但仅用于以太网光纤通道（<a href="https://en.wikipedia.org/wiki/Fibre_Channel_over_Ethernet">FCoE</a>）。鉴于此，我们假设网络设备没有实现 <code>ndo_select_queue</code> 和/或没有使用 FCoE。在这种情况下，内核将使用<code>__netdev_pick_tx</code> 选择 tx 队列。</p><p>一旦<code>__netdev_pick_tx</code> 确定了队列号，<code>skb_set_queue_mapping</code> 将缓存该值（稍后将在 流量控制代码中使用），<code>netdev_get_tx_queue</code> 将查找并返回指向该队列的指针。让我们 看一下<code>__netdev_pick_tx</code> 在返回<code>__dev_queue_xmit</code> 之前的工作原理。</p><h3 id="netdev-pick-tx-1">6.2.2 __netdev_pick_tx</h3><p>我们来看内核如何选择 TX 队列。 <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/flow_dissector.c#L375-L395">net/core/flow_dissector.c</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">u16 __netdev_pick_tx(struct net_device *dev, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">        struct sock *sk &#x3D; skb-&gt;sk;</span><br><span class="line">        int queue_index &#x3D; sk_tx_queue_get(sk);</span><br><span class="line"></span><br><span class="line">        if (queue_index &lt; 0 || skb-&gt;ooo_okay ||</span><br><span class="line">            queue_index &gt;&#x3D; dev-&gt;real_num_tx_queues) &#123;</span><br><span class="line">                int new_index &#x3D; get_xps_queue(dev, skb);</span><br><span class="line">                if (new_index &lt; 0)</span><br><span class="line">                        new_index &#x3D; skb_tx_hash(dev, skb);</span><br><span class="line"></span><br><span class="line">                if (queue_index !&#x3D; new_index &amp;&amp; sk &amp;&amp;</span><br><span class="line">                    rcu_access_pointer(sk-&gt;sk_dst_cache))</span><br><span class="line">                        sk_tx_queue_set(sk, new_index);</span><br><span class="line"></span><br><span class="line">                queue_index &#x3D; new_index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return queue_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码首先调用 <code>sk_tx_queue_get</code> 检查发送队列是否已经缓存在 socket 上，如果尚未缓存， 则返回-1。</p><p>下一个 if 语句检查是否满足以下任一条件：</p><ol><li><code>queue_index &lt; 0</code>：表示尚未设置 TX queue 的情况</li><li><code>ooo_okay</code> 标志是否非零：如果不为 0，则表示现在允许无序（out of order）数据包。 协议层必须正确地地设置此标志。当 flow 的所有 outstanding（需要确认的？）数据包都 已确认时，TCP 协议层将设置此标志。当发生这种情况时，内核可以为此数据包选择不同 的 TX 队列。UDP 协议层不设置此标志 - 因此 UDP 数据包永远不会将 <code>ooo_okay</code> 设置为非零 值。</li><li>TX queue index 大于 TX queue 数量：如果用户最近通过 ethtool 更改了设备上的队列数， 则会发生这种情况。稍后会详细介绍。</li></ol><p>以上任何一种情况，都表示没有找到合适的 TX queue，因此接下来代码会进入慢路径以继续 寻找合适的发送队列。首先调用 <code>get_xps_queue</code>，它会使用一个由用户配置的 TX queue 到 CPU 的映射，这称为 XPS（Transmit Packet Steering ，发送数据包控制），我们将更详细 地了解 XPS 是什么以及它如何工作。</p><p>如果内核不支持 XPS，或者系统管理员未配置 XPS，或者配置的映射引用了无效队列， <code>get_xps_queue</code> 返回-1，则代码将继续调用 <code>skb_tx_hash</code>。</p><p>一旦 XPS 或内核使用 <code>skb_tx_hash</code> 自动选择了发送队列，<code>sk_tx_queue_set</code> 会将队列缓存 在 socket 对象上，然后返回。让我们看看 XPS，以及 <code>skb_tx_hash</code> 在继续调用 <code>dev_queue_xmit</code> 之前是如何工作的。</p><h4 id="Transmit-Packet-Steering-XPS">6.2.2.1 Transmit Packet Steering (XPS)</h4><p>发送数据包控制（XPS）是一项功能，允许系统管理员配置哪些 CPU 可以处理网卡的哪些发送 队列。XPS 的主要目的是<strong>避免处理发送请求时的锁竞争</strong>。使用 XPS 还可以减少缓存驱逐， 避免<a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a>机器上的远程 内存访问等。</p><p>可以查看内核有关 XPS 的<a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/scaling.txt#L364-L422">文档 </a>了解其如何工作的更多信息。我们后面会介绍如何调整系统的 XPS，现在，你只需要知道 配置 XPS，系统管理员需要定义 TX queue 到 CPU 的映射（bitmap 形式）。</p><p>上面代码中，<code>get_xps_queue</code> 将查询这个用户指定的映射，以确定应使用哪个发送 队列。如果 <code>get_xps_queue</code> 返回-1，则将改为使用 <code>skb_tx_hash</code>。</p><h4 id="skb-tx-hash">6.2.2.2 skb_tx_hash</h4><p>如果 XPS 未包含在内核中，或 XPS 未配置，或配置的队列不可用（可能因为用户调整了队列数 ），<code>skb_tx_hash</code> 将接管以确定应在哪个队列上发送数据。准确理解 <code>skb_tx_hash</code> 的工作 原理非常重要，具体取决于你的发送负载。请注意，这段代码已经随时间做过一些更新，因 此如果你使用的内核版本与本文不同，则应直接查阅相应版本的 j 内核源代码。</p><p>让我们看看它是如何工作的，来自 <a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/netdevice.h#L2331-L2340">include/linux/netdevice.h</a> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Returns a Tx hash for the given packet when dev-&gt;real_num_tx_queues is used</span><br><span class="line"> * as a distribution range limit for the returned value.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static inline u16 skb_tx_hash(const struct net_device *dev,</span><br><span class="line">                              const struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">        return __skb_tx_hash(dev, skb, dev-&gt;real_num_tx_queues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用了<code> __skb_tx_hash</code>, <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/flow_dissector.c#L239-L271">net/core/flow_dissector.c</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Returns a Tx hash based on the given packet descriptor a Tx queues&#39; number</span><br><span class="line"> * to be used as a distribution range.</span><br><span class="line"> *&#x2F;</span><br><span class="line">u16 __skb_tx_hash(const struct net_device *dev, const struct sk_buff *skb,</span><br><span class="line">                  unsigned int num_tx_queues)</span><br><span class="line">&#123;</span><br><span class="line">        u32 hash;</span><br><span class="line">        u16 qoffset &#x3D; 0;</span><br><span class="line">        u16 qcount &#x3D; num_tx_queues;</span><br><span class="line"></span><br><span class="line">        if (skb_rx_queue_recorded(skb)) &#123;</span><br><span class="line">                hash &#x3D; skb_get_rx_queue(skb);</span><br><span class="line">                while (unlikely(hash &gt;&#x3D; num_tx_queues))</span><br><span class="line">                        hash -&#x3D; num_tx_queues;</span><br><span class="line">                return hash;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这个函数中的第一个 if 是一个有趣的短路。函数名 <code>skb_rx_queue_recorded</code> 有点误导。skb 有一个 <code>queue_mapping</code> 字段，rx 和 tx 都会用到这个字段。无论如何，如果系统正在接收数 据包并将其转发到其他地方，则此 if 语句都为 <code>true</code>。否则，代码将继续向下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (dev-&gt;num_tc) &#123;</span><br><span class="line">        u8 tc &#x3D; netdev_get_prio_tc_map(dev, skb-&gt;priority);</span><br><span class="line">        qoffset &#x3D; dev-&gt;tc_to_txq[tc].offset;</span><br><span class="line">        qcount &#x3D; dev-&gt;tc_to_txq[tc].count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要理解这段代码，首先要知道，程序可以设置 socket 上发送的数据的优先级。这可以通过 <code>setsockopt</code> 带 <code>SOL_SOCKET</code> 和 <code>SO_PRIORITY</code> 选项来完成。有关 <code>SO_PRIORITY</code> 的更多信息 ，请参见<a href="http://man7.org/linux/man-pages/man7/socket.7.html">socket (7) man page</a>。</p><p>请注意，如果使用 <code>setsockopt</code> 带 <code>IP_TOS</code> 选项来设置在 socket 上发送的 IP 包的 TOS 标志（ 或者作为辅助消息传递给 <code>sendmsg</code>，在数据包级别设置），内核会将其转换为 <code>skb-&gt;priority</code>。</p><p>如前所述，一些网络设备支持基于硬件的流量控制系统。<strong>如果 num_tc 不为零，则表示此设 备支持基于硬件的流量控制</strong>。这种情况下，将查询一个<strong>packet priority 到该硬件支持 的流量控制</strong>的映射，根据此映射选择适当的流量类型（traffic class）。</p><p>接下来，将计算出该 traffic class 的 TX queue 的范围，它将用于确定发送队列。</p><p>如果 <code>num_tc</code> 为零（网络设备不支持硬件流量控制），则 <code>qcount</code> 和 <code>qoffset</code> 变量分 别设置为发送队列数和 0。</p><p>使用 <code>qcount</code> 和 <code>qoffset</code>，将计算发送队列的 index：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        if (skb-&gt;sk &amp;&amp; skb-&gt;sk-&gt;sk_hash)</span><br><span class="line">                hash &#x3D; skb-&gt;sk-&gt;sk_hash;</span><br><span class="line">        else</span><br><span class="line">                hash &#x3D; (__force u16) skb-&gt;protocol;</span><br><span class="line">        hash &#x3D; __flow_hash_1word(hash);</span><br><span class="line"></span><br><span class="line">        return (u16) (((u64) hash * qcount) &gt;&gt; 32) + qoffset;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__skb_tx_hash);</span><br></pre></td></tr></table></figure><p>最后，通过<code>__netdev_pick_tx</code> 返回选出的 TX queue index。</p><h2 id="继续-dev-queue-xmit">6.3 继续__dev_queue_xmit</h2><p>至此已经选到了合适的发送队列。</p><p>继续<code>__dev_queue_xmit can continue</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        q &#x3D; rcu_dereference_bh(txq-&gt;qdisc);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_NET_CLS_ACT</span><br><span class="line">        skb-&gt;tc_verd &#x3D; SET_TC_AT(skb-&gt;tc_verd, AT_EGRESS);</span><br><span class="line">#endif</span><br><span class="line">        trace_net_dev_queue(skb);</span><br><span class="line">        if (q-&gt;enqueue) &#123;</span><br><span class="line">                rc &#x3D; __dev_xmit_skb(skb, q, dev, txq);</span><br><span class="line">                goto out;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>首先获取与此队列关联的 qdisc。回想一下，之前我们看到单发送队列设备的默认类型是 <code>pfifo_fast</code> qdisc，而对于多队列设备，默认类型是 <code>mq</code> qdisc。</p><p>接下来，如果内核中已启用数据包分类 API，则代码会为 packet 分配 traffic class。 接下 来，检查 disc 是否有合适的队列来存放 packet。像 <code>noqueue</code> 这样的 qdisc 没有队列。 如果 有队列，则代码调用<code>__dev_xmit_skb</code> 继续处理数据，然后跳转到此函数的末尾。我们很快 就会看到<code>__dev_xmit_skb</code>。现在，让我们看看如果没有队列会发生什么，从一个非常有用 的注释开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* The device has no queue. Common case for software devices:</span><br><span class="line">   loopback, all the sorts of tunnels...</span><br><span class="line"></span><br><span class="line">   Really, it is unlikely that netif_tx_lock protection is necessary</span><br><span class="line">   here.  (f.e. loopback and IP tunnels are clean ignoring statistics</span><br><span class="line">   counters.)</span><br><span class="line">   However, it is possible, that they rely on protection</span><br><span class="line">   made by us here.</span><br><span class="line"></span><br><span class="line">   Check this and shot the lock. It is not prone from deadlocks.</span><br><span class="line">   Either shot noqueue qdisc, it is even simpler 8)</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (dev-&gt;flags &amp; IFF_UP) &#123;</span><br><span class="line">        int cpu &#x3D; smp_processor_id(); &#x2F;* ok because BHs are off *&#x2F;</span><br></pre></td></tr></table></figure><p>正如注释所示，<strong>唯一可以拥有”没有队列的 qdisc”的设备是环回设备和隧道设备</strong>。如果 设备当前处于运行状态，则获取当前 CPU，然后判断此设备队列上的发送锁是否由此 CPU 拥有 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (txq-&gt;xmit_lock_owner !&#x3D; cpu) &#123;</span><br><span class="line"></span><br><span class="line">        if (__this_cpu_read(xmit_recursion) &gt; RECURSION_LIMIT)</span><br><span class="line">                goto recursion_alert;</span><br></pre></td></tr></table></figure><p>如果发送锁不由此 CPU 拥有，则在此处检查 per-CPU 计数器变量 <code>xmit_recursion</code>，判断其是 否超过 <code>RECURSION_LIMIT</code>。 一个程序可能会在这段代码这里持续发送数据，然后被抢占， 调度程序选择另一个程序来运行。第二个程序也可能驻留在此持续发送数据。因此， <code>xmit_recursion</code> 计数器用于确保在此处竞争发送数据的程序不超过 <code>RECURSION_LIMIT</code> 个 。</p><p>我们继续：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">                        HARD_TX_LOCK(dev, txq, cpu);</span><br><span class="line"></span><br><span class="line">                        if (!netif_xmit_stopped(txq)) &#123;</span><br><span class="line">                                __this_cpu_inc(xmit_recursion);</span><br><span class="line">                                rc &#x3D; dev_hard_start_xmit(skb, dev, txq);</span><br><span class="line">                                __this_cpu_dec(xmit_recursion);</span><br><span class="line">                                if (dev_xmit_complete(rc)) &#123;</span><br><span class="line">                                        HARD_TX_UNLOCK(dev, txq);</span><br><span class="line">                                        goto out;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        HARD_TX_UNLOCK(dev, txq);</span><br><span class="line">                        net_crit_ratelimited(&quot;Virtual device %s asks to queue packet!\n&quot;,</span><br><span class="line">                                             dev-&gt;name);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                        &#x2F;* Recursion is detected! It is possible,</span><br><span class="line">                         * unfortunately</span><br><span class="line">                         *&#x2F;</span><br><span class="line">recursion_alert:</span><br><span class="line">                        net_crit_ratelimited(&quot;Dead loop on virtual device %s, fix it urgently!\n&quot;,</span><br><span class="line">                                             dev-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>接下来的代码首先尝试获取发送锁，然后检查要使用的设备的发送队列是否被停用。如果没 有停用，则更新 <code>xmit_recursion</code> 计数，然后将数据向下传递到更靠近发送的设备。我们稍 后会更详细地看到 <code>dev_hard_start_xmit</code>。</p><p>或者，如果当前 CPU 是发送锁定的拥有者，或者如果 <code>RECURSION_LIMIT</code> 被命中，则不进行发 送，而会打印告警日志。</p><p>函数剩余部分的代码设置错误码并返回。</p><p>由于我们对真正的以太网设备感兴趣，让我们来看一下之前就需要跟进去的 <code>__dev_xmit_skb</code> 函数，这是发送主线上的函数。</p><h2 id="dev-xmit-skb">6.4 __dev_xmit_skb</h2><p>现在我们带着排队规则 <code>qdisc</code>、网络设备 <code>dev</code> 和发送队列 <code>txq</code> 三个变量来到 <code>__dev_xmit_skb</code>， <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L2684-L2745">net/core/dev.c</a> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static inline int __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,</span><br><span class="line">                                 struct net_device *dev,</span><br><span class="line">                                 struct netdev_queue *txq)</span><br><span class="line">&#123;</span><br><span class="line">        spinlock_t *root_lock &#x3D; qdisc_lock(q);</span><br><span class="line">        bool contended;</span><br><span class="line">        int rc;</span><br><span class="line"></span><br><span class="line">        qdisc_pkt_len_init(skb);</span><br><span class="line">        qdisc_calculate_pkt_len(skb, q);</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Heuristic to force contended enqueues to serialize on a</span><br><span class="line">         * separate lock before trying to get qdisc main lock.</span><br><span class="line">         * This permits __QDISC_STATE_RUNNING owner to get the lock more often</span><br><span class="line">         * and dequeue packets faster.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        contended &#x3D; qdisc_is_running(q);</span><br><span class="line">        if (unlikely(contended))</span><br><span class="line">                spin_lock(&amp;q-&gt;busylock);</span><br></pre></td></tr></table></figure><p>代码首先使用 <code>qdisc_pkt_len_init</code> 和 <code>qdisc_calculate_pkt_len</code> 来计算数据的准确长度 ，稍后 qdisc 会用到该值。 对于硬件 offload（例如 UFO）这是必需的，因为添加的额外的头 信息，硬件 offload 的时候回用到。</p><p>接下来，使用另一个锁来帮助减少 qdisc 主锁上的竞争（我们稍后会看到这第二个锁）。 如 果 qdisc 当前正在运行，那么试图发送的其他程序将在 qdisc 的 <code>busylock</code> 上竞争。 这允许 运行 qdisc 的程序在处理数据包的同时，与较少量的程序竞争第二个主锁。随着竞争者数量 的减少，这种技巧增加了吞吐量。<a href="https://github.com/torvalds/linux/commit/79640a4ca6955e3ebdb7038508fa7a0cd7fa5527">原始 commit 描述 </a>。 接下来是主锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_lock(root_lock);</span><br></pre></td></tr></table></figure><p>接下来处理 3 种可能情况：</p><ol><li>如果 qdisc 已停用</li><li>如果 qdisc 允许数据包 bypass 排队系统，并且没有其他包要发送，并且 qdisc 当前没有运 行。允许包 bypass 所谓的<strong>“work-conserving qdisc” - 那些用于流量整形（traffic reshaping）目的并且不会引起发送延迟的 qdisc</strong></li><li>所有其他情况</li></ol><p>让我们来看看每种情况下发生什么，从 qdisc 停用开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (unlikely(test_bit(__QDISC_STATE_DEACTIVATED, &amp;q-&gt;state))) &#123;</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">        rc &#x3D; NET_XMIT_DROP;</span><br></pre></td></tr></table></figure><p>这很简单。 如果 qdisc 停用，则释放数据并将返回代码设置为 <code>NET_XMIT_DROP</code>。</p><p>接下来，如果 qdisc 允许数据包 bypass，并且没有其他包要发送，并且 qdisc 当前没有运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#125; else if ((q-&gt;flags &amp; TCQ_F_CAN_BYPASS) &amp;&amp; !qdisc_qlen(q) &amp;&amp;</span><br><span class="line">           qdisc_run_begin(q)) &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * This is a work-conserving queue; there are no old skbs</span><br><span class="line">         * waiting to be sent out; and the qdisc is not running -</span><br><span class="line">         * xmit the skb directly.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (!(dev-&gt;priv_flags &amp; IFF_XMIT_DST_RELEASE))</span><br><span class="line">                skb_dst_force(skb);</span><br><span class="line"></span><br><span class="line">        qdisc_bstats_update(q, skb);</span><br><span class="line"></span><br><span class="line">        if (sch_direct_xmit(skb, q, dev, txq, root_lock)) &#123;</span><br><span class="line">                if (unlikely(contended)) &#123;</span><br><span class="line">                        spin_unlock(&amp;q-&gt;busylock);</span><br><span class="line">                        contended &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">                __qdisc_run(q);</span><br><span class="line">        &#125; else</span><br><span class="line">                qdisc_run_end(q);</span><br><span class="line"></span><br><span class="line">        rc &#x3D; NET_XMIT_SUCCESS;</span><br></pre></td></tr></table></figure><p>这个 if 语句有点复杂，如果满足以下所有条件，则整个语句的计算结果为 true：</p><ol><li><code>q-&gt; flags＆TCQ_F_CAN_BYPASS</code>：qdisc 允许数据包绕过排队系统。对于所谓的“ work-conserving” qdiscs 这会是 <code>true</code>；即，允许 packet bypass 流量整形 qdisc。 <code>pfifo_fast</code> qdisc 允许数据包 bypass</li><li><code>!qdisc_qlen(q)</code>：qdisc 的队列中没有待发送的数据</li><li><code>qdisc_run_begin(p)</code>：如果 qdisc 未运行，此函数将设置 qdisc 的状态为“running”并返 回 <code>true</code>，如果 qdisc 已在运行，则返回 <code>false</code></li></ol><p>如果以上三个条件都为 <code>true</code>，那么：</p><ul><li>检查 <code>IFF_XMIT_DST_RELEASE</code> 标志，此标志允许内核释放 skb 的目标缓存。如果标志已禁用，将强制对 skb 进行引用计数</li><li>调用 <code>qdisc_bstats_update</code> 更新 qdisc 发送的字节数和包数统计</li><li>调用 <code>sch_direct_xmit</code> 用于发送数据包。我们将很快深入研究 <code>sch_direct_xmit</code>，因为慢路径也会调用到它</li></ul><p><code>sch_direct_xmit</code> 的返回值有两种情况：</p><ol><li>队列不为空（返回&gt; 0）。在这种情况下，<code>busylock</code> 将被释放，然后调用<code>__qdisc_run</code> 重新启动 qdisc 处理</li><li>队列为空（返回 0）。在这种情况下，<code>qdisc_run_end</code> 用于关闭 qdisc 处理</li></ol><p>在任何一种情况下，都会返回 <code>NET_XMIT_SUCCESS</code>，这不是太糟糕。</p><p>让我们检查最后一种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#125; else &#123;</span><br><span class="line">        skb_dst_force(skb);</span><br><span class="line">        rc &#x3D; q-&gt;enqueue(skb, q) &amp; NET_XMIT_MASK;</span><br><span class="line">        if (qdisc_run_begin(q)) &#123;</span><br><span class="line">                if (unlikely(contended)) &#123;</span><br><span class="line">                        spin_unlock(&amp;q-&gt;busylock);</span><br><span class="line">                        contended &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">                __qdisc_run(q);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在所有其他情况下：</p><ol><li>调用 <code>skb_dst_force</code> 强制对 skb 的目标缓存进行引用计数</li><li>调用 qdisc 的 <code>enqueue</code> 方法将数据入队，保存函数返回值</li><li>调用 <code>qdisc_run_begin(p)</code>将 qdisc 标记为正在运行。如果它尚未运行（<code>contended == false</code>），则释放 <code>busylock</code>，然后调用<code>__qdisc_run(p)</code>启动 qdisc 处理</li></ol><p>函数最后释放相应的锁，并返回状态码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spin_unlock(root_lock);</span><br><span class="line">if (unlikely(contended))</span><br><span class="line">        spin_unlock(&amp;q-&gt;busylock);</span><br><span class="line">return rc;</span><br></pre></td></tr></table></figure><h2 id="调优-Transmit-Packet-Steering-XPS">6.5 调优: Transmit Packet Steering (XPS)</h2><p>使用 XPS 需要在内核配置中启用它（Ubuntu 上内核 3.13.0 有 XPS），并提供一个位掩码，用于 描述<strong>CPU 和 TX queue 的对应关系</strong>。</p><p>这些位掩码类似于 <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#receive-packet-steering-rps">RPS</a> 位掩码，你可以在内核<a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/scaling.txt#L147-L150">文档 </a>中找到有关这些位掩码的一些资料。</p><p>简而言之，要修改的位掩码位于以下位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;sys&#x2F;class&#x2F;net&#x2F;DEVICE_NAME&#x2F;queues&#x2F;QUEUE&#x2F;xps_cpus</span><br></pre></td></tr></table></figure><p>因此，对于 eth0 和 TX queue 0，你需要使用十六进制数修改文件： <code>/sys/class/net/eth0/queues/tx-0/xps_cpus</code>，制定哪些 CPU 应处理来自 eth0 的发送队列 0 的发送过程。另外，<a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/scaling.txt#L412-L422">文档 </a>指出，在某些配置中可能不需要 XPS。</p><h1 id="Queuing-Disciplines（排队规则）">7 Queuing Disciplines（排队规则）</h1><p>至此，我们需要先看一些 qdisc 代码。本文不打算涵盖 TX 所有选项的具体细节。 如果对此感兴趣，可以查看<a href="http://lartc.org/howto/index.html">这篇</a>很棒的指南。</p><p>接下来将查看<strong>通用的数据包调度程序</strong>（generic packet scheduler）是如何工作的 。特别地，我们将分析 <code>qdisc_run_begin()</code>、<code>qdisc_run_end()</code>、<code>__ qdisc_run()</code> 和 <code>sch_direct_xmit()</code> 函数是如何一层层将数据传递给驱动程序的。</p><p>从 <code>qdisc_run_begin()</code> 的工作原理开始。</p><h2 id="qdisc-run-begin-and-qdisc-run-end-：仅设置-qdisc-状态位">7.1 qdisc_run_begin() and qdisc_run_end()：仅设置 qdisc 状态位</h2><p>定义在<a href="https://github.com/torvalds/linux/blob/v3.13/include/net/sch_generic.h#L101-L107">include/net/sch_generic.h</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static inline bool qdisc_run_begin(struct Qdisc *qdisc)</span><br><span class="line">&#123;</span><br><span class="line">        if (qdisc_is_running(qdisc))</span><br><span class="line">                return false;</span><br><span class="line">        qdisc-&gt;__state |&#x3D; __QDISC___STATE_RUNNING;</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void qdisc_run_end(struct Qdisc *qdisc)</span><br><span class="line">&#123;</span><br><span class="line">        qdisc-&gt;__state &amp;&#x3D; ~__QDISC___STATE_RUNNING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>qdisc_run_begin()</code> 检查 qdisc 是否设置了<code>__QDISC___STATE_RUNNING</code> 状态 位。如果设置了，直接返回 <code>false</code>；否则，设置此状态位，然后返回 <code>true</code>。</li><li><code>qdisc_run_end()</code> 执行相反的操作，清除此状态位。</li></ul><p>需要注意的是，这两个函数都<strong>只是设置状态位，并没有真正干活</strong>。真正的处理过程是从 <code>__qdisc_run()</code> 开始的。</p><h2 id="qdisc-run-：真正的-qdisc-执行入口">7.2 __qdisc_run()：真正的 qdisc 执行入口</h2><p>这个函数乍看非常简单，甚至让人产生错觉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void __qdisc_run(struct Qdisc *q)</span><br><span class="line">&#123;</span><br><span class="line">        int quota &#x3D; weight_p;</span><br><span class="line"></span><br><span class="line">        while (qdisc_restart(q)) &#123; &#x2F;&#x2F; 从队列取出一个 skb 并发送，剩余队列不为空时返回非零，见 8.3</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 如果发生下面情况之一，则延后处理：</span><br><span class="line">                &#x2F;&#x2F; 1. quota 用尽</span><br><span class="line">                &#x2F;&#x2F; 2. 其他进程需要 CPU</span><br><span class="line">                if (--quota &lt;&#x3D; 0 || need_resched()) &#123;</span><br><span class="line">                        __netif_schedule(q);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        qdisc_run_end(q);          &#x2F;&#x2F; 清除 RUNNING 状态位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首先获取 <code>weight_p</code>，这个变量通常是通过 sysctl 设置的，收包路径也会用到。我们稍 后会看到如何调整此值。这个循环做两件事：</p><ol><li>在 <code>while</code> 循环中调用 <code>qdisc_restart()</code>，直到它返回 <code>false</code>（或触发下面的中断）。</li><li>判断是否还有 quota，或 <code>need_resched()</code> 是否返回 <code>true</code>。其中任何一个为真， 将调用 <code>__netif_schedule()</code> 然后跳出循环。</li></ol><blockquote><p>注意：用户程序调用 <code>sendmsg</code> <strong>系统调用之后，内核便接管了执行过程，一路执行到 这里;用户程序一直在累积系统时间（system time）</strong>。</p></blockquote><ul><li>如果用户程序在内核中用完其 time quota，<code>need_resched()</code> 将返回 <code>true</code>。</li><li>如果仍有 quota，且用户程序的时间片尚未使用，则将再次调用 <code>qdisc_restart()</code>。</li></ul><p>先来看看 <code>qdisc_restart(q)</code>是如何工作的，然后将深入研究<code>__netif_schedule(q)</code>。</p><h2 id="qdisc-restart：从-qdisc-队列中取包，发送给网络驱动">7.3 qdisc_restart：从 qdisc 队列中取包，发送给网络驱动</h2><p><a href="https://github.com/torvalds/linux/blob/v3.13/net/sched/sch_generic.c#L156-L192">qdisc_restart()</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * NOTE: Called under qdisc_lock(q) with locally disabled BH.</span><br><span class="line"> *</span><br><span class="line"> * __QDISC_STATE_RUNNING guarantees only one CPU can process</span><br><span class="line"> * this qdisc at a time. qdisc_lock(q) serializes queue accesses for this queue.</span><br><span class="line"> *</span><br><span class="line"> *  netif_tx_lock serializes accesses to device driver.</span><br><span class="line"> *</span><br><span class="line"> *  qdisc_lock(q) and netif_tx_lock are mutually exclusive,</span><br><span class="line"> *  if one is grabbed, another must be free.</span><br><span class="line"> *</span><br><span class="line"> * Returns to the caller:</span><br><span class="line"> *                                0  - queue is empty or throttled.</span><br><span class="line"> *                                &gt;0 - queue is not empty.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static inline int qdisc_restart(struct Qdisc *q)</span><br><span class="line">&#123;</span><br><span class="line">        struct sk_buff      *skb &#x3D; dequeue_skb(q);</span><br><span class="line">        if (!skb)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        spinlock_t          *root_lock &#x3D; qdisc_lock(q);</span><br><span class="line">        struct net_device   *dev &#x3D; qdisc_dev(q);</span><br><span class="line">        struct netdev_queue *txq &#x3D; netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));</span><br><span class="line"></span><br><span class="line">        return sch_direct_xmit(skb, q, dev, txq, root_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>qdisc_restart()</code> 函数开头的注释非常有用，描述了用到的三个锁：</p><ol><li><code>__QDISC_STATE_RUNNING</code> 保证了同一时间只有一个 CPU 可以处理这个 qdisc。</li><li><code>qdisc_lock(q)</code> 将<strong>访问此 qdisc</strong> 的操作顺序化。</li><li><code>netif_tx_lock</code> 将<strong>访问设备驱动</strong>的操作顺序化。</li></ol><p>函数逻辑：</p><ol><li>首先调用 <code>dequeue_skb()</code> 从 qdisc 中取出要发送的 skb。如果队列为空，返回 0， 这将导致上层的 <code>qdisc_restart()</code> 返回 <code>false</code>，继而退出 <code>while</code> 循环。</li><li>如果 skb 不为空，接下来获取 qdisc 队列锁，然后找到相关的发送设备 <code>dev</code> 和发送 队列 <code>txq</code>，最后带着这些参数调用 <code>sch_direct_xmit()</code>。</li></ol><p>先来看 <code>dequeue_skb()</code>，然后再回到 <code>sch_direct_xmit()</code>。</p><h3 id="dequeue-skb-：从-qdisc-队列取待发送-skb">7.3.1 dequeue_skb()：从 qdisc 队列取待发送 skb</h3><p>定义在 <a href="https://github.com/torvalds/linux/blob/v3.13/net/sched/sch_generic.c#L59-L78">net/sched/sch_generic.c</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static inline struct sk_buff *dequeue_skb(struct Qdisc *q)</span><br><span class="line">&#123;</span><br><span class="line">    struct sk_buff      *skb &#x3D; q-&gt;gso_skb;   &#x2F;&#x2F; 待发送包</span><br><span class="line">    struct netdev_queue *txq &#x3D; q-&gt;dev_queue; &#x2F;&#x2F; 之前发送失败的包所在的队列</span><br><span class="line"></span><br><span class="line">    if (unlikely(skb)) &#123;</span><br><span class="line">        &#x2F;* check the reason of requeuing without tx lock first *&#x2F;</span><br><span class="line">        txq &#x3D; netdev_get_tx_queue(txq-&gt;dev, skb_get_queue_mapping(skb));</span><br><span class="line"></span><br><span class="line">        if (!netif_xmit_frozen_or_stopped(txq)) &#123;</span><br><span class="line">            q-&gt;gso_skb &#x3D; NULL;</span><br><span class="line">            q-&gt;q.qlen--;</span><br><span class="line">        &#125; else</span><br><span class="line">            skb &#x3D; NULL;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!(q-&gt;flags &amp; TCQ_F_ONETXQUEUE) || !netif_xmit_frozen_or_stopped(txq))</span><br><span class="line">            skb &#x3D; q-&gt;dequeue(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return skb;</span><br></pre></td></tr></table></figure><p>函数首先声明一个 <code>struct sk_buff *skb</code> 变量，这是接下来要处理的数据。这个变量后 面会依不同情况而被赋不同的值，最后作为返回值返回给调用方。</p><p>变量 <code>skb</code> 初始化为 qdisc 的 <code>gso_skb</code> 字段，这是<strong>之前由于发送失败而重新入队的数据</strong>。</p><p>接下来分为两种情况，根据 <code>skb = q-&gt;gso_skb</code> 是否为空：</p><ol><li><p>如果不为空，会将之前重新入队的 skb 出队，作为待处理数据返回。</p><ol><li>检查发送队列是否已停止。</li><li>如果队列未停止，则 <code>gso_skb</code> 字段置空，队列长度减 1，返回 skb。</li><li>如果队列已停止，则 <code>gso_skb</code> 不动，返回空。</li></ol></li><li><p>如果为空（即之前没有数据重新入队），则从要处理的 qdisc 中取出一个新 skb，作为待处理数据返回。</p><p> 进入另一个 tricky 的 if 语句，如果：</p><ol><li>qdisc 不是单发送队列，或</li><li>发送队列未停止工作</li></ol><p> 则调用 qdisc 的 <code>dequeue()</code> 方法获取新数据并返回。dequeue 的内部实现依 qdisc 的实现和功能而有所不同。</p></li></ol><p>该函数最后返回变量 <code>skb</code>，这是接下来要处理的数据包。</p><h3 id="sch-direct-xmit-：发送给网卡驱动">7.3.2 sch_direct_xmit()：发送给网卡驱动</h3><p>现在来到 <code>sch_direct_xmit()</code>（定义在 <a href="https://github.com/torvalds/linux/blob/v3.13/net/sched/sch_generic.c#L109-L154">net/sched/sch_generic.c</a> ），这是将数据向下发送到网络设备的重要一步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Transmit one skb, and handle the return status as required. Holding the</span><br><span class="line"> * __QDISC_STATE_RUNNING bit guarantees that only one CPU can execute this</span><br><span class="line"> * function.</span><br><span class="line"> *</span><br><span class="line"> * Returns to the caller:</span><br><span class="line"> *                                0  - queue is empty or throttled.</span><br><span class="line"> *                                &gt;0 - queue is not empty.</span><br><span class="line"> *&#x2F;</span><br><span class="line">int sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q,</span><br><span class="line">                    struct net_device *dev, struct netdev_queue *txq,</span><br><span class="line">                    spinlock_t *root_lock)</span><br><span class="line">&#123;</span><br><span class="line">        int ret &#x3D; NETDEV_TX_BUSY;</span><br><span class="line"></span><br><span class="line">        spin_unlock(root_lock);</span><br><span class="line">        if (!netif_xmit_frozen_or_stopped(txq))</span><br><span class="line">            ret &#x3D; dev_hard_start_xmit(skb, dev, txq);</span><br><span class="line">        spin_lock(root_lock);</span><br><span class="line"></span><br><span class="line">        if (dev_xmit_complete(ret)) &#123;                    &#x2F;&#x2F; 1. 驱动发送成功</span><br><span class="line">            ret &#x3D; qdisc_qlen(q);                         &#x2F;&#x2F;    将 qdisc 队列的剩余长度作为返回值</span><br><span class="line">        &#125; else if (ret &#x3D;&#x3D; NETDEV_TX_LOCKED) &#123;            &#x2F;&#x2F; 2. 驱动获取发送锁失败</span><br><span class="line">            ret &#x3D; handle_dev_cpu_collision(skb, txq, q);</span><br><span class="line">        &#125; else &#123;                                         &#x2F;&#x2F; 3. 驱动发送“正忙”，当前无法发送</span><br><span class="line">            ret &#x3D; dev_requeue_skb(skb, q);               &#x2F;&#x2F;    将数据重新入队，等下次发送。</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ret &amp;&amp; netif_xmit_frozen_or_stopped(txq))</span><br><span class="line">            ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br></pre></td></tr></table></figure><p>这段代码首先释放 qdisc（发送队列）锁，然后获取（设备驱动的）发送锁。</p><p>接下来，如果发送队列没有停止，就会调用 <code>dev_hard_start_xmit()</code>。稍后将看到， 后者会把数据从 Linux 内核的网络设备子系统发送到设备驱动程序。</p><p><code>dev_hard_start_xmit()</code> 执行之后，（或因发送队列停止而跳过执行），队列的发送锁就会被释放。</p><p>接下来，再次获取此 qdisc 的锁，然后通过调用 <code>dev_xmit_complete()</code> 检查 <code>dev_hard_start_xmit()</code> 的返回值。</p><ol><li><p>如果 <code>dev_xmit_complete()</code> 返回 <code>true</code>，数据已成功发送，则将 qdisc 队列长度设置为返回值，否则</p></li><li><p>如果 <code>dev_hard_start_xmit()</code> 返回的是 <code>NETDEV_TX_LOCKED</code>，调用 <code>handle_dev_cpu_collision()</code> 来处理锁竞争。</p><p> 当驱动程序锁定发送队列失败时，支持 <code>NETIF_F_LLTX</code> 功能的设备会返回 <code>NETDEV_TX_LOCKED</code>。 稍后会仔细研究 <code>handle_dev_cpu_collision</code>。</p></li></ol><p>现在，让我们继续关注 <code>sch_direct_xmit()</code> 并查看，以上两种情况都不满足时的情况。 如果发送失败，而且不是以上两种情况，那还有第三种可能：由于 <code>NETDEV_TX_BUSY</code>。驱动 程序返回 <code>NETDEV_TX_BUSY</code> 表示设备或驱动程序“正忙”，数据现在无法发送。这种情 况下，调用 <code>dev_requeue_skb()</code> 将数据重新入队，等下次发送。</p><p>来深入地看一下 <code>handle_dev_cpu_collision()</code> 和 <code>dev_requeue_skb()</code>。</p><h3 id="handle-dev-cpu-collision">7.3.3 handle_dev_cpu_collision()</h3><p>定义在 <a href="https://github.com/torvalds/linux/blob/v3.13/net/sched/sch_generic.c#L80-L107">net/sched/sch_generic.c</a>，处理两种情况：</p><ol><li>发送锁由当前 CPU 保持</li><li>发送锁由其他 CPU 保存</li></ol><p>第一种情况认为是配置问题，打印一条警告。</p><p>第二种情况，更新统计计数器 <code>cpu_collision</code>，通过 <code>dev_requeue_skb</code> 将数据重新入队 以便稍后发送。回想一下，我们在 <code>dequeue_skb</code> 中看到了专门处理重新入队的 skb 的代码。</p><p>代码很简短，可以快速阅读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static inline int handle_dev_cpu_collision(struct sk_buff *skb,</span><br><span class="line">                                           struct netdev_queue *dev_queue,</span><br><span class="line">                                           struct Qdisc *q)</span><br><span class="line">&#123;</span><br><span class="line">        int ret;</span><br><span class="line"></span><br><span class="line">        if (unlikely(dev_queue-&gt;xmit_lock_owner &#x3D;&#x3D; smp_processor_id())) &#123;</span><br><span class="line">                &#x2F;*</span><br><span class="line">                 * Same CPU holding the lock. It may be a transient</span><br><span class="line">                 * configuration error, when hard_start_xmit() recurses. We</span><br><span class="line">                 * detect it by checking xmit owner and drop the packet when</span><br><span class="line">                 * deadloop is detected. Return OK to try the next skb.</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                kfree_skb(skb);</span><br><span class="line">                net_warn_ratelimited(&quot;Dead loop on netdevice %s, fix it urgently!\n&quot;,</span><br><span class="line">                                     dev_queue-&gt;dev-&gt;name);</span><br><span class="line">                ret &#x3D; qdisc_qlen(q);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">                &#x2F;*</span><br><span class="line">                 * Another cpu is holding lock, requeue &amp; delay xmits for</span><br><span class="line">                 * some time.</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                __this_cpu_inc(softnet_data.cpu_collision);</span><br><span class="line">                ret &#x3D; dev_requeue_skb(skb, q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看 <code>dev_requeue_skb</code> 做了什么，后面会看到，<code>sch_direct_xmit</code> 会调用它.</p><h3 id="dev-requeue-skb-：重新压入-qdisc-队列，等待下次发送">7.3.4 dev_requeue_skb()：重新压入 qdisc 队列，等待下次发送</h3><p>这个函数很简短，<a href="https://github.com/torvalds/linux/blob/v3.13/net/sched/sch_generic.c#L39-L57">net/sched/sch_generic.c</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Modifications to data participating in scheduling must be protected with</span><br><span class="line"> * qdisc_lock(qdisc) spinlock.</span><br><span class="line"> *</span><br><span class="line"> * The idea is the following:</span><br><span class="line"> * - enqueue, dequeue are serialized via qdisc root lock</span><br><span class="line"> * - ingress filtering is also serialized via qdisc root lock</span><br><span class="line"> * - updates to tree and tree walking are only done under the rtnl mutex.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static inline int dev_requeue_skb(struct sk_buff *skb, struct Qdisc *q)</span><br><span class="line">&#123;</span><br><span class="line">        skb_dst_force(skb);   &#x2F;&#x2F; skb 上强制增加一次引用计数</span><br><span class="line">        q-&gt;gso_skb &#x3D; skb;     &#x2F;&#x2F; 回想一下，dequeue_skb() 中取出一个 skb 时会检查该字段</span><br><span class="line">        q-&gt;qstats.requeues++; &#x2F;&#x2F; 更新 &#96;requeue&#96; 计数</span><br><span class="line">        q-&gt;q.qlen++;          &#x2F;&#x2F; 更新 qdisc 队列长度</span><br><span class="line"></span><br><span class="line">        __netif_schedule(q);  &#x2F;&#x2F; 触发 softirq</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来再回忆一遍我们一步步到达这里的过程，然后查看 <code>__netif_schedule()</code>。</p><h2 id="复习：-qdisc-run-主逻辑">7.4 复习：__qdisc_run()主逻辑</h2><p>回想一下，我们是从 <code>__qdisc_run()</code> 开始到达这里的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void __qdisc_run(struct Qdisc *q)</span><br><span class="line">&#123;</span><br><span class="line">        int quota &#x3D; weight_p;</span><br><span class="line">        while (qdisc_restart(q)) &#123; &#x2F;&#x2F; dequeue skb, send it</span><br><span class="line">            if (--quota &lt;&#x3D; 0 || need_resched()) &#123;&#x2F;&#x2F; Ordered by possible occurrence: Postpone processing if</span><br><span class="line">                    __netif_schedule(q);         &#x2F;&#x2F; 1. we&#39;ve exceeded packet quota</span><br><span class="line">                    break;                       &#x2F;&#x2F; 2. another process needs the CPU</span><br><span class="line">            &#125;                                    </span><br><span class="line">        &#125;</span><br><span class="line">        qdisc_run_end(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>while</code> 循环调用 <code>qdisc_restart()</code>，后者取出一个 skb，然后尝试通过 <code>sch_direct_xmit()</code> 来发送；<code>sch_direct_xmit</code> 调用 <code>dev_hard_start_xmit</code> 来向驱动 程序进行实际发送。任何无法发送的 skb 都重新入队，将在 <code>NET_TX</code> softirq 中进行 发送。</p><p>发送过程的下一步是查看 <code>dev_hard_start_xmit()</code>，了解如何调用驱动程序来发送数据。但 在此之前，应该先查看 <code>__netif_schedule()</code> 以完全理解 <code>__qdisc_run()</code> 和 <code>dev_requeue_skb()</code> 的工作方式。</p><h3 id="netif-schedule">7.4.1 __netif_schedule</h3><p>现在来看 <code>__netif_schedule()</code>， <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L2127-L2146">net/core/dev.c</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void __netif_schedule(struct Qdisc *q)</span><br><span class="line">&#123;</span><br><span class="line">    if (!test_and_set_bit(__QDISC_STATE_SCHED, &amp;q-&gt;state))</span><br><span class="line">            __netif_reschedule(q);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__netif_schedule);</span><br><span class="line"></span><br><span class="line">static inline void __netif_reschedule(struct Qdisc *q)</span><br><span class="line">&#123;</span><br><span class="line">    struct softnet_data *sd;</span><br><span class="line">    unsigned long flags;</span><br><span class="line"></span><br><span class="line">    local_irq_save(flags);                  &#x2F;&#x2F; 保存硬中断状态，并禁用硬中断（IRQ）</span><br><span class="line">    sd &#x3D; &amp;__get_cpu_var(softnet_data);      &#x2F;&#x2F; 获取当前 CPU 的 struct softnet_data 实例</span><br><span class="line">    q-&gt;next_sched &#x3D; NULL;</span><br><span class="line">    *sd-&gt;output_queue_tailp &#x3D; q;            &#x2F;&#x2F; 将 qdisc 添加到 softnet_data 的 output 队列中</span><br><span class="line">    sd-&gt;output_queue_tailp &#x3D; &amp;q-&gt;next_sched;</span><br><span class="line">    raise_softirq_irqoff(NET_TX_SOFTIRQ);   &#x2F;&#x2F; 重要步骤：触发 NET_TX_SOFTIRQ 类型软中断（softirq）</span><br><span class="line">    local_irq_restore(flags);               &#x2F;&#x2F; 恢复 IRQ 状态并重新启用硬中断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>test_and_set_bit()</code> 检查 <code>q-&gt;state</code> 中的 <code>__QDISC_STATE_SCHED</code> 位，如果为该位为 0，会将其置 1。 如果置位成功（意味着之前处于非 <code>__QDISC_STATE_SCHED</code> 状态），代码将调用 <code>__netif_reschedule()</code>，这个函数不长，但做的事情非常重要。</p><blockquote><p>更多有关 <code>struct softnet_data</code> 初始化的内容，可参考我们之前关于网络栈接收数据的 <a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#linux-network-device-subsystem">文章</a>。</p></blockquote><p><code>__netif_reschedule()</code> 中的重要步骤是 <code>raise_softirq_irqoff()</code>，它触发一次 <code>NET_TX_SOFTIRQ</code> 类型 softirq。 softirqs 及其注册过程也包含在我们之前的<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#softirqs">文章 </a>中。简单来说，可以认为 <strong>softirqs 是以很高优先级在执行的内核线程，并代表内核处理数据</strong>， 用于网络数据的收发处理（incoming 和 outgoing）。</p><p>正如在<a href="http://arthurchiao.art/blog/tuning-stack-tx-zh/">上一篇</a>文章中看到的，<code>NET_TX_SOFTIRQ</code> softirq 有一个注册的回调函数 <code>net_tx_action()</code>，这意味着有一个内核线程将会执行 <code>net_tx_action()</code>。该线程偶尔会被暂 停（pause），<code>raise_softirq_irqoff()</code> 会恢复（resume）其执行。让我们看一下 <code>net_tx_action()</code> 的作用，以便了解内核如何处理发送数据请求。</p><h3 id="net-tx-action">7.4.2 net_tx_action()</h3><p>定义在 <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L3297-L3353">net/core/dev.c</a> ，由两个 if 组成，分别处理 executing CPU 的 <strong><code>softnet_data</code> 实例的两个 queue</strong>：</p><ol><li>completion queue</li><li>output queue</li></ol><p>让我们分别来看这两种情况，注意，<strong>这段代码在 softirq 上下文中作为一个独立的内核线 程执行</strong>。网络栈发送侧的<strong>热路径中不适合执行的代码，将被延后（defer），然 后由执行 <code>net_tx_action()</code> 的线程处理</strong>。</p><h3 id="net-tx-action-completion-queue：待释放-skb-队列">7.4.3 net_tx_action() completion queue：待释放 skb 队列</h3><p><code>softnet_data</code> 的 completion queue 存放<strong>等待释放的 skb</strong>。函数 <code>dev_kfree_skb_irq</code> 可以将 skbs 添加到队列中以便稍后释放。设备驱动程序通常使用它来推迟释放已经发送成功的 skbs。驱动 程序推迟释放 skb 的原因是，释放内存可能需要时间，而且有些代码（如 hardirq 处理程序） 需要尽可能快的执行并返回。</p><p>看一下 <code>net_tx_action</code> 第一段代码，该代码处理 completion queue 中等待释放的 skb：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (sd-&gt;completion_queue) &#123;</span><br><span class="line">        struct sk_buff *clist;</span><br><span class="line"></span><br><span class="line">        local_irq_disable();</span><br><span class="line">        clist &#x3D; sd-&gt;completion_queue;</span><br><span class="line">        sd-&gt;completion_queue &#x3D; NULL;</span><br><span class="line">        local_irq_enable();</span><br><span class="line"></span><br><span class="line">        while (clist) &#123;</span><br><span class="line">                struct sk_buff *skb &#x3D; clist;</span><br><span class="line">                clist &#x3D; clist-&gt;next;</span><br><span class="line">                __kfree_skb(skb);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 completion queue 非空，<code>while</code> 循环将遍历这个列表并<code>__kfree_skb</code> 释放每个 skb 占 用的内存。<strong>牢记，此代码在一个名为 softirq 的独立“线程”中运行 - 它并没有占用用 户程序的系统时间（system time）</strong>。</p><h3 id="net-tx-action-output-queue：待发送-skb-队列">7.4.4 net_tx_action output queue：待发送 skb 队列</h3><p>output queue 存储 <strong>待发送的 skb</strong>。如前所述，<code>__netif_reschedule()</code> 将数据添加到 output queue 中，通常从<code>__netif_schedule</code> 调用过来。</p><p>目前，我们看到 <code>__netif_schedule()</code> 函数在两个地方被调用：</p><ol><li><code>dev_requeue_skb()</code>：如果驱动程序返回 <code>NETDEV_TX_BUSY</code> 或者存在 CPU 冲突，可以调用此函数。</li><li><code>__qdisc_run()</code>：一旦超出 quota 或者需要 reschedule，会调用<code>__netif_schedule</code>。</li></ol><p>这个函数会将 qdisc 添加到 softnet_data 的 output queue 进行处理。 这里将输出队列处理代码拆分为三个块。</p><p>我们来看看第一块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (sd-&gt;output_queue) &#123;       &#x2F;&#x2F; 如果 output queue 上有 qdisc</span><br><span class="line">    struct Qdisc *head;</span><br><span class="line"></span><br><span class="line">    local_irq_disable();</span><br><span class="line">    head &#x3D; sd-&gt;output_queue;  &#x2F;&#x2F; 将 head 指向第一个 qdisc</span><br><span class="line">    sd-&gt;output_queue &#x3D; NULL;</span><br><span class="line">    sd-&gt;output_queue_tailp &#x3D; &amp;sd-&gt;output_queue; &#x2F;&#x2F; 更新队尾指针</span><br><span class="line">    local_irq_enable();</span><br></pre></td></tr></table></figure><p>如果 output queue 上有 qdisc，则将 <code>head</code> 变量指向第一个 qdisc，并 更新队尾指针。</p><p>接下来，一个 <strong><code>while</code> 循环开始遍历 qdsics 列表</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">while (head) &#123;</span><br><span class="line">    struct Qdisc *q &#x3D; head;</span><br><span class="line">    head &#x3D; head-&gt;next_sched;</span><br><span class="line"></span><br><span class="line">    spinlock_t *root_lock &#x3D; qdisc_lock(q);</span><br><span class="line"></span><br><span class="line">    if (spin_trylock(root_lock)) &#123;                 &#x2F;&#x2F; 非阻塞：尝试获取 qdisc root lock</span><br><span class="line">        smp_mb__before_clear_bit();</span><br><span class="line">        clear_bit(__QDISC_STATE_SCHED, &amp;q-&gt;state); &#x2F;&#x2F; 清除 q-&gt;state SCHED 状态位</span><br><span class="line"></span><br><span class="line">        qdisc_run(q);                              &#x2F;&#x2F; 执行 qdisc 规则，这会设置 q-&gt;state 的 RUNNING 状态位</span><br><span class="line"></span><br><span class="line">        spin_unlock(root_lock);                    &#x2F;&#x2F; 释放 qdisc 锁</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!test_bit(__QDISC_STATE_DEACTIVATED, &amp;q-&gt;state)) &#123; &#x2F;&#x2F; qdisc 还在运行</span><br><span class="line">            __netif_reschedule(q);                 &#x2F;&#x2F; 重新放入 queue，稍后继续尝试获取 root lock</span><br><span class="line">        &#125; else &#123;                                   &#x2F;&#x2F; qdisc 已停止运行，清除 SCHED 状态位</span><br><span class="line">            smp_mb__before_clear_bit();</span><br><span class="line">            clear_bit(__QDISC_STATE_SCHED, &amp;q-&gt;state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>spin_trylock()</code> 获得 root lock 后，</p><ol><li>调用 <code>clear_bit()</code> 清除 qdisc 的 <code>__QDISC_STATE_SCHED</code> 状态位。</li><li>然后执行 <code>qdisc_run()</code>，这会将 <code>__QDISC___STATE_RUNNING</code> 状态位置 1，并执行<code>__qdisc_run()</code>。</li></ol><p>这里很重要。从系统调用开始的发送过程代表 applition 执行，花费的是系统时间；但接 下来它将转入 softirq 上下文中执行（这个 qdisc 的 skb 之前没有被发送出去发），花 费的是 softirq 时间。这种区分非常重要，因为这<strong>直接影响着应用程序的 CPU 使用量监 控</strong>，尤其是发送大量数据的应用。换一种陈述方式：</p><ol><li>无论发送完成还是驱动程序返回错误，程序的系统时间都包括调用驱动程序发送数据所花的时间。</li><li>如果驱动层发送失败（例如，设备忙于发送其他内容），则会将 qdisc 添加到 output queue，稍后由 softirq 线程处理。在这种情况下，将会额外花费一些 softirq（ <code>si</code>）时间在发送数据上。</li></ol><p>因此，发送数据花费的总时间是下面二者之和：</p><ol><li><strong>系统调用的系统时间</strong>（sys time）</li><li><strong><code>NET_TX</code> 类型的 softirq 时间</strong>（softirq time）</li></ol><p>如果 <code>spin_trylock()</code> 失败，则检查 qdisc 是否已经停止运行（<code>__QDISC_STATE_DEACTIVATED</code> 状态位），两种情况：</p><ol><li>qdisc 未停用：调用 <code>__netif_reschedule()</code>，这会将 qdisc 放回到原 queue 中，稍后再次尝试获取 qdisc 锁。</li><li>qdisc 已停用：清除 <code>__QDISC_STATE_SCHED</code> 状态位。</li></ol><h2 id="最终来到dev-hard-start-xmit">7.5 最终来到dev_hard_start_xmit</h2><p>至此，我们已经穿过了整个网络栈，最终来到 <code>dev_hard_start_xmit</code>。也许你是从 <code>sendmsg</code> 系统调用直接到达这里的，或者你是通过 qdisc 上的 softirq 线程处理网络数据来 到这里的。<code>dev_hard_start_xmit</code> 将调用设备驱动程序来实际执行发送操作。</p><p>这个函数处理两种主要情况：</p><ol><li>已经准备好要发送的数据，或</li><li>需要 segmentation offloading 的数据</li></ol><p>先看第一种情况，要发送的数据已经准备好的情况。 <a href="https://github.com/torvalds/linux/blob/v3.13/net/core/dev.c#L2541-L2652">net/code/dev.c</a> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev,</span><br><span class="line">                        struct netdev_queue *txq)</span><br><span class="line">&#123;</span><br><span class="line">        const struct net_device_ops *ops &#x3D; dev-&gt;netdev_ops;</span><br><span class="line">        int rc &#x3D; NETDEV_TX_OK;</span><br><span class="line">        unsigned int skb_len;</span><br><span class="line"></span><br><span class="line">        if (likely(!skb-&gt;next)) &#123;</span><br><span class="line">                netdev_features_t features;</span><br><span class="line"></span><br><span class="line">                &#x2F;*</span><br><span class="line">                 * If device doesn&#39;t need skb-&gt;dst, release it right now while</span><br><span class="line">                 * its hot in this cpu cache</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                if (dev-&gt;priv_flags &amp; IFF_XMIT_DST_RELEASE)</span><br><span class="line">                        skb_dst_drop(skb);</span><br><span class="line"></span><br><span class="line">                features &#x3D; netif_skb_features(skb);</span><br></pre></td></tr></table></figure><p>代码首先获取设备的回调函数集合 <code>ops</code>，后面让驱动程序做一些发送数据的工作时会用到 。检查 <code>skb-&gt;next</code> 以确定此数据不是已分片数据的一部分，然后继续执行以下两项操作：</p><p>首先，检查设备是否设置了 <code>IFF_XMIT_DST_RELEASE</code> 标志。这个版本的内核中的任何“真实” 以太网设备都不使用此标志，但环回设备和其他一些软件设备使用。如果启用此特性，则可 以减少目标高速缓存条目上的引用计数，因为驱动程序不需要它。</p><p>接下来，<code>netif_skb_features</code> 获取设备支持的功能列表，并根据数据的协议类型（ <code>dev-&gt;protocol</code>）对特性列表进行一些修改。例如，如果设备支持此协议的校验和计算， 则将对 skb 进行相应的标记。 VLAN tag（如果已设置）也会导致功能标记被修改。</p><p>接下来，将检查 vlan 标记，如果设备无法 offload VLAN tag，将通过<code>__vlan_put_tag</code> 在软 件中执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (vlan_tx_tag_present(skb) &amp;&amp;</span><br><span class="line">    !vlan_hw_offload_capable(features, skb-&gt;vlan_proto)) &#123;</span><br><span class="line">        skb &#x3D; __vlan_put_tag(skb, skb-&gt;vlan_proto,</span><br><span class="line">                             vlan_tx_tag_get(skb));</span><br><span class="line">        if (unlikely(!skb))</span><br><span class="line">                goto out;</span><br><span class="line"></span><br><span class="line">        skb-&gt;vlan_tci &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，检查数据以确定这是不是 encapsulation （隧道封装）offload 请求，例如， <a href="https://en.wikipedia.org/wiki/Generic_Routing_Encapsulation">GRE</a>。 在这种情况 下，feature flags 将被更新，以添加任何特定于设备的硬件封装功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* If encapsulation offload request, verify we are testing</span><br><span class="line"> * hardware encapsulation features instead of standard</span><br><span class="line"> * features for the netdev</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (skb-&gt;encapsulation)</span><br><span class="line">        features &amp;&#x3D; dev-&gt;hw_enc_features;</span><br></pre></td></tr></table></figure><p>接下来，<code>netif_needs_gso</code> 用于确定 skb 是否需要分片。 如果需要，但设备不支持，则 <code>netif_needs_gso</code> 将返回 <code>true</code>，表示分片应在软件中进行。 在这种情况下，调用 <code>dev_gso_segment</code> 进行分片，代码将跳转到 gso 以发送数据包。我们稍后会看到 GSO 路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (netif_needs_gso(skb, features)) &#123;</span><br><span class="line">        if (unlikely(dev_gso_segment(skb, features)))</span><br><span class="line">                goto out_kfree_skb;</span><br><span class="line">        if (skb-&gt;next)</span><br><span class="line">                goto gso;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果数据不需要分片，则处理一些其他情况。 首先，数据是否需要顺序化？ 也就是说，如 果数据分布在多个缓冲区中，设备是否支持发送网络数据，还是首先需要将它们组合成单个 有序缓冲区？ 绝大多数网卡不需要在发送之前将数据顺序化，因此在几乎所有情况下， <code>skb_needs_linearize</code> 将为 <code>false</code> 然后被跳过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">            else &#123;</span><br><span class="line">if (skb_needs_linearize(skb, features) &amp;&amp;</span><br><span class="line">    __skb_linearize(skb))</span><br><span class="line">        goto out_kfree_skb;</span><br></pre></td></tr></table></figure><p>从接下来的一段注释我们可以了解到，下面的代码判断数据包是否仍然需要计算校验和。 如果设备不支持计算校验和，则在这里通过软件计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        &#x2F;* If packet is not checksummed and device does not</span><br><span class="line">         * support checksumming for this protocol, complete</span><br><span class="line">         * checksumming here.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (skb-&gt;ip_summed &#x3D;&#x3D; CHECKSUM_PARTIAL) &#123;</span><br><span class="line">                if (skb-&gt;encapsulation)</span><br><span class="line">                        skb_set_inner_transport_header(skb,</span><br><span class="line">                                skb_checksum_start_offset(skb));</span><br><span class="line">                else</span><br><span class="line">                        skb_set_transport_header(skb,</span><br><span class="line">                                skb_checksum_start_offset(skb));</span><br><span class="line">                if (!(features &amp; NETIF_F_ALL_CSUM) &amp;&amp;</span><br><span class="line">                     skb_checksum_help(skb))</span><br><span class="line">                        goto out_kfree_skb;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往前，我们来到了 packet taps（tap 是包过滤器的安插点，例如抓包执行的地方）。回想 一下在<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#netifreceiveskbcore-special-box-delivers-data-to-packet-taps-and-protocol-layers">接收数据的文章 </a>中，我们看到了数据包是如何传递给 tap（如 <a href="http://www.tcpdump.org/manpages/pcap.3pcap.html">PCAP</a>）的。 该函数中的下一个代 码块将要发送的数据包传递给 tap（如果有的话）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!list_empty(&amp;ptype_all))</span><br><span class="line">        dev_queue_xmit_nit(skb, dev);</span><br></pre></td></tr></table></figure><p>最终，调用驱动的 <code>ops</code> 里面的发送回调函数 <code>ndo_start_xmit</code> 将数据包传给网卡设备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        skb_len &#x3D; skb-&gt;len;</span><br><span class="line">        rc &#x3D; ops-&gt;ndo_start_xmit(skb, dev);</span><br><span class="line"></span><br><span class="line">        trace_net_dev_xmit(skb, rc, dev, skb_len);</span><br><span class="line">        if (rc &#x3D;&#x3D; NETDEV_TX_OK)</span><br><span class="line">                txq_trans_update(txq);</span><br><span class="line">        return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ndo_start_xmit</code> 的返回值表示发送成功与否，并作为这个函数的返回值被返回给更上层。 我们看到了这个返回值将如何影响上层：数据可能会被此时的 qdisc 重新入队，因此 稍后尝试再次发送。</p><p>我们来看看 GSO 的 case。如果此函数的前面部分完成了分片，或者之前已经完成了分片但是 上次发送失败，则会进入下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">gso:</span><br><span class="line">        do &#123;</span><br><span class="line">                struct sk_buff *nskb &#x3D; skb-&gt;next;</span><br><span class="line"></span><br><span class="line">                skb-&gt;next &#x3D; nskb-&gt;next;</span><br><span class="line">                nskb-&gt;next &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">                if (!list_empty(&amp;ptype_all))</span><br><span class="line">                        dev_queue_xmit_nit(nskb, dev);</span><br><span class="line"></span><br><span class="line">                skb_len &#x3D; nskb-&gt;len;</span><br><span class="line">                rc &#x3D; ops-&gt;ndo_start_xmit(nskb, dev);</span><br><span class="line">                trace_net_dev_xmit(nskb, rc, dev, skb_len);</span><br><span class="line">                if (unlikely(rc !&#x3D; NETDEV_TX_OK)) &#123;</span><br><span class="line">                        if (rc &amp; ~NETDEV_TX_MASK)</span><br><span class="line">                                goto out_kfree_gso_skb;</span><br><span class="line">                        nskb-&gt;next &#x3D; skb-&gt;next;</span><br><span class="line">                        skb-&gt;next &#x3D; nskb;</span><br><span class="line">                        return rc;</span><br><span class="line">                &#125;</span><br><span class="line">                txq_trans_update(txq);</span><br><span class="line">                if (unlikely(netif_xmit_stopped(txq) &amp;&amp; skb-&gt;next))</span><br><span class="line">                        return NETDEV_TX_BUSY;</span><br><span class="line">        &#125; while (skb-&gt;next);</span><br></pre></td></tr></table></figure><p>你可能已经猜到，此 <code>while</code> 循环会遍历分片生成的 skb 列表。</p><p>每个数据包将被：</p><ul><li>传给包过滤器（tap，如果有的话）</li><li>通过 <code>ndo_start_xmit</code> 传递给驱动程序进行发送</li></ul><p>设备驱动 <code>ndo_start_xmit()</code>返回错误时，会进行一些错误处理，并将错误返回给更上层。 未发送的 skbs 可能会被重新入队以便稍后再次发送。</p><p>该函数的最后一部分做一些清理工作，在上面发生错误时释放一些资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">out_kfree_gso_skb:</span><br><span class="line">        if (likely(skb-&gt;next &#x3D;&#x3D; NULL)) &#123;</span><br><span class="line">                skb-&gt;destructor &#x3D; DEV_GSO_CB(skb)-&gt;destructor;</span><br><span class="line">                consume_skb(skb);</span><br><span class="line">                return rc;</span><br><span class="line">        &#125;</span><br><span class="line">out_kfree_skb:</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">out:</span><br><span class="line">        return rc;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(dev_hard_start_xmit);</span><br></pre></td></tr></table></figure><p>在继续进入到设备驱动程序之前，先来看一些和前面分析过的代码有关的监控和调优的内容。</p><h2 id="Monitoring-qdiscs">7.6 Monitoring qdiscs</h2><h3 id="Using-the-tc-command-line-tool">7.6.1 Using the tc command line tool</h3><p>使用 <code>tc</code> 工具监控 qdisc 统计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tc -s qdisc show dev eth1</span><br><span class="line">qdisc mq 0: root</span><br><span class="line"> Sent 31973946891907 bytes 2298757402 pkt (dropped 0, overlimits 0 requeues 1776429)</span><br><span class="line"> backlog 0b 0p requeues 1776429</span><br></pre></td></tr></table></figure><p>网络设备的 qdisc 统计对于监控系统发送数据包的运行状况至关重要。你可以通过运行命令 行工具 tc 来查看状态。 上面的示例显示了如何检查 eth1 的统计信息。</p><ul><li><code>bytes</code>: The number of bytes that were pushed down to the driver for transmit.</li><li><code>pkt</code>: The number of packets that were pushed down to the driver for transmit.</li><li><code>dropped</code>: The number of packets that were dropped by the qdisc. This can happen if transmit queue length is not large enough to fit the data being queued to it.</li><li><code>overlimits</code>: Depends on the queuing discipline, but can be either the number of packets that could not be enqueued due to a limit being hit, and/or the number of packets which triggered a throttling event when dequeued.</li><li><code>requeues</code>: Number of times dev_requeue_skb has been called to requeue an skb. Note that an skb which is requeued multiple times will bump this counter each time it is requeued.</li><li><code>backlog</code>: Number of bytes currently on the qdisc’s queue. This number is usually bumped each time a packet is enqueued.</li></ul><p>一些 qdisc 还会导出额外的统计信息。每个 qdisc 都不同，对同一个 counter 可能会累积不同 的次数。你需要查看相应 qdisc 的源代码，弄清楚每个 counter 是在哪里、什么条件下被更新 的，如果这些数据对你非常重要，那你必须这么谨慎。</p><h2 id="Tuning-qdiscs">7.7 Tuning qdiscs</h2><h3 id="调整-qdisc-run-处理权重">7.7.1 调整__qdisc_run 处理权重</h3><p>你可以调整前面看到的<code>__qdisc_run</code> 循环的权重（上面看到的 <code>quota</code> 变量），这将导致 <code>__netif_schedule</code> 更多的被调用执行。 结果将是当前 qdisc 将被更多的添加到当前 CPU 的 output_queue，最终会使发包所占的时间变多。</p><p>例如：调整所有 qdisc 的<code>__qdisc_run</code> 权重：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysctl -w net.core.dev_weight&#x3D;600</span><br></pre></td></tr></table></figure><h3 id="增加发送队列长度">7.7.2 增加发送队列长度</h3><p>每个网络设备都有一个可以修改的 txqueuelen。 大多数 qdisc 在将数据插入到其发送队列之 前，会检查 txqueuelen 是否足够（表示的是字节数？）。 你可以调整这个参数以增加 qdisc 队列的字节数。</p><p>Example: increase the <code>txqueuelen</code> of <code>eth0</code> to <code>10000</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ifconfig eth0 txqueuelen 10000</span><br></pre></td></tr></table></figure><p>默认值是 1000，你可以通过 ifconfig 命令的输出，查看每个网络设备的 txqueuelen。</p><h1 id="网络设备驱动">8 网络设备驱动</h1><p>我们即将结束我们的网络栈之旅。</p><p>要理解数据包的发送过程，有一个重要的概念。大多数设备和驱动程序通过两个阶段处理数 据包发送：</p><ol><li>合理地组织数据，然后触发设备通过 DMA 从 RAM 中读取数据并将其发送到网络中</li><li>发送完成后，设备发出中断，驱动程序解除映射缓冲区、释放内存或清除其状态</li></ol><p>第二阶段通常称为“发送完成”（transmit completion）阶段。我们将对以上两阶段进行研 究，先从第一个开始：发送阶段。</p><p>之前已经看到，<code>dev_hard_start_xmit</code> 通过调用 <code>ndo_start_xmit</code>（保持一个锁）来发送 数据，所以接下来先看驱动程序是如何注册 <code>ndo_start_xmit</code> 的，然后再深入理解该函数的 工作原理。</p><p>与上篇<a href="http://arthurchiao.art/blog/tuning-stack-rx-zh/">Linux 网络栈监控和调优：接收数据</a> 一样，我们将拿 <code>igb</code> 驱动作为例子。</p><h2 id="驱动回调函数注册">8.1 驱动回调函数注册</h2><p>驱动程序实现了一系列方法来支持设备操作，例如：</p><ol><li>发送数据（<code>ndo_start_xmit</code>）</li><li>获取统计信息（<code>ndo_get_stats64</code>）</li><li>处理设备 <code>ioctl</code>s（<code>ndo_do_ioctl</code>）</li></ol><p>这些方法通过一个 <code>struct net_device_ops</code> 实例导出。让我们来看看<a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L1905-L1928">igb 驱动程序 </a>中这些操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static const struct net_device_ops igb_netdev_ops &#x3D; &#123;</span><br><span class="line">        .ndo_open               &#x3D; igb_open,</span><br><span class="line">        .ndo_stop               &#x3D; igb_close,</span><br><span class="line">        .ndo_start_xmit         &#x3D; igb_xmit_frame,</span><br><span class="line">        .ndo_get_stats64        &#x3D; igb_get_stats64,</span><br><span class="line"></span><br><span class="line">                &#x2F;* ... more fields ... *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个 <code>igb_netdev_ops</code> 变量在 <a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L2090"><code>igb_probe</code></a> 函数中注册给设备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static int igb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)</span><br><span class="line">&#123;</span><br><span class="line">                &#x2F;* ... lots of other stuff ... *&#x2F;</span><br><span class="line"></span><br><span class="line">        netdev-&gt;netdev_ops &#x3D; &amp;igb_netdev_ops;</span><br><span class="line"></span><br><span class="line">                &#x2F;* ... more code ... *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如我们在上一节中看到的，更上层的代码将通过设备的 <code>netdev_ops</code> 字段 调用适当的回调函数。想了解更多关于 PCI 设备是如何启动的，以及何时/何处调用 <code>igb_probe</code>，请查看我们之前文章中的<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#initialization">驱动程序初始化 </a>部分。</p><h2 id="通过-ndo-start-xmit-发送数据">8.2 通过 ndo_start_xmit 发送数据</h2><p>上层的网络栈通过 <code>struct net_device_ops</code> 实例里的回调函数，调用驱动程序来执行各种 操作。正如我们之前看到的，qdisc 代码调用 <code>ndo_start_xmit</code> 将数据传递给驱动程序进行 发送。对于大多数硬件设备，都是在保持一个锁时调用 <code>ndo_start_xmit</code> 函数。</p><p>在 igb 设备驱动程序中，<code>ndo_start_xmit</code> 字段初始化为 <code>igb_xmit_frame</code> 函数，所以 我们接下来从 <code>igb_xmit_frame</code> 开始，查看该驱动程序是如何发送数据的。跟随 <a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L4664-L4741">drivers/net/ethernet/intel/igb/igb_main.c</a> ，并记得以下代码在整个执行过程中都 hold 着一个锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">netdev_tx_t igb_xmit_frame_ring(struct sk_buff *skb,</span><br><span class="line">                                struct igb_ring *tx_ring)</span><br><span class="line">&#123;</span><br><span class="line">        struct igb_tx_buffer *first;</span><br><span class="line">        int tso;</span><br><span class="line">        u32 tx_flags &#x3D; 0;</span><br><span class="line">        u16 count &#x3D; TXD_USE_COUNT(skb_headlen(skb));</span><br><span class="line">        __be16 protocol &#x3D; vlan_get_protocol(skb);</span><br><span class="line">        u8 hdr_len &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        &#x2F;* need: 1 descriptor per page * PAGE_SIZE&#x2F;IGB_MAX_DATA_PER_TXD,</span><br><span class="line">         *       + 1 desc for skb_headlen&#x2F;IGB_MAX_DATA_PER_TXD,</span><br><span class="line">         *       + 2 desc gap to keep tail from touching head,</span><br><span class="line">         *       + 1 desc for context descriptor,</span><br><span class="line">         * otherwise try next time</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (NETDEV_FRAG_PAGE_MAX_SIZE &gt; IGB_MAX_DATA_PER_TXD) &#123;</span><br><span class="line">                unsigned short f;</span><br><span class="line">                for (f &#x3D; 0; f &lt; skb_shinfo(skb)-&gt;nr_frags; f++)</span><br><span class="line">                        count +&#x3D; TXD_USE_COUNT(skb_shinfo(skb)-&gt;frags[f].size);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">                count +&#x3D; skb_shinfo(skb)-&gt;nr_frags;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>函数首先使用 <code>TXD_USER_COUNT</code> 宏来计算发送 skb 所需的描述符数量，用 <code>count</code> 变量表示。然后根据分片情况，对 <code>count</code> 进行相应调整。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (igb_maybe_stop_tx(tx_ring, count + 3)) &#123;</span><br><span class="line">        &#x2F;* this is a hard error *&#x2F;</span><br><span class="line">        return NETDEV_TX_BUSY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后驱动程序调用内部函数 <code>igb_maybe_stop_tx</code>，检查 TX Queue 以确保有足够可用的描 述符。如果没有，则返回 <code>NETDEV_TX_BUSY</code>。正如我们之前在 qdisc 代码中看到的那样，这 将导致 qdisc 将 skb 重新入队以便稍后重试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* record the location of the first descriptor for this packet *&#x2F;</span><br><span class="line">first &#x3D; &amp;tx_ring-&gt;tx_buffer_info[tx_ring-&gt;next_to_use];</span><br><span class="line">first-&gt;skb &#x3D; skb;</span><br><span class="line">first-&gt;bytecount &#x3D; skb-&gt;len;</span><br><span class="line">first-&gt;gso_segs &#x3D; 1;</span><br></pre></td></tr></table></figure><p>然后，获取 TX Queue 中下一个可用缓冲区信息，用 <code>struct igb_tx_buffer *first</code> 表 示，这个信息稍后将用于设置缓冲区描述符。数据包 <code>skb</code> 指针及其大小 <code>skb-&gt;len</code> 也存储到 <code>first</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skb_tx_timestamp(skb);</span><br></pre></td></tr></table></figure><p>接下来代码调用 <code>skb_tx_timestamp</code>，获取基于软件的发送时间戳。应用程序可以 使用发送时间戳来确定数据包通过网络栈的发送路径所花费的时间。</p><p>某些设备还支持硬件时间戳，这允许系统将打时间戳任务 offload 到设备。程序员因此可以 获得更准确的时间戳，因为它更接近于硬件实际发送的时间。</p><p>某些网络设备可以使用<a href="https://events.linuxfoundation.org/sites/events/files/slides/lcjp14_ichikawa_0.pdf">Precision Time Protocol</a> （PTP，精确时间协议）在硬件中为数据包加时间戳。驱动程序处理用户的硬件时间戳请求。</p><p>我们现在看到这个代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (unlikely(skb_shinfo(skb)-&gt;tx_flags &amp; SKBTX_HW_TSTAMP)) &#123;</span><br><span class="line">        struct igb_adapter *adapter &#x3D; netdev_priv(tx_ring-&gt;netdev);</span><br><span class="line"></span><br><span class="line">        if (!(adapter-&gt;ptp_tx_skb)) &#123;</span><br><span class="line">                skb_shinfo(skb)-&gt;tx_flags |&#x3D; SKBTX_IN_PROGRESS;</span><br><span class="line">                tx_flags |&#x3D; IGB_TX_FLAGS_TSTAMP;</span><br><span class="line"></span><br><span class="line">                adapter-&gt;ptp_tx_skb &#x3D; skb_get(skb);</span><br><span class="line">                adapter-&gt;ptp_tx_start &#x3D; jiffies;</span><br><span class="line">                if (adapter-&gt;hw.mac.type &#x3D;&#x3D; e1000_82576)</span><br><span class="line">                        schedule_work(&amp;adapter-&gt;ptp_tx_work);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 if 语句检查 <code>SKBTX_HW_TSTAMP</code> 标志，该标志表示用户请求了硬件时间戳。接下来检 查是否设置了 <code>ptp_tx_skb</code>。一次只能给一个数据包加时间戳，因此给正在打时间戳的 skb 上设置了 <code>SKBTX_IN_PROGRESS</code> 标志。然后更新 <code>tx_flags</code>，将 <code>IGB_TX_FLAGS_TSTAMP</code> 标志 置位。<code>tx_flags</code> 变量稍后将被复制到缓冲区信息结构中。</p><p>当前的 <code>jiffies</code> 值赋给 <code>ptp_tx_start</code>。驱动程序中的其他代码将使用这个值， 以确保 TX 硬件打时间戳不会 hang 住。最后，如果这是一个 82576 以太网硬件网卡，将用 <code>schedule_work</code> 函数启动<a href="http://www.makelinux.net/ldd3/chp-7-sect-6">工作队列</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (vlan_tx_tag_present(skb)) &#123;</span><br><span class="line">        tx_flags |&#x3D; IGB_TX_FLAGS_VLAN;</span><br><span class="line">        tx_flags |&#x3D; (vlan_tx_tag_get(skb) &lt;&lt; IGB_TX_FLAGS_VLAN_SHIFT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码将检查 skb 的 <code>vlan_tci</code> 字段是否设置了，如果是，将设置 <code>IGB_TX_FLAGS_VLAN</code> 标记，并保存 VLAN ID。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* record initial flags and protocol *&#x2F;</span><br><span class="line">first-&gt;tx_flags &#x3D; tx_flags;</span><br><span class="line">first-&gt;protocol &#x3D; protocol;</span><br></pre></td></tr></table></figure><p>最后将 <code>tx_flags</code> 和 <code>protocol</code> 值都保存到 <code>first</code> 变量里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tso &#x3D; igb_tso(tx_ring, first, &amp;hdr_len);</span><br><span class="line">if (tso &lt; 0)</span><br><span class="line">        goto out_drop;</span><br><span class="line">else if (!tso)</span><br><span class="line">        igb_tx_csum(tx_ring, first);</span><br></pre></td></tr></table></figure><p>接下来，驱动程序调用其内部函数 <code>igb_tso</code>，判断 skb 是否需要分片。如果需要 ，缓冲区信息变量（<code>first</code>）将更新标志位，以提示硬件需要做 TSO。</p><p>如果不需要 TSO，则 <code>igb_tso</code> 返回 0；否则返回 1。 如果返回 0，则将调用 <code>igb_tx_csum</code> 来 处理校验和 offload 信息（是否需要 offload，是否支持此协议的 offload）。 <code>igb_tx_csum</code> 函数将检查 skb 的属性，修改 <code>first</code> 变量中的一些标志位，以表示需要校验 和 offload。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">igb_tx_map(tx_ring, first, hdr_len);</span><br></pre></td></tr></table></figure><p><code>igb_tx_map</code> 函数准备给设备发送的数据。我们后面会仔细查看这个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Make sure there is space in the ring for the next send. *&#x2F;</span><br><span class="line">igb_maybe_stop_tx(tx_ring, DESC_NEEDED);</span><br><span class="line"></span><br><span class="line">return NETDEV_TX_OK;</span><br></pre></td></tr></table></figure><p>发送结束之后，驱动要检查确保有足够的描述符用于下一次发送。如果不够，TX Queue 将被 关闭。最后返回 <code>NETDEV_TX_OK</code> 给上层（qdisc 代码）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">out_drop:</span><br><span class="line">        igb_unmap_and_free_tx_resource(tx_ring, first);</span><br><span class="line"></span><br><span class="line">        return NETDEV_TX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是一些错误处理代码，只有当 <code>igb_tso</code> 遇到某种错误时才会触发此代码。 <code>igb_unmap_and_free_tx_resource</code> 用于清理数据。在这种情况下也返回 <code>NETDEV_TX_OK</code> 。发送没有成功，但驱动程序释放了相关资源，没有什么需要做的了。请注意，在这种情 况下，此驱动程序不会增加 drop 计数，但或许它应该增加。</p><h2 id="igb-tx-map">8.3 igb_tx_map</h2><p><code>igb_tx_map</code> 函数处理将 skb 数据映射到 RAM 的 DMA 区域的细节。它还会更新设备 TX Queue 的 尾部指针，从而触发设备“被唤醒”，从 RAM 获取数据并开始发送。</p><p>让我们简单地看一下这个<a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L4501-L4627">函数 </a>的工作原理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void igb_tx_map(struct igb_ring *tx_ring,</span><br><span class="line">                       struct igb_tx_buffer *first,</span><br><span class="line">                       const u8 hdr_len)</span><br><span class="line">&#123;</span><br><span class="line">        struct sk_buff *skb &#x3D; first-&gt;skb;</span><br><span class="line"></span><br><span class="line">                &#x2F;* ... other variables ... *&#x2F;</span><br><span class="line"></span><br><span class="line">        u32 tx_flags &#x3D; first-&gt;tx_flags;</span><br><span class="line">        u32 cmd_type &#x3D; igb_tx_cmd_type(skb, tx_flags);</span><br><span class="line">        u16 i &#x3D; tx_ring-&gt;next_to_use;</span><br><span class="line"></span><br><span class="line">        tx_desc &#x3D; IGB_TX_DESC(tx_ring, i);</span><br><span class="line"></span><br><span class="line">        igb_tx_olinfo_status(tx_ring, tx_desc, tx_flags, skb-&gt;len - hdr_len);</span><br><span class="line"></span><br><span class="line">        size &#x3D; skb_headlen(skb);</span><br><span class="line">        data_len &#x3D; skb-&gt;data_len;</span><br><span class="line"></span><br><span class="line">        dma &#x3D; dma_map_single(tx_ring-&gt;dev, skb-&gt;data, size, DMA_TO_DEVICE);</span><br></pre></td></tr></table></figure><p>上面的代码所做的一些事情：</p><ol><li>声明变量并初始化</li><li>使用 <code>IGB_TX_DESC</code> 获取下一个可用描述符的指针</li><li><code>igb_tx_olinfo_status</code> 函数更新 <code>tx_flags</code>，并将它们复制到描述符（<code>tx_desc</code>）中</li><li>计算 skb 头长度和数据长度</li><li>调用 <code>dma_map_single</code> 为 <code>skb-&gt;data</code> 构造内存映射，以允许设备通过 DMA 从 RAM 中读取数据</li></ol><p>接下来是驱动程序中的一个<strong>非常长的循环，用于为 skb 的每个分片生成有效映射</strong>。具体如何 做的细节并不是特别重要，但如下步骤值得一提：</p><ul><li>驱动程序遍历该数据包的所有分片</li><li>当前描述符有其数据的 DMA 地址信息</li><li>如果分片的大小大于单个 IGB 描述符可以发送的大小，则构造多个描述符指向可 DMA 区域的块，直到描述符指向整个分片</li><li>更新描述符迭代器</li><li>更新剩余长度</li><li>当没有剩余分片或者已经消耗了整个数据长度时，循环终止</li></ul><p>下面提供循环的代码以供以上描述参考。这里的代码进一步向读者说明，<strong>如果可能的话，避 免分片是一个好主意</strong>。分片需要大量额外的代码来处理网络栈的每一层，包括驱动层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">tx_buffer &#x3D; first;</span><br><span class="line"></span><br><span class="line">for (frag &#x3D; &amp;skb_shinfo(skb)-&gt;frags[0];; frag++) &#123;</span><br><span class="line">        if (dma_mapping_error(tx_ring-&gt;dev, dma))</span><br><span class="line">                goto dma_error;</span><br><span class="line"></span><br><span class="line">        &#x2F;* record length, and DMA address *&#x2F;</span><br><span class="line">        dma_unmap_len_set(tx_buffer, len, size);</span><br><span class="line">        dma_unmap_addr_set(tx_buffer, dma, dma);</span><br><span class="line"></span><br><span class="line">        tx_desc-&gt;read.buffer_addr &#x3D; cpu_to_le64(dma);</span><br><span class="line"></span><br><span class="line">        while (unlikely(size &gt; IGB_MAX_DATA_PER_TXD)) &#123;</span><br><span class="line">                tx_desc-&gt;read.cmd_type_len &#x3D;</span><br><span class="line">                        cpu_to_le32(cmd_type ^ IGB_MAX_DATA_PER_TXD);</span><br><span class="line"></span><br><span class="line">                i++;</span><br><span class="line">                tx_desc++;</span><br><span class="line">                if (i &#x3D;&#x3D; tx_ring-&gt;count) &#123;</span><br><span class="line">                        tx_desc &#x3D; IGB_TX_DESC(tx_ring, 0);</span><br><span class="line">                        i &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">                tx_desc-&gt;read.olinfo_status &#x3D; 0;</span><br><span class="line"></span><br><span class="line">                dma +&#x3D; IGB_MAX_DATA_PER_TXD;</span><br><span class="line">                size -&#x3D; IGB_MAX_DATA_PER_TXD;</span><br><span class="line"></span><br><span class="line">                tx_desc-&gt;read.buffer_addr &#x3D; cpu_to_le64(dma);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (likely(!data_len))</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">        tx_desc-&gt;read.cmd_type_len &#x3D; cpu_to_le32(cmd_type ^ size);</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">        tx_desc++;</span><br><span class="line">        if (i &#x3D;&#x3D; tx_ring-&gt;count) &#123;</span><br><span class="line">                tx_desc &#x3D; IGB_TX_DESC(tx_ring, 0);</span><br><span class="line">                i &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        tx_desc-&gt;read.olinfo_status &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        size &#x3D; skb_frag_size(frag);</span><br><span class="line">        data_len -&#x3D; size;</span><br><span class="line"></span><br><span class="line">        dma &#x3D; skb_frag_dma_map(tx_ring-&gt;dev, frag, 0,</span><br><span class="line">                               size, DMA_TO_DEVICE);</span><br><span class="line"></span><br><span class="line">        tx_buffer &#x3D; &amp;tx_ring-&gt;tx_buffer_info[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有需要的描述符都已建好，且 <code>skb</code> 的所有数据都映射到 DMA 地址后，驱动就会 进入到它的最后一步，触发一次发送：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* write last descriptor with RS and EOP bits *&#x2F;</span><br><span class="line">cmd_type |&#x3D; size | IGB_TXD_DCMD;</span><br><span class="line">tx_desc-&gt;read.cmd_type_len &#x3D; cpu_to_le32(cmd_type);</span><br></pre></td></tr></table></figure><p>对最后一个描述符设置 <code>RS</code> 和 <code>EOP</code> 位，以提示设备这是最后一个描述符了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netdev_tx_sent_queue(txring_txq(tx_ring), first-&gt;bytecount);</span><br><span class="line"></span><br><span class="line">&#x2F;* set the timestamp *&#x2F;</span><br><span class="line">first-&gt;time_stamp &#x3D; jiffies;</span><br></pre></td></tr></table></figure><p>调用 <code>netdev_tx_sent_queue</code> 函数，同时带着将发送的字节数作为参数。这个函数是 byte query limit（字节查询限制）功能的一部分，我们将在稍后详细介绍。当前的 jiffies 存 储到 <code>first</code> 的时间戳字段。</p><p>接下来，有点 tricky：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Force memory writes to complete before letting h&#x2F;w know there</span><br><span class="line"> * are new descriptors to fetch.  (Only applicable for weak-ordered</span><br><span class="line"> * memory model archs, such as IA-64).</span><br><span class="line"> *</span><br><span class="line"> * We also need this memory barrier to make certain all of the</span><br><span class="line"> * status bits have been updated before next_to_watch is written.</span><br><span class="line"> *&#x2F;</span><br><span class="line">wmb();</span><br><span class="line"></span><br><span class="line">&#x2F;* set next_to_watch value indicating a packet is present *&#x2F;</span><br><span class="line">first-&gt;next_to_watch &#x3D; tx_desc;</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line">if (i &#x3D;&#x3D; tx_ring-&gt;count)</span><br><span class="line">        i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">tx_ring-&gt;next_to_use &#x3D; i;</span><br><span class="line"></span><br><span class="line">writel(i, tx_ring-&gt;tail);</span><br><span class="line"></span><br><span class="line">&#x2F;* we need this if more than one processor can write to our tail</span><br><span class="line"> * at a time, it synchronizes IO on IA64&#x2F;Altix systems</span><br><span class="line"> *&#x2F;</span><br><span class="line">mmiowb();</span><br><span class="line"></span><br><span class="line">return;</span><br></pre></td></tr></table></figure><p>上面的代码做了一些重要的事情：</p><ol><li>调用 <code>wmb</code> 函数强制完成内存写入。这通常称作<strong>“写屏障”</strong>（write barrier） ，是通过 CPU 平台相关的特殊指令完成的。这对某些 CPU 架构非常重要，因为如果触发 设备启动 DMA 时不能确保所有内存写入已经完成，那设备可能从 RAM 中读取不一致 状态的数据。<a href="http://preshing.com/20120930/weak-vs-strong-memory-models/">这篇文章</a>和<a href="http://www.cs.utexas.edu/~pingali/CS378/2012fa/lectures/consistency.pdf">这个课程</a>深 入探讨了内存顺序的细节</li><li>设置 <code>next_to_watch</code> 字段，它将在 completion 阶段后期使用</li><li>更新计数，并且 TX Queue 的 <code>next_to_use</code> 字段设置为下一个可用的描述符。使用 <code>writel</code> 函数更新 TX Queue 的尾部。<code>writel</code> 向<a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">内存映射 I/O</a>地址写入一个 <code>long</code> 型数据 ，这里地址是 <code>tx_ring-&gt;tail</code>（一个硬件地址），要写入的值是 <code>i</code>。这次写操作会让 设备知道其他数据已经准备好，可以通过 DMA 从 RAM 中读取并写入网络</li><li>最后，调用 <code>mmiowb</code> 函数。它执行特定于 CPU 体系结构的指令，对内存映射的 写操作进行排序。它也是一个写屏障，用于内存映射的 I/O 写</li></ol><p>想了解更多关于 <code>wmb</code>，<code>mmiowb</code> 以及何时使用它们的信息，可以阅读 Linux 内核中一些包含 内存屏障的优秀<a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/memory-barriers.txt">文档</a> 。</p><p>最后，代码包含了一些错误处理。只有 DMA API（将 skb 数据地址映射到 DMA 地址）返回错误 时，才会执行此代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dma_error:</span><br><span class="line">        dev_err(tx_ring-&gt;dev, &quot;TX DMA map failed\n&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;* clear dma mappings for failed tx_buffer_info map *&#x2F;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">                tx_buffer &#x3D; &amp;tx_ring-&gt;tx_buffer_info[i];</span><br><span class="line">                igb_unmap_and_free_tx_resource(tx_ring, tx_buffer);</span><br><span class="line">                if (tx_buffer &#x3D;&#x3D; first)</span><br><span class="line">                        break;</span><br><span class="line">                if (i &#x3D;&#x3D; 0)</span><br><span class="line">                        i &#x3D; tx_ring-&gt;count;</span><br><span class="line">                i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tx_ring-&gt;next_to_use &#x3D; i;</span><br></pre></td></tr></table></figure><p>在继续跟进“发送完成”（transmit completion）过程之前，让我们来看下之前跳过了的一 个东西：dynamic queue limits（动态队列限制）。</p><h3 id="Dynamic-Queue-Limits-DQL">8.3.1 Dynamic Queue Limits (DQL)</h3><p>正如在本文中看到的，<strong>数据在逐步接近网络设备的过程中，花费了大量时间在 不同阶段的 Queue 里面</strong>。队列越大，在队列中所花费的时间就越多。</p><p>解决这个问题的一种方式是<strong>背压</strong>（back pressure）。动态队列限制（DQL）系统是一种 机制，驱动程序可以使用该机制向网络系统（network system）施加反压，以避免设备 无法发送时有过多的数据积压在队列。</p><p>要使用 DQL，驱动需要在其发送和完成例程（transmit and completion routines）中调用 几次简单的 API。DQL 内部算法判断何时数据已足够多，达到此阈值后，DQL 将暂时禁用 TX Queue，从而对网络系统产生背压。当足够的数据已发送完后，DQL 再自动重新启用 该队列。</p><p><a href="https://www.linuxplumbersconf.org/2012/wp-content/uploads/2012/08/bql_slide.pdf">这里</a> 给出了 DQL 的一些性能数据及 DQL 内部算法的说明。</p><p>我们刚刚看到的 <code>netdev_tx_sent_queue</code> 函数就是 DQL API 一部分。当数据排 队到设备进行发送时，将调用此函数。发送完成后，驱动程序调用 <code>netdev_tx_completed_queue</code>。在内部，这两个函数都将调用 DQL 库（在 <a href="https://github.com/torvalds/linux/blob/v3.13/lib/dynamic_queue_limits.c">lib/dynamic_queue_limits.c</a> 和 <a href="https://github.com/torvalds/linux/blob/v3.13/include/linux/dynamic_queue_limits.h">include/linux/dynamic_queue_limits.h</a> ），以判断是否禁用、重新启用 DQL，或保持配置不动。</p><p>DQL 在 sysfs 中导出了一些统计信息和调优参数。调整 DQL 不是必需的；算法自己会随着时间 变化调整其参数。尽管如此，为了完整性，我们稍后会看到如何监控和调整 DQL。</p><h2 id="发送完成（Transmit-completions）">8.4 发送完成（Transmit completions）</h2><p>设备发送数据之后会产生一个中断，表示发送已完成。然后，设备驱动程序可以调度一些长 时间运行的工作，例如解除 DMA 映射、释放数据。这是如何工作的取决于不同设备。对于 <code>igb</code> 驱动程序（及其关联设备），发送完成和数据包接收所触发的 IRQ 是相同的。这意味着 对于 <code>igb</code> 驱动程序，<code>NET_RX</code> 既用于处理发送完成，又用于处理数据包接收。</p><p>让我重申一遍，以强调这一点的重要性：<strong>你的设备可能会发出与“接收到数据包时触发的中 断”相同的中断来表示“数据包发送已完成”</strong>。如果是这种情况，则 <code>NET_RX</code> softirq 会被用于 处理<strong>数据包接收</strong>和<strong>发送完成</strong>两种情况。</p><p>由于两个操作共享相同的 IRQ，因此只能注册一个 IRQ 处理函数来处理这两种情况。 回忆以下收到网络数据时的流程：</p><ol><li>收到网络数据</li><li>网络设备触发 IRQ</li><li>驱动的 IRQ 处理程序执行，清除 IRQ 并运行 softIRQ（如果尚未运行）。这里触发的 softIRQ 是 <code>NET_RX</code> 类型</li><li>softIRQ 本质上作为单独的内核线程，执行 NAPI 轮询循环</li><li>只要有足够的预算，NAPI 轮询循环就一直接收数据包</li><li>每次处理数据包后，预算都会减少，直到没有更多数据包要处理、预算达到 0 或时间片已过期为止</li></ol><p>在 igb（和 ixgbe）驱动中，上面的步骤 5 在处理接收数据之前会先处理发送完成（TX completion）。请记住，<strong>根据驱动程序的实现，处理发送完成和接收数据的函数可能共享一 份处理预算</strong>。igb 和 ixgbe 驱动程序分别跟踪发送完成和接收数据包的预算，因此处理发送完 成不一定会消耗完 RX 预算。</p><p>也就是说，整个 NAPI 轮询循环在 hard code 时间片内运行。这意味着如果要处理大量的 TX 完成 ，TX 完成可能会比处理接收数据时占用更多的时间片。对于在高负载环境中运行网络硬 件的人来说，这可能是一个重要的考虑因素。</p><p>让我们看看 igb 驱动程序在实际是如何实现的。</p><h3 id="Transmit-completion-IRQ">8.4.1 Transmit completion IRQ</h3><p>收包过程我们已经在<a href="http://arthurchiao.art/blog/tuning-stack-rx-zh/">数据接收部分的博客</a> 中介绍过，这里不再赘述，只给出相应链接。</p><p>那么，让我们从头开始：</p><ol><li>网络设备<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#bringing-a-network-device-up">启用</a>（bring up）</li><li>IRQ 处理函数完成<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#register-an-interrupt-handler">注册</a></li><li>用户程序将数据发送到 socket。数据穿过网络栈，最后被网络设备从内存中取出并发送</li><li>设备完成数据发送并触发 IRQ 表示发送完成</li><li>驱动程序的 IRQ 处理函数开始<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#interrupt-handler">处理中断</a></li><li>IRQ 处理程序调用 <code>napi_schedule</code></li><li><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#napi-and-napischedule">NAPI 代码</a>触发 <code>NET_RX</code> 类型 softirq</li><li><code>NET_RX</code> 类型 sofitrq 的中断处理函数 <code>net_rx_action</code><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#network-data-processing-begins">开始执行</a></li><li><code>net_rx_action</code> 函数调用驱动程序注册的<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#napi-poll-function-and-weight">NAPI 轮询函数</a></li><li>NAPI 轮询函数 <code>igb_poll</code><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#igbpoll">开始运行</a></li></ol><p>poll 函数 <code>igb_poll</code> 同时处理接收数据包和发送完成（transmit completion）逻辑。让我 们深入研究这个函数的代码，看看发生了什么。</p><h3 id="igb-poll">8.4.2 igb_poll</h3><p><a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L5987-L6018">drivers/net/ethernet/intel/igb/igb_main.c</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  igb_poll - NAPI Rx polling callback</span><br><span class="line"> *  @napi: napi polling structure</span><br><span class="line"> *  @budget: count of how many packets we should handle</span><br><span class="line"> **&#x2F;</span><br><span class="line">static int igb_poll(struct napi_struct *napi, int budget)</span><br><span class="line">&#123;</span><br><span class="line">        struct igb_q_vector *q_vector &#x3D; container_of(napi,</span><br><span class="line">                                                     struct igb_q_vector,</span><br><span class="line">                                                     napi);</span><br><span class="line">        bool clean_complete &#x3D; true;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_IGB_DCA</span><br><span class="line">        if (q_vector-&gt;adapter-&gt;flags &amp; IGB_FLAG_DCA_ENABLED)</span><br><span class="line">                igb_update_dca(q_vector);</span><br><span class="line">#endif</span><br><span class="line">        if (q_vector-&gt;tx.ring)</span><br><span class="line">                clean_complete &#x3D; igb_clean_tx_irq(q_vector);</span><br><span class="line"></span><br><span class="line">        if (q_vector-&gt;rx.ring)</span><br><span class="line">                clean_complete &amp;&#x3D; igb_clean_rx_irq(q_vector, budget);</span><br><span class="line"></span><br><span class="line">        &#x2F;* If all work not completed, return budget and keep polling *&#x2F;</span><br><span class="line">        if (!clean_complete)</span><br><span class="line">                return budget;</span><br><span class="line"></span><br><span class="line">        &#x2F;* If not enough Rx work done, exit the polling mode *&#x2F;</span><br><span class="line">        napi_complete(napi);</span><br><span class="line">        igb_ring_irq_enable(q_vector);</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数按顺序执行以下操作：</p><ol><li>如果在内核中启用了直接缓存访问（<a href="https://lwn.net/Articles/247493/">DCA</a>）功能 ，则更新 CPU 缓存（预热，warm up），后续对 RX Ring Buffer 的访问将命中 CPU 缓存。可以在接 收数据博客的 Extras 部分中阅读<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#direct-cache-access-dca">有关 DCA 的更多信息</a></li><li>调用 <code>igb_clean_tx_irq</code> 执行发送完成操作</li><li>调用 <code>igb_clean_rx_irq</code> 处理收到的数据包</li><li>最后，检查 <code>clean_complete</code> 变量，判断是否还有更多工作可以完成。如果是，则返 回预算。如果是这种情况，<code>net_rx_action</code> 会将此 NAPI 实例移动到轮询列表的末尾， 以便稍后再次处理</li></ol><p>要了解 <code>igb_clean_rx_irq</code> 如何工作的，请阅读上一篇博客文章的<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/#igbcleanrxirq">这一部分 </a>。</p><p>本文主要关注发送方面，因此我们将继续研究上面的 <code>igb_clean_tx_irq</code> 如何工作。</p><h3 id="igb-clean-tx-irq">8.4.3 igb_clean_tx_irq</h3><p>来看一下这个函数的实现， <a href="https://github.com/torvalds/linux/blob/v3.13/drivers/net/ethernet/intel/igb/igb_main.c#L6020-L6189">drivers/net/ethernet/intel/igb/igb_main.c</a>。</p><p>这个函数有点长，分成几部分来看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static bool igb_clean_tx_irq(struct igb_q_vector *q_vector)</span><br><span class="line">&#123;</span><br><span class="line">        struct igb_adapter *adapter &#x3D; q_vector-&gt;adapter;</span><br><span class="line">        struct igb_ring *tx_ring &#x3D; q_vector-&gt;tx.ring;</span><br><span class="line">        struct igb_tx_buffer *tx_buffer;</span><br><span class="line">        union e1000_adv_tx_desc *tx_desc;</span><br><span class="line">        unsigned int total_bytes &#x3D; 0, total_packets &#x3D; 0;</span><br><span class="line">        unsigned int budget &#x3D; q_vector-&gt;tx.work_limit;</span><br><span class="line">        unsigned int i &#x3D; tx_ring-&gt;next_to_clean;</span><br><span class="line"></span><br><span class="line">        if (test_bit(__IGB_DOWN, &amp;adapter-&gt;state))</span><br><span class="line">                return true;</span><br></pre></td></tr></table></figure><p>该函数首先初始化一些变量，其中比较重要的是预算（变量 <code>budget</code>） ，初始化为此队列的 <code>tx.work_limit</code>。在 igb 驱动程序中，<code>tx.work_limit</code> 初始化为 hard code 值 <code>IGB_DEFAULT_TX_WORK</code>（128）。</p><p>值得注意的是，虽然我们现在看到的 TX 完成代码与 RX 处理在同一个 <code>NET_RX</code> softirq 中运行 ，但 igb 驱动的 TX 和 RX 函数<strong>不共享处理预算</strong>。由于整个轮询函数在同一时间片内运行，因此 每次 <code>igb_poll</code> 运行不会出现 RX 或 TX 饥饿，只要调用 <code>igb_poll</code>，两者都将被处理。</p><p>继续前进，代码检查网络设备是否已关闭。如果是，则返回 <code>true</code> 并退出 <code>igb_clean_tx_irq</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tx_buffer &#x3D; &amp;tx_ring-&gt;tx_buffer_info[i];</span><br><span class="line">tx_desc &#x3D; IGB_TX_DESC(tx_ring, i);</span><br><span class="line">i -&#x3D; tx_ring-&gt;count;</span><br></pre></td></tr></table></figure><p>接下来：</p><ol><li><code>tx_buffer</code> 变量初始化为 <code>tx_ring-&gt;next_to_clean</code>（其本身被初始化为 0）</li><li><code>tx_desc</code> 变量初始化为相关描述符的指针</li><li>计数器 <code>i</code> 减去 TX Queue 的大小。可以调整此值（我们将在调优部分中看到），但初始化为 <code>IGB_DEFAULT_TXD</code>（256）</li></ol><p>接下来，循环开始。它包含一些有用的注释，用于解释每个步骤中发生的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">        union e1000_adv_tx_desc *eop_desc &#x3D; tx_buffer-&gt;next_to_watch;</span><br><span class="line"></span><br><span class="line">        &#x2F;* if next_to_watch is not set then there is no work pending *&#x2F;</span><br><span class="line">        if (!eop_desc)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">        &#x2F;* prevent any other reads prior to eop_desc *&#x2F;</span><br><span class="line">        read_barrier_depends();</span><br><span class="line"></span><br><span class="line">        &#x2F;* if DD is not set pending work has not been completed *&#x2F;</span><br><span class="line">        if (!(eop_desc-&gt;wb.status &amp; cpu_to_le32(E1000_TXD_STAT_DD)))</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">        &#x2F;* clear next_to_watch to prevent false hangs *&#x2F;</span><br><span class="line">        tx_buffer-&gt;next_to_watch &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">        &#x2F;* update the statistics for this packet *&#x2F;</span><br><span class="line">        total_bytes +&#x3D; tx_buffer-&gt;bytecount;</span><br><span class="line">        total_packets +&#x3D; tx_buffer-&gt;gso_segs;</span><br><span class="line"></span><br><span class="line">        &#x2F;* free the skb *&#x2F;</span><br><span class="line">        dev_kfree_skb_any(tx_buffer-&gt;skb);</span><br><span class="line"></span><br><span class="line">        &#x2F;* unmap skb header data *&#x2F;</span><br><span class="line">        dma_unmap_single(tx_ring-&gt;dev,</span><br><span class="line">                         dma_unmap_addr(tx_buffer, dma),</span><br><span class="line">                         dma_unmap_len(tx_buffer, len),</span><br><span class="line">                         DMA_TO_DEVICE);</span><br><span class="line"></span><br><span class="line">        &#x2F;* clear tx_buffer data *&#x2F;</span><br><span class="line">        tx_buffer-&gt;skb &#x3D; NULL;</span><br><span class="line">        dma_unmap_len_set(tx_buffer, len, 0);</span><br></pre></td></tr></table></figure><ol><li>首先将 <code>eop_desc</code>（eop = end of packet）设置为发送缓冲区 <code>tx_buffer</code> 的 <code>next_to_watch</code>，后者是在我们之前看到的发送代码中设置的</li><li>如果 <code>eop_desc</code> 为 <code>NULL</code>，则表示没有待处理的工作</li><li>接下来调用 <code>read_barrier_depends</code> 函数，该函数执行此 CPU 体系结构相关的指令，通过屏障防止其他任何读操作</li><li>接下来，检查描述符 <code>eop_desc</code> 的状态位。如果 <code>E1000_TXD_STAT_DD</code> 未设置，则表示发送尚未完成，因此跳出循环</li><li>清除 <code>tx_buffer-&gt;next_to_watch</code>。驱动中的 watchdog 定时器将监视此字段以判断发送是否 hang 住。清除此字段将不会触发 watchdog</li><li>统计发送的总字节数和包数，这些计数将被复制到驱动的相应计数中</li><li>释放 skb</li><li>调用 <code>dma_unmap_single</code> 取消 skb 数据区映射</li><li><code>tx_buffer-&gt;skb</code> 设置为 <code>NULL</code>，解除 <code>tx_buffer</code> 映射</li></ol><p>接下来，在上面的循环内部开始了另一个循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* clear last DMA location and unmap remaining buffers *&#x2F;</span><br><span class="line">while (tx_desc !&#x3D; eop_desc) &#123;</span><br><span class="line">        tx_buffer++;</span><br><span class="line">        tx_desc++;</span><br><span class="line">        i++;</span><br><span class="line">        if (unlikely(!i)) &#123;</span><br><span class="line">                i -&#x3D; tx_ring-&gt;count;</span><br><span class="line">                tx_buffer &#x3D; tx_ring-&gt;tx_buffer_info;</span><br><span class="line">                tx_desc &#x3D; IGB_TX_DESC(tx_ring, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* unmap any remaining paged data *&#x2F;</span><br><span class="line">        if (dma_unmap_len(tx_buffer, len)) &#123;</span><br><span class="line">                dma_unmap_page(tx_ring-&gt;dev,</span><br><span class="line">                               dma_unmap_addr(tx_buffer, dma),</span><br><span class="line">                               dma_unmap_len(tx_buffer, len),</span><br><span class="line">                               DMA_TO_DEVICE);</span><br><span class="line">                dma_unmap_len_set(tx_buffer, len, 0);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个内层循环会遍历每个发送描述符，直到 <code>tx_desc</code> 等于 <code>eop_desc</code>，并会解除被其他描 述符引用的被 DMA 映射的数据。</p><p>外层循环继续：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        &#x2F;* move us one more past the eop_desc for start of next pkt *&#x2F;</span><br><span class="line">        tx_buffer++;</span><br><span class="line">        tx_desc++;</span><br><span class="line">        i++;</span><br><span class="line">        if (unlikely(!i)) &#123;</span><br><span class="line">                i -&#x3D; tx_ring-&gt;count;</span><br><span class="line">                tx_buffer &#x3D; tx_ring-&gt;tx_buffer_info;</span><br><span class="line">                tx_desc &#x3D; IGB_TX_DESC(tx_ring, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;* issue prefetch for next Tx descriptor *&#x2F;</span><br><span class="line">        prefetch(tx_desc);</span><br><span class="line"></span><br><span class="line">        &#x2F;* update budget accounting *&#x2F;</span><br><span class="line">        budget--;</span><br><span class="line">&#125; while (likely(budget));</span><br></pre></td></tr></table></figure><p>外层循环递增迭代器，更新 budget，然后检查是否要进入下一次循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">netdev_tx_completed_queue(txring_txq(tx_ring),</span><br><span class="line">                          total_packets, total_bytes);</span><br><span class="line">i +&#x3D; tx_ring-&gt;count;</span><br><span class="line">tx_ring-&gt;next_to_clean &#x3D; i;</span><br><span class="line">u64_stats_update_begin(&amp;tx_ring-&gt;tx_syncp);</span><br><span class="line">tx_ring-&gt;tx_stats.bytes +&#x3D; total_bytes;</span><br><span class="line">tx_ring-&gt;tx_stats.packets +&#x3D; total_packets;</span><br><span class="line">u64_stats_update_end(&amp;tx_ring-&gt;tx_syncp);</span><br><span class="line">q_vector-&gt;tx.total_bytes +&#x3D; total_bytes;</span><br><span class="line">q_vector-&gt;tx.total_packets +&#x3D; total_packets;</span><br></pre></td></tr></table></figure><p>这段代码：</p><ol><li>调用 <code>netdev_tx_completed_queue</code>，它是上面解释的 DQL API 的一部分。如果处理了足够的发送完成，这可能会重新启用 TX Queue</li><li>更新各处的统计信息，以便用户可以访问它们，我们稍后会看到</li></ol><p>代码继续，首先检查是否设置了 <code>IGB_RING_FLAG_TX_DETECT_HANG</code> 标志。每次运行定时器 回调函数时，watchdog 定时器都会设置此标志，以强制定期检查 TX Queue。如果该标志被设 置了，则代码将检查 TX Queue 是否 hang 住：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">if (test_bit(IGB_RING_FLAG_TX_DETECT_HANG, &amp;tx_ring-&gt;flags)) &#123;</span><br><span class="line">        struct e1000_hw *hw &#x3D; &amp;adapter-&gt;hw;</span><br><span class="line"></span><br><span class="line">        &#x2F;* Detect a transmit hang in hardware, this serializes the</span><br><span class="line">         * check with the clearing of time_stamp and movement of i</span><br><span class="line">         *&#x2F;</span><br><span class="line">        clear_bit(IGB_RING_FLAG_TX_DETECT_HANG, &amp;tx_ring-&gt;flags);</span><br><span class="line">        if (tx_buffer-&gt;next_to_watch &amp;&amp;</span><br><span class="line">            time_after(jiffies, tx_buffer-&gt;time_stamp +</span><br><span class="line">                       (adapter-&gt;tx_timeout_factor * HZ)) &amp;&amp;</span><br><span class="line">            !(rd32(E1000_STATUS) &amp; E1000_STATUS_TXOFF)) &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;* detected Tx unit hang *&#x2F;</span><br><span class="line">                dev_err(tx_ring-&gt;dev,</span><br><span class="line">                        &quot;Detected Tx Unit Hang\n&quot;</span><br><span class="line">                        &quot;  Tx Queue             &lt;%d&gt;\n&quot;</span><br><span class="line">                        &quot;  TDH                  &lt;%x&gt;\n&quot;</span><br><span class="line">                        &quot;  TDT                  &lt;%x&gt;\n&quot;</span><br><span class="line">                        &quot;  next_to_use          &lt;%x&gt;\n&quot;</span><br><span class="line">                        &quot;  next_to_clean        &lt;%x&gt;\n&quot;</span><br><span class="line">                        &quot;buffer_info[next_to_clean]\n&quot;</span><br><span class="line">                        &quot;  time_stamp           &lt;%lx&gt;\n&quot;</span><br><span class="line">                        &quot;  next_to_watch        &lt;%p&gt;\n&quot;</span><br><span class="line">                        &quot;  jiffies              &lt;%lx&gt;\n&quot;</span><br><span class="line">                        &quot;  desc.status          &lt;%x&gt;\n&quot;,</span><br><span class="line">                        tx_ring-&gt;queue_index,</span><br><span class="line">                        rd32(E1000_TDH(tx_ring-&gt;reg_idx)),</span><br><span class="line">                        readl(tx_ring-&gt;tail),</span><br><span class="line">                        tx_ring-&gt;next_to_use,</span><br><span class="line">                        tx_ring-&gt;next_to_clean,</span><br><span class="line">                        tx_buffer-&gt;time_stamp,</span><br><span class="line">                        tx_buffer-&gt;next_to_watch,</span><br><span class="line">                        jiffies,</span><br><span class="line">                        tx_buffer-&gt;next_to_watch-&gt;wb.status);</span><br><span class="line">                netif_stop_subqueue(tx_ring-&gt;netdev,</span><br><span class="line">                                    tx_ring-&gt;queue_index);</span><br><span class="line"></span><br><span class="line">                &#x2F;* we are about to reset, no point in enabling stuff *&#x2F;</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上面的 if 语句检查：</p><ol><li><code>tx_buffer-&gt;next_to_watch</code> 已设置，并且</li><li>当前 jiffies 大于 <code>tx_buffer</code> 发送路径上记录的 <code>time_stamp</code> 加上超时因子，并且</li><li>设备的发送状态寄存器未设置 <code>E1000_STATUS_TXOFF</code></li></ol><p>如果这三个条件都为真，则会打印一个错误，表明已检测到挂起。<code>netif_stop_subqueue</code> 用于关闭队列，最后函数返回 true。</p><p>让我们继续阅读代码，看看如果没有发送挂起检查会发生什么，或者如果有，但没有检测到 挂起：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#define TX_WAKE_THRESHOLD (DESC_NEEDED * 2)</span><br><span class="line">        if (unlikely(total_packets &amp;&amp;</span><br><span class="line">            netif_carrier_ok(tx_ring-&gt;netdev) &amp;&amp;</span><br><span class="line">            igb_desc_unused(tx_ring) &gt;&#x3D; TX_WAKE_THRESHOLD)) &#123;</span><br><span class="line">                &#x2F;* Make sure that anybody stopping the queue after this</span><br><span class="line">                 * sees the new next_to_clean.</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                smp_mb();</span><br><span class="line">                if (__netif_subqueue_stopped(tx_ring-&gt;netdev,</span><br><span class="line">                                             tx_ring-&gt;queue_index) &amp;&amp;</span><br><span class="line">                    !(test_bit(__IGB_DOWN, &amp;adapter-&gt;state))) &#123;</span><br><span class="line">                        netif_wake_subqueue(tx_ring-&gt;netdev,</span><br><span class="line">                                            tx_ring-&gt;queue_index);</span><br><span class="line"></span><br><span class="line">                        u64_stats_update_begin(&amp;tx_ring-&gt;tx_syncp);</span><br><span class="line">                        tx_ring-&gt;tx_stats.restart_queue++;</span><br><span class="line">                        u64_stats_update_end(&amp;tx_ring-&gt;tx_syncp);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return !!budget;</span><br></pre></td></tr></table></figure><p>在上面的代码中，如果先前已禁用，则驱动程序将重新启动 TX Queue。 它首先检查：</p><ol><li>是否有数据包处理完成（<code>total_packets</code> 非零）</li><li>调用 <code>netif_carrier_ok</code>，确保设备没有被关闭</li><li>TX Queue 中未使用的描述符数量大于等于 <code>TX_WAKE_THRESHOLD</code>（我的 x86_64 系统上此阈值为 42）</li></ol><p>如果满足以上所有条件，则执行<strong>写屏障</strong>（<code>smp_mb</code>）。</p><p>接下来检查另一组条件。如果：</p><ol><li>队列停止了</li><li>设备未关闭</li></ol><p>则调用 <code>netif_wake_subqueue</code> 唤醒 TX Queue，并向更高层发信号通知它们可能需要将数据 再次入队。<code>restart_queue</code> 统计计数器递增。我们接下来会看到如何阅读这个值。</p><p>最后，返回一个布尔值。如果有任何剩余的未使用预算，则返回 true，否则为 false。在 <code>igb_poll</code> 中检查此值以确定返回 <code>net_rx_action</code> 的内容。</p><h3 id="igb-poll-返回值">8.4.4 igb_poll 返回值</h3><p><code>igb_poll</code> 函数通过以下逻辑决定返回什么值给 <code>net_rx_action</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (q_vector-&gt;tx.ring)</span><br><span class="line">        clean_complete &#x3D; igb_clean_tx_irq(q_vector);</span><br><span class="line"></span><br><span class="line">if (q_vector-&gt;rx.ring)</span><br><span class="line">        clean_complete &amp;&#x3D; igb_clean_rx_irq(q_vector, budget);</span><br><span class="line"></span><br><span class="line">&#x2F;* If all work not completed, return budget and keep polling *&#x2F;</span><br><span class="line">if (!clean_complete)</span><br><span class="line">        return budget;</span><br></pre></td></tr></table></figure><p>换句话说，如果：</p><ol><li><code>igb_clean_tx_irq</code> 清除了所有<strong>待发送</strong>数据包，且未用完其 TX 预算（transmit completion budget），并且</li><li><code>igb_clean_rx_irq</code> 清除了所有<strong>接收到的</strong>数据包，且未用完其 RX 预算（packet processing budget）</li></ol><p>那么，最后将返回整个预算值（包括 igb 在内的大多数驱动程序 hard code 为 64）；否则，如果 RX 或 TX 处理中的任何用完了其 budget（因为还有更多工作要做），则调用 <code>napi_complete</code> 禁用 NAPI 并返回 0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        &#x2F;* If not enough Rx work done, exit the polling mode *&#x2F;</span><br><span class="line">        napi_complete(napi);</span><br><span class="line">        igb_ring_irq_enable(q_vector);</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监控网络设备">8.5 监控网络设备</h2><p>监控网络设备有多种方式，每种方式提供的监控粒度和复杂度各不相同。我们先从最粗 大粒度开始，然后逐步到最细的粒度。</p><h3 id="使用-ethtool-S-命令">8.5.1 使用 ethtool -S 命令</h3><p>Ubuntu 安装 ethtool：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ethtool.</span><br></pre></td></tr></table></figure><p><code>ethtool -S &lt;NIC&gt;</code>可以打印设备的收发统计信息（例如，发送错误）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ethtool -S eth0</span><br><span class="line">NIC statistics:</span><br><span class="line">     rx_packets: 597028087</span><br><span class="line">     tx_packets: 5924278060</span><br><span class="line">     rx_bytes: 112643393747</span><br><span class="line">     tx_bytes: 990080156714</span><br><span class="line">     rx_broadcast: 96</span><br><span class="line">     tx_broadcast: 116</span><br><span class="line">     rx_multicast: 20294528</span><br><span class="line">     ....</span><br></pre></td></tr></table></figure><p>监控这个数据不是太容易，因为并无统一的标准规定<code>-S</code> 应该打印出哪些字段。不同的设备 ，甚至是相同设备的不同版本，都可能打印出名字不同但意思相同的字段。</p><p>你首先需要检查里面的“drop”、“buffer”、“miss”、“errors”等字段，然后查看驱动程序的 代码，以确定哪些计数是在软件里更新的（例如，内存不足时更新），哪些是直接来自硬件 寄存器更新的。如果是硬件寄存器值，那你需要查看网卡的 data sheet，确定这个计数真正 表示什么，因为 ethtool 给出的很多字段都是有误导性的（misleading）。</p><h3 id="使用-sysfs">8.5.2 使用 sysfs</h3><p>sysfs 也提供了很多统计值，但比网卡层的统计更上层一些。</p><p>例如，你可以通过 <code>cat &lt;file&gt;</code>的方式查看 eth0 接收的丢包数。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;statistics&#x2F;tx_aborted_errors</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>每个 counter 对应一个文件，包括 <code>tx_aborted_errors</code>, <code>tx_carrier_errors</code>, <code>tx_compressed</code>, <code>tx_dropped</code>,等等。</p><p><strong>不幸的是，每个值代表什么是由驱动决定的，因此，什么时候更新它们，在什么条件下更新 ，都是驱动决定的。</strong>例如，你可能已经注意到，对于同一种错误，有的驱动将其视为 drop ，而有的驱动将其视为 miss。</p><p>如果这些值对你非常重要，那你必须阅读驱动代码和网卡 data sheet，以确定每个值真正代 表什么。</p><h3 id="使用-proc-net-dev">8.5.3 使用/proc/net/dev</h3><p><code>/proc/net/dev</code> 提供了更高一层的统计，它给系统中的每个网络设备一个统计摘要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;proc&#x2F;net&#x2F;dev</span><br><span class="line">Inter-|   Receive                                                |  Transmit</span><br><span class="line"> face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed</span><br><span class="line">  eth0: 110346752214 597737500    0    2    0     0          0  20963860 990024805984 6066582604    0    0    0     0       0          0</span><br><span class="line">    lo: 428349463836 1579868535    0    0    0     0          0         0 428349463836 1579868535    0    0    0     0       0          0</span><br></pre></td></tr></table></figure><p>这里打印出来的字段是上面 sysfs 里字段的一个子集，可以作为通用 general reference。</p><p>上面的建议在这里同样适用，即： 如果这些值对你非常重要，那你必须阅读驱动代码和网卡 data sheet，以确定每个值真正代 表什么。</p><h2 id="监控-DQL">8.6 监控 DQL</h2><p>可以通过<code>/sys/class/net/&lt;NIC&gt;/queues/tx-&lt;QUEUE_ID&gt;/byte_queue_limits/</code> 监控网络设备的动态队列限制（DQL）信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;queues&#x2F;tx-0&#x2F;byte_queue_limits&#x2F;inflight</span><br><span class="line">350</span><br></pre></td></tr></table></figure><p>文件包括：</p><ol><li><code>hold_time</code>: Initialized to HZ (a single hertz). If the queue has been full for hold_time, then the maximum size is decreased.</li><li><code>inflight</code>: This value is equal to (number of packets queued - number of packets completed). It is the current number of packets being transmit for which a completion has not been processed.</li><li><code>limit_max</code>: A hardcoded value, set to DQL_MAX_LIMIT (1879048192 on my x86_64 system).</li><li><code>limit_min</code>: A hardcoded value, set to 0.</li><li><code>limit</code>: A value between limit_min and limit_max which represents the current maximum number of objects which can be queued.</li></ol><p>在修改这些值之前，强烈建议先阅读<a href="https://www.linuxplumbersconf.org/2012/wp-content/uploads/2012/08/bql_slide.pdf">这些资料 </a>，以更深入地了解其算法。</p><h2 id="调优网络设备">8.7 调优网络设备</h2><h3 id="查询-TX-Queue-数量">8.7.1 查询 TX Queue 数量</h3><p>如果网络及其驱动支持多 TX Queue，那可以用 ethtool 调整 TX queue（也叫 TX channel）的数量。</p><p>查看网卡 TX Queue 数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ethtool -l eth0</span><br><span class="line">Channel parameters for eth0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:   0</span><br><span class="line">TX:   0</span><br><span class="line">Other:    0</span><br><span class="line">Combined: 8</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:   0</span><br><span class="line">TX:   0</span><br><span class="line">Other:    0</span><br><span class="line">Combined: 4</span><br></pre></td></tr></table></figure><p>这里显示了（由驱动和硬件）预设的最大值，以及当前值。</p><p>注意：不是所有设备驱动都支持这个选项。</p><p>如果你的网卡不支持，会遇到以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ethtool -l eth0</span><br><span class="line">Channel parameters for eth0:</span><br><span class="line">Cannot get device channel parameters</span><br><span class="line">: Operation not supported</span><br></pre></td></tr></table></figure><p>这表示设备驱动没有实现 ethtool 的 <code>get_channels</code> 方法，这可能是由于网卡不支持调整 queue 数量，不支持多 TX Queue，或者驱动版本太旧导致不支持此操作。</p><h3 id="调整-TX-queue-数量">8.7.2 调整 TX queue 数量</h3><p><code>ethtool -L</code> 可以修改 TX Queue 数量。</p><p>注意：一些设备及其驱动只支持 combined queue，这种情况下一个 TX queue 和和一个 RX queue 绑定到一起的。前面的例子中我们已经看到了。</p><p>例子：设置收发队列数量为 8：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ethtool -L eth0 combined 8</span><br></pre></td></tr></table></figure><p>如果你的设备和驱动支持分别设置 TX queue 和 RX queue 的数量，那你可以分别设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ethtool -L eth0 tx 8</span><br></pre></td></tr></table></figure><p>注意：对于大部分驱动，调整以上设置会导致网卡先 down 再 up，经过这个网卡的连接会断掉 。如果只是一次性改动，那这可能不是太大问题。</p><h3 id="调整-TX-queue-大小">8.7.3 调整 TX queue 大小</h3><p>一些设备及其驱动支持修改 TX queue 大小，这是如何实现的取决于具体的硬件，但是， ethtool 提供了一个通用的接口可以调整这个大小。由于 DQL 在更高层面处理数据排队的问题 ，因此调整队列大小可能不会产生明显的影响。然而，你可能还是想要将 TX queue 调到最大 ，然后再把剩下的事情交给 DQL：</p><p><code>ethtool -g</code> 查看队列当前的大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ethtool -g eth0</span><br><span class="line">Ring parameters for eth0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:   4096</span><br><span class="line">RX Mini:  0</span><br><span class="line">RX Jumbo: 0</span><br><span class="line">TX:   4096</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:   512</span><br><span class="line">RX Mini:  0</span><br><span class="line">RX Jumbo: 0</span><br><span class="line">TX:   512</span><br></pre></td></tr></table></figure><p>以上显示硬件支持最大 4096 个接收和发送描述符，但当前只使用了 512 个。</p><p><code>-G</code> 修改 queue 大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ethtool -G eth0 tx 4096</span><br></pre></td></tr></table></figure><p>注意：对于大部分驱动，调整以上设置会导致网卡先 down 再 up，经过这个网卡的连接会断掉 。如果只是一次性改动，那这可能不是太大问题。</p><h1 id="网络栈之旅：结束">9 网络栈之旅：结束</h1><p>至此，你已经知道关于 Linux 如何发送数据包的全部内容了：从用户程序直到驱动，以及反 方向。</p><h1 id="Extras">10 Extras</h1><h2 id="减少-ARP-流量-MSG-CONFIRM">10.1 减少 ARP 流量 (MSG_CONFIRM)</h2><p><code>send</code>, <code>sendto</code> 和 <code>sendmsg</code> 系统调用都支持一个 <code>flags</code> 参数。如果你调用的时候传递了 <code>MSG_CONFIRM</code> flag，它会使内核里的 <code>dst_neigh_output</code> 函数更新邻居（ARP）缓存的时 间戳。所导致的结果是，相应的邻居缓存不会被垃圾回收。这会减少发出的 ARP 请求的数量 。</p><h2 id="UDP-Corking（软木塞）">10.2 UDP Corking（软木塞）</h2><p>在查看 UDP 协议栈的时候我们深入地研究过了 UDP corking 这个选项。如果你想在应用中使用 这个选项，可以在调用 <code>setsockopt</code> 设置 IPPROTO_UDP 类型 socket 的时候，将 UDP_CORK 标记 位置 1。</p><h2 id="打时间戳">10.3 打时间戳</h2><p>本文已经看到，网络栈可以收集发送包的时间戳信息。我们在文章中已经看到了软 件部分哪里可以设置时间戳；而一些网卡甚至还支持硬件时间戳。</p><p>如果你想看内核网络栈给收包增加了多少延迟，那这个特性非常有用。</p><p>内核<a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/timestamping.txt">关于时间戳的文档</a> 非常优秀，甚至还包括一个<a href="https://github.com/torvalds/linux/tree/v3.13/Documentation/networking/timestamping">示例程序和相应的 Makefile</a>，有兴趣的话可以上手试试。</p><p>使用 <code>ethtool -T</code> 可以查看网卡和驱动支持哪种打时间戳方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ethtool -T eth0</span><br><span class="line">Time stamping parameters for eth0:</span><br><span class="line">Capabilities:</span><br><span class="line">  software-transmit     (SOF_TIMESTAMPING_TX_SOFTWARE)</span><br><span class="line">  software-receive      (SOF_TIMESTAMPING_RX_SOFTWARE)</span><br><span class="line">  software-system-clock (SOF_TIMESTAMPING_SOFTWARE)</span><br><span class="line">PTP Hardware Clock: none</span><br><span class="line">Hardware Transmit Timestamp Modes: none</span><br><span class="line">Hardware Receive Filter Modes: none</span><br></pre></td></tr></table></figure><p>从上面这个信息看，该网卡不支持硬件打时间戳。但这个系统上的软件打时间戳，仍然可以 帮助我判断内核在接收路径上到底带来多少延迟。</p>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>802.11ax 帧格式</title>
      <link href="posts/f75076df.html"/>
      <url>posts/f75076df.html</url>
      
        <content type="html"><![CDATA[<h1 id="Element">1 Element</h1><p><img "" class="lazyload placeholder" data-original="/posts/f75076df/image-20210430141137899.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Element IDs"></p><p><img "" class="lazyload placeholder" data-original="/posts/f75076df/image-20210430141208379.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="Element IDs"></p><h1 id="HE-Capabilities-element">2 HE Capabilities element</h1><p>HE STA通过发送HE Capabilities element来声明它是HE STA。HE Capabilities element包含许多字段，用于通告HE STA的HE能力。</p><p><img "" class="lazyload placeholder" data-original="/posts/f75076df/image-20210430141634639.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="HE Capabilities element format"></p><p>Element ID:255</p><p>Element ID Extension:35</p><h2 id="HE-MAC-Capabilities-Information">2.1 HE MAC Capabilities Information</h2><p><img "" class="lazyload placeholder" data-original="/posts/f75076df/image-20210430142024674.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="HE MAC Capabilities Information field format"></p><p><img "" class="lazyload placeholder" data-original="/posts/f75076df/image-20210430142035913.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="HE MAC Capabilities Information field format"></p><table><thead><tr><th>Subfield</th><th>Definition</th><th>Encoding</th></tr></thead><tbody><tr><td>+HTC-HE Support</td><td>表示支持接收带有HE变量HT控制字段的帧</td><td>对于非AP的STA：<br>如果STA支持基于Draft8.0的10.8中描述的HT Control filed operation，设置为1。 <br>对于AP，将该字段设置为1。</td></tr><tr><td>TWT Requester Support</td><td>表示对TWT请求的支持</td><td>1：dot11TWTOptionActivated为真，并且支持TWT请求<br>0：不支持</td></tr><tr><td>TWT Responder Support</td><td>表示对TWT响应的支持</td><td>1：dot11TWTOptionActivated为真，并且支持TWT请求<br>0：不支持</td></tr><tr><td>Dynamic Fragmentation Support</td><td>STA作为接收者支持的动态分段级别</td><td>0：不支持<br>1：支持1级动态分段整理<br>2：支持2级动态分段整理<br>3：支持3级动态分段整理</td></tr><tr><td>Maximum Number Of Fragmented MSDUs/A-MSDUs Exponent</td><td>STA能够同时接收的最大分段MSDUs/A-MSDU的最大数目（如果接收方支持）</td><td>如果Dynamic Fragmentation Support字段大于0，这个字段会定义MSDUs/A-MSDU的最大分段数目Nmax:<img "" class="lazyload placeholder" data-original="/posts/f75076df/image-20210430151932754.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210430151932754">,如果该字段的值为7，则表示没有限制<br>如果Dynamic Fragmentation Support等于0，则该字段保留</td></tr><tr><td>Minimum Fragment Size</td><td>接收方STA支持的MSDU，A-MSDU（如果支持），MMPDU的第一个片段的最小帧主体（frame body）大小（以字节为单位）</td><td>如果Dynamic Fragmentation Support字段大于0<br>0：没有最小帧主题大小<br>1：最小帧主体大小为128字节<br>2：最小帧主体大小为256字节<br>3：最小帧主体大小为512字节<br>如果Dynamic Fragmentation Support等于0，则该字段保留。<br><br><br></td></tr><tr><td>Trigger Frame MAC Padding Duration</td><td>最小的TrigProcTime（触发帧的填充）</td><td>对于非AP的STA：<br>0：0<br>1：8us<br>2：16us<br>3：保留<br>对于AP，保留</td></tr><tr><td>Multi-TID Aggregation Rx Support</td><td>HE STA在multi-TIDs A-MSUD中接受的QOS数据帧的TID数量，如26.6.3中所述</td><td>设置为HE STA可在多TID A-MPDU中传输的TID数量减去QoS数据帧的1</td></tr><tr><td>HE Link adaptation Support</td><td>使用HLA Control子字段支持链路自适应</td><td>如果+HTC-HE Support子字段为1：<br>0：如果STA不提供HE MFB，设置为0（无反馈）<br>2：如果STA可以接受和仅提供未经请求的HE MFB（未经请求），设置为2<br>3：如果STA能够响应HE MRQ接收并提供HE MFB，并且STA可以接受并提供未经请求的HE MFB，则设置为3（请求的和主动的）<br><br>ME MFB和ME MRQ分别是使用HLA控制子字段的MFB和MRQ<br><br>1：保留<br><br></td></tr><tr><td>All Ack Support</td><td>支持在all ack上下文接收Multi-STTA BlockAck帧</td><td>1：支持<br>0：不支持</td></tr><tr><td>TRS Support</td><td>对于非AP STA，支持接收带有TRS Control子字段的帧</td><td>一个非AP STA，设置+HTC-HE Support的子字段为1：<br>1：如果STA支持接收带有TRS Control子字段<br>0：不支持<br>对于一个AP或者+HTC-HE Support子字段为0，该字段保留。<br></td></tr><tr><td>BSR Support</td><td>对于AP，表示是否支持接收带有BSR Control子字段的帧。<br>对于非AP的STA，表示是否支持生成带有BSR Control子字段的帧</td><td>如果+HTC-HE Support子字段为1：<br>1：如果STA支持BSR Control子字段功能<br>0：不支持<br>如果+HTC-HE Support子字段为0，则该字段保留<br><br><br></td></tr><tr><td>Broadcast TWT Support</td><td>对于非AP STA，表示是否支持TWT调度的STA角色支持。<br>对于AP，表示是否支持TWT调度AP的角色。<br></td><td>1：如果STA支持广播TWT功能<br>0：其他<br></td></tr><tr><td>32-bit BA Bitmap Support</td><td>是否支持接收一个Multi-STA Block Ack帧，该帧具有一个AID信息字段和32-bit Block Ack Bitmap子字段</td><td>1：支持接收一个Multi-STA Block Ack帧，该帧具有一个AID信息字段和32-bit Block Ack Bitmap子字段<br>0：不支持<br></td></tr><tr><td>MU Cascading Support</td><td>是否支持参与MU级联序列</td><td>对于HE AP：<br>1：表示AP能够在MU级联操作下传输一个按照MU级联操作规则构造的A-MPDU <br> 0：不支持<br>对于非AP HE STA：<br>1：表示非AP STA能够接收一个按照MU级联序列规则构造的A-MPDU<br>0：不支持<br></td></tr><tr><td>Ack-Enabled Aggregation Support</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HE信道访问26.2</title>
      <link href="posts/cceb2019.html"/>
      <url>posts/cceb2019.html</url>
      
        <content type="html"><![CDATA[<h1 id="基于TXOP持续时间的RTS-CTS">1 基于TXOP持续时间的RTS / CTS</h1><p>在HE BSS中，RTS/CTS基于TXOP 持续时间（duration）或者PSDU长度，对于非AP HE STA，AP可以将其配置为基于TXOP Duration的RTS/CTS交换来降低密集环境中的干扰。</p><p>HE AP发送的HE operation element中，将HE operation parameters字段中的TXOP Duration RTS Threshold子字段设置为1~1022，设置STA基于TXOP duration RTS/CTS交换。设置为1023，则禁用。设置为0，则保持不变。</p><p>如果与AP关联的STA收到非零的TXOP Duration RTS Threshold，则STA必须将dot11TXOPDurationRTSThreshold设置为收到的值，否则保持不变。</p><p>如果启用了基于TXOP Duration 的RTS/CTS，则需要满足：</p><ul><li>STA给AP发送单独寻址的帧</li><li>TXOP Duration大于等于 32us * dot11TXOPDurationRTSThreshold</li></ul><h1 id="Intra-BSS-and-inter-BSS-PPDU-分类">2 Intra-BSS and inter-BSS PPDU 分类</h1><p>STA接收到的PPDU满足下述任意一个条件就是inter-BSS PPDU</p><ul><li>RXVECTOR中参数BSS_COLOR不为0，并且不是STA所属BSS的颜色</li><li>如果PPDU是VHT PPDU，其RXVECTOR参数PARTIAL_AID不等于与STA关联的BSS的BSSID[39:47]，或者在相同的多个BSSID集或共同托管的BSSID中的其他BSS的BSSID[39:47]，并且RXVECTOR中参数GROUP_ID为0（0或者63代表是一个VHT SU PPDU，否则代表VHT MU PPDU）</li><li>如果PPDU是VHT PPDU，其RXVECTOR参数PARTIAL_AID不等于dot11PartialBSSColorImplemented为真的STA所属的BSS宣布的颜色的4 LSBs，同时，当最新HE Operation element中的Partial BSS Color字段为1时，RXVECTOR参数的GROUP_ID等于63</li><li>如果PPDU是VHT MU PPDU或者HE MU PPDU，RXVECTOR参数中UPLINIK_FLAG等于0，并且这个STA是一个AP</li></ul>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Control OBSS/PD Sensitivity Threshold for IEEE 802.11ax BSS Color</title>
      <link href="posts/b9e0ade6.html"/>
      <url>posts/b9e0ade6.html</url>
      
        <content type="html"><![CDATA[<p><strong>参考资料</strong>：<a href="/books/Control_OBSS-PD_Sensitivity_Threshold_for_IEEE_802.11ax_BSS_Color.pdf">Control_OBSS-PD_Sensitivity_Threshold_for_IEEE_802.11ax_BSS_Color.pdf</a></p><p><strong>摘要</strong>：IEEE 802.11ax空间重用（SR）是IEEE 802.11系列中的新类别，旨在提高密集部署中的频谱效率和网络性能。该修订中，主要的（也许是唯一的）SR技术是基本服务集（BSS）颜色。它旨在基于新定义的重叠BSS/前导检测（OBSS/PD）阈值和来自重叠BSS（OBSS）的接收信号强度只是（RSSI），增加特定区域中的并发传输数量。在本文中，提出了一种控制OBSS/PD灵敏度阈值（COST）算法，它基于相关接收者的干扰水平和RSSI。与提出的用来设置OBSS/PD动态灵敏度控制（DSC）算法相反，COST完全了解OBSS的任何变化，并且可以应用于任何IEEE 802.11ax节点。在各种情况下的仿真结果显示，与传统的BSS Color和DSC的保守固定OBSS/PD相比，吞吐量明显提高了57%。</p><h1 id="介绍">1 介绍</h1><p>与蜂窝技术类似，电气和电子工程师协会（IEEE）802.11无线局域网（WLAN）也在不断发展，以适应电信行业面临的快速变化和新的用户期望/需求。移动数据流量的指数增长，连接到互联网的设备数量，新用例以及用户需求是下一代网络的主要挑战。</p><p>由于WLAN技术所提供的成功和优势，预计它将在形成下一代网络中发挥关键作用。特别是，它是一种经济高效的解决方案，可以轻松部署（例如，公寓，办公室等），从而以高数据速率提供对Internet的访问。但是，由于干扰问题，计划外和不受管理的接入点（AP）部署会加剧网络性能。</p><p>为了应对WLAN在2.4 GHz和5 GHz频段上将面临的需求和新挑战，IEEE 802.11ax于2014年推出，目前正在积极开发中。 预计将于2019年下半年完成。</p><p>与之前的旨在提高链路吞吐量的目标相反，任务组802.11ax（TGax）致力于提高密集WLAN场景下的频谱效率和区域吞吐量，同时降低便携式设备的功耗。此外，此修正案将在可用时合并1至7 GHz之间的其他频带。</p><p>向后兼容性是IEEE 802.11ax规范的主要要求之一，因为预计异构设备将以相同的频率运行。 迄今为止，此修订中引入的其他功能包括小型蜂窝网络的改进（更高的调制阶数，1024-QAM），多天线技术（下行链路/上行链路多用户多输入多路）。 输出（DL / UL MU-MIMO），有效利用信道资源（DL / UL正交频分多址（OFDMA）和空间复用（SR）技术。SR机制旨在增加给定区域内的并发传输次数，从而提高区域吞吐量和频谱效率。 通常，SR包括那些适合载波侦听或使用发射功率控制（TPC）的方案。 尽管已经针对无线网络对各种SR方案进行了广泛的研究，但是，IEEE 802.11h-2003仅对TPC的使用进行了标准化。 特别是，IEEE 802.11h-2003定义了区域中最大发射功率的规则。</p><h1 id="相关工作">2 相关工作</h1><p>IEEE 802.11是一种异步技术，该技术依赖于随机访问方法来授予访问权限并通过无线介质进行传输。它使用带冲突避免的载波侦听多路访问（CSMA / CA）协议，这意味着每个节点在传输之前都会感知信道。如果在信道上感测到的能量超过“清除信道评估”（CCA）阈值，则该信道将被识别为“忙”，并且将传输延迟。否则，将该信道声明为“空闲”，并且该节点继续进行帧传输。</p><p>从上面可以清楚地看出，传输的可能性与CCA阈值的值高度相关。低阈值导致较低的传输机会（较大的载波侦听范围），而激进的值可能导致较高的传输机会。类似于CCA阈值，发射功率的水平也会影响发射的可能性。特别地，高发射功率电平的使用使得传输可以被位于远处的节点检测到，这影响了它们的传输机会。</p><p>已经遵循各种方法来调整CCA阈值。  [12]，[13]中提出的算法结合了IEEE 802.11k修正，以获取阈值调整所需的统计信息。此外，节点定期将其测量报告发送到AP，然后AP处理所有报告并通过信标广播此信息。在[14]，[15]中提出了一种用于调整CCA阈值的基于区域的方案，其中分别使用请求发送/清除发送（RTS / CTS）帧或无线控制器， 研究了用于定义节点所属区域的方法。</p>]]></content>
      
      
      <categories>
          
          <category> WIFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS教程</title>
      <link href="posts/612878de.html"/>
      <url>posts/612878de.html</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-教程">1 CSS 教程</h1><p><strong>CSS 是一种描述 HTML 文档样式的语言。</strong></p><p>CSS 描述应该如何显示 HTML 元素。</p><p>本教程将从零起点的基础教程开始，一直到 CSS3 高级教程，为您提供全面系统地讲解。</p><h2 id="每一章中的实例">1.1 每一章中的实例</h2><p>本 CSS 教程包含数百个 CSS 实例。</p><p>通过使用我们的在线编辑器（W3Schoo TIY），您可以编辑 CSS，然后单击运行按钮来查看结果。</p><h3 id="CSS-实例">1.1.1 CSS 实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-color: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1 &#123;</span><br><span class="line">  color: white;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">  font-family: verdana;</span><br><span class="line">  font-size: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_index">亲自试一试</a></p><p>请点击“亲自试一试”按钮来查看它如何运行。</p><h2 id="CSS-实例-1">1.2 CSS 实例</h2><p>从 300 多个实例中学习！使用我们的在线编辑器，您可以编辑 CSS，然后单击运行按钮来查看结果。</p><p><a href="https://www.w3school.com.cn/css/css_examples.asp">访问 CSS 实例！</a></p><h2 id="CSS-习题和测验">1.3 CSS 习题和测验</h2><p>在 W3School 测试您的 CSS 技能！</p><p><a href="https://www.w3school.com.cn/quiz/quiz.asp?f=css">开始 CSS 测验！</a></p><h2 id="CSS-参考手册">1.4 CSS 参考手册</h2><p>在 W3School，您将找到所有属性和选择器的完整 CSS 参考手册，包括语法、示例、浏览器支持等。</p><ul><li><a href="https://www.w3school.com.cn/cssref/index.asp">CSS 参考手册</a></li><li><a href="https://www.w3school.com.cn/cssref/css_browsersupport.asp">CSS 浏览器支持参考手册</a></li><li><a href="https://www.w3school.com.cn/cssref/css_selectors.asp">CSS 选择器参考手册</a></li><li><a href="https://www.w3school.com.cn/cssref/css_functions.asp">CSS 函数参考手册</a></li><li><a href="https://www.w3school.com.cn/cssref/css_animatable.asp">CSS 动画相关属性</a></li><li><a href="https://www.w3school.com.cn/cssref/css_websafe_fonts.asp">CSS 网络安全字体</a></li><li><a href="https://www.w3school.com.cn/cssref/css_fonts_fallbacks.asp">CSS 字体回退</a></li><li><a href="https://www.w3school.com.cn/cssref/css_units.asp">CSS 单位</a></li><li><a href="https://www.w3school.com.cn/cssref/css_colors.asp">CSS 颜色</a></li><li><a href="https://www.w3school.com.cn/cssref/css_colors_legal.asp">CSS 颜色值</a></li><li><a href="https://www.w3school.com.cn/cssref/css_default_values.asp">CSS 默认值</a></li><li><a href="https://www.w3school.com.cn/cssref/css_entities.asp">CSS 实体</a></li><li><a href="https://www.w3school.com.cn/cssref/css_ref_aural.asp">CSS 听觉参考手册</a></li></ul><h1 id="CSS-简介">2 CSS 简介</h1><h2 id="什么是-CSS？">2.1 什么是 CSS？</h2><ul><li><em>CSS</em> 指的是层叠样式表* (<em>C</em>ascading <em>S</em>tyle <em>S</em>heets)</li><li>CSS 描述了<em>如何在屏幕、纸张或其他媒体上显示 HTML 元素</em></li><li>CSS <em>节省了大量工作</em>。它可以同时控制多张网页的布局</li><li>外部样式表存储在 <em>CSS 文件</em>中</li></ul><p>*<strong>：</strong>也称级联样式表。</p><h2 id="CSS-演示-一张-HTML-页面-多个样式！">2.2 CSS 演示 - 一张 HTML 页面 - 多个样式！</h2><p>下面是一张提供了四个不同样式表的 HTML 页面。请单击下面的样式表链接，来查看不同的样式：</p><iframe src="https://www.w3school.com.cn/demo/css/intro.html" style="margin: 0px; padding: 0px; border: none; width: 810px; height: 700px; background: rgb(255, 255, 255);"></iframe><h2 id="为何使用-CSS？">2.3 为何使用 CSS？</h2><p>CSS 用于定义网页的样式，包括针对不同设备和屏幕尺寸的设计和布局。</p><h3 id="CSS-实例-2">2.3.1 CSS 实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-color: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1 &#123;</span><br><span class="line">  color: white;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">  font-family: verdana;</span><br><span class="line">  font-size: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_index">亲自试一试</a></p><h2 id="CSS-解决了一个大问题">2.4 CSS 解决了一个大问题</h2><p>HTML 从未打算包含用于格式化网页的标签！</p><p>创建 HTML 的目的是<em>描述网页</em>的内容，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;这是一个标题。&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;这是一个段落。&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>将 <font> 之类的标签和 color 属性添加到 HTML 3.2 规范后，Web 开发人员的噩梦开始了。大型网站的开发将字体和颜色信息添加到每个页面中，这演变为一个漫长而昂贵的过程。</font></p><p>为了解决这个问题，万维网联盟（W3C）创建了 CSS。</p><p>CSS 从 HTML 页面中删除了样式格式！</p><p>如果您不知道 HTML 是什么，建议您阅读 <a href="https://www.w3school.com.cn/html/index.asp">HTML 教程</a>。</p><h2 id="CSS-节省了大量工作！">2.5 CSS 节省了大量工作！</h2><p>样式定义通常保存在外部 .css 文件中。</p><p>通过使用外部样式表文件，您只需更改一个文件即可更改整个网站的外观！</p><h1 id="CSS-语法">3 CSS 语法</h1><h2 id="CSS-语法-1">3.1 CSS 语法</h2><p>CSS 规则集（rule-set）由选择器和声明块组成：</p><p><img "" class="lazyload placeholder" data-original="https://www.w3school.com.cn/i/css/selector.gif" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="CSS 选择器"></p><p>选择器指向您需要设置样式的 HTML 元素。</p><p>声明块包含一条或多条用分号分隔的声明。</p><p>每条声明都包含一个 CSS 属性名称和一个值，以冒号分隔。</p><p>多条 CSS 声明用分号分隔，声明块用花括号括起来。</p><h3 id="实例">3.1.1 实例</h3><p>在此例中，所有 </p><p> 元素都将居中对齐，并带有红色文本颜色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_syntax_1">亲自试一试</a></p><h3 id="例子解释">3.1.2 例子解释</h3><ul><li>p 是 CSS 中的<em>选择器</em>（它指向要设置样式的 HTML 元素：<p>）。</p></li><li>color 是属性，red 是属性值</li><li>text-align 是属性，center 是属性值</li></ul><p>在下一章中，您将学到更多关于 CSS 选择器和 CSS 属性的知识。</p><h1 id="CSS-选择器">4 CSS 选择器</h1><h2 id="CSS-选择器-1">4.1 CSS 选择器</h2><p>CSS 选择器用于“查找”（或选取）要设置样式的 HTML 元素。</p><p>我们可以将 CSS 选择器分为五类：</p><ul><li>简单选择器（根据名称、id、类来选取元素）</li><li><a href="https://www.w3school.com.cn/css/css_combinators.asp">组合器选择器</a>（根据它们之间的特定关系来选取元素）</li><li><a href="https://www.w3school.com.cn/css/css_pseudo_classes.asp">伪类选择器</a>（根据特定状态选取元素）</li><li><a href="https://www.w3school.com.cn/css/css_pseudo_elements.asp">伪元素选择器</a>（选取元素的一部分并设置其样式）</li><li><a href="https://www.w3school.com.cn/css/css_attribute_selectors.asp">属性选择器</a>（根据属性或属性值来选取元素）</li></ul><p>此页会讲解最基本的 CSS 选择器。</p><h2 id="CSS-元素选择器">4.2 CSS 元素选择器</h2><p>元素选择器根据元素名称来选择 HTML 元素。</p><h3 id="实例-1">4.2.1 实例</h3><p>在这里，页面上的所有 </p><p> 元素都将居中对齐，并带有红色文本颜色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_syntax_element">亲自试一试</a></p><h2 id="CSS-id-选择器">4.3 CSS id 选择器</h2><p>id 选择器使用 HTML 元素的 id 属性来选择特定元素。</p><p>元素的 id 在页面中是唯一的，因此 id 选择器用于选择一个唯一的元素！</p><p>要选择具有特定 id 的元素，请写一个井号（＃），后跟该元素的 id。</p><h3 id="实例-2">4.3.1 实例</h3><p>这条 CSS 规则将应用于 id=”para1” 的 HTML 元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#para1 &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_syntax_id">亲自试一试</a></p><p><strong>注意：</strong>id 名称不能以数字开头。</p><h2 id="CSS-类选择器">4.4 CSS 类选择器</h2><p>类选择器选择有特定 class 属性的 HTML 元素。</p><p>如需选择拥有特定 class 的元素，请写一个句点（.）字符，后面跟类名。</p><h3 id="实例-3">4.4.1 实例</h3><p>在此例中，所有带有 class=”center” 的 HTML 元素将为红色且居中对齐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.center &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_syntax_class">亲自试一试</a></p><p>您还可以指定只有特定的 HTML 元素会受类的影响。</p><h3 id="实例-4">4.4.2 实例</h3><p>在这个例子中，只有具有 class=”center” 的 </p><p> 元素会居中对齐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p.center &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_syntax_element_class_1">亲自试一试</a></p><p>HTML 元素也可以引用多个类。</p><h3 id="实例-5">4.4.3 实例</h3><p>在这个例子中，</p><p> 元素将根据 class=”center” 和 class=”large” 进行样式设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class&#x3D;&quot;center large&quot;&gt;这个段落引用两个类。&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_syntax_element_class_2">亲自试一试</a></p><p><strong>注意：</strong>类名不能以数字开头！</p><h2 id="CSS-通用选择器">4.5 CSS 通用选择器</h2><p>通用选择器（*）选择页面上的所有的 HTML 元素。</p><h3 id="实例-6">4.5.1 实例</h3><p>下面的 CSS 规则会影响页面上的每个 HTML 元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_syntax_universal">亲自试一试</a></p><h2 id="CSS-分组选择器">4.6 CSS 分组选择器</h2><p>分组选择器选取所有具有相同样式定义的 HTML 元素。</p><p>请看下面的 CSS 代码（h1、h2 和 p 元素具有相同的样式定义）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h2 &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好对选择器进行分组，以最大程度地缩减代码。</p><p>如需对选择器进行分组，请用逗号来分隔每个选择器。</p><h3 id="实例-7">4.6.1 实例</h3><p>在这个例子中，我们对上述代码中的选择器进行分组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h1, h2, p &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_grouping">亲自试一试</a></p><h2 id="所有简单的-CSS-选择器">4.7 所有简单的 CSS 选择器</h2><table><thead><tr><th align="left">选择器</th><th align="left">例子</th><th align="left">例子描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/css/css_selectors.asp">.<em>class</em></a></td><td align="left">.intro</td><td align="left">选取所有 class=”intro” 的元素。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/css/css_selectors.asp">#<em>id</em></a></td><td align="left">#firstname</td><td align="left">选取 id=”firstname” 的那个元素。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/css/css_selectors.asp">*</a></td><td align="left">*</td><td align="left">选取所有元素。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/css/css_selectors.asp"><em>element</em></a></td><td align="left">p</td><td align="left">选取所有 <p> 元素。</p></td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/css/css_selectors.asp"><em>element</em>,<em>element</em>,..</a></td><td align="left">div, p</td><td align="left">选取所有 <div> 元素和所有 <p> 元素。</p></div></td></tr></tbody></table><h2 id="延伸阅读">4.8 延伸阅读</h2><p>课外书：<a href="https://www.w3school.com.cn/css/css_selector_type.asp">CSS 元素选择器</a></p><p>课外书：<a href="https://www.w3school.com.cn/css/css_selector_grouping.asp">CSS 选择器分组</a></p><p>课外书：<a href="https://www.w3school.com.cn/css/css_selector_class.asp">CSS 类选择器详解</a></p><p>课外书：<a href="https://www.w3school.com.cn/css/css_selector_id.asp">CSS ID 选择器详解</a></p><p>课外书：<a href="https://www.w3school.com.cn/css/css_selector_attribute.asp">CSS 属性选择器详解</a></p><p>课外书：<a href="https://www.w3school.com.cn/css/css_selector_descendant.asp">CSS 后代选择器</a></p><p>课外书：<a href="https://www.w3school.com.cn/css/css_selector_child.asp">CSS 子元素选择器</a></p><p>课外书：<a href="https://www.w3school.com.cn/css/css_selector_adjacent_sibling.asp">CSS 相邻兄弟选择器</a></p><h1 id="如何添加-CSS">5 如何添加 CSS</h1><p><strong>当浏览器读到样式表时，它将根据样式表中的信息来格式化 HTML 文档。</strong></p><h2 id="三种使用-CSS-的方法">5.1 三种使用 CSS 的方法</h2><p>有三种插入样式表的方法：</p><ul><li>外部 CSS</li><li>内部 CSS</li><li>行内 CSS</li></ul><h2 id="外部-CSS">5.2 外部 CSS</h2><p>通过使用外部样式表，您只需修改一个文件即可改变整个网站的外观！</p><p>每张 HTML 页面必须在 head 部分的 <link> 元素内包含对外部样式表文件的引用。</p><h3 id="实例-8">5.2.1 实例</h3><p>外部样式在 HTML 页面 <head> 部分内的 <link> 元素中进行定义：</head></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;mystyle.css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;This is a heading&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;p&gt;This is a paragraph.&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_howto_external">亲自试一试</a></p><p>外部样式表可以在任何文本编辑器中编写，并且必须以 .css 扩展名保存。</p><p>外部 .css 文件不应包含任何 HTML 标签。</p><p>“mystyle.css” 是这样的：</p><h3 id="“mystyle-css”">5.2.2 “mystyle.css”</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-color: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1 &#123;</span><br><span class="line">  color: navy;</span><br><span class="line">  margin-left: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>请勿在属性值和单位之间添加空格（例如 <strong>margin-left: 20 px;<strong>）。正确的写法是：</strong>margin-left: 20px;</strong></p><h2 id="内部-CSS">5.3 内部 CSS</h2><p>如果一张 HTML 页面拥有唯一的样式，那么可以使用内部样式表。</p><p>内部样式是在 head 部分的 <style> 元素中进行定义。</p><h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><p>内部样式在 HTML 页面的 <head> 部分内的 <style> 元素中进行定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">body &#123;</span><br><span class="line">  background-color: linen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1 &#123;</span><br><span class="line">  color: maroon;</span><br><span class="line">  margin-left: 40px;</span><br><span class="line">&#125; </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;This is a heading&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;p&gt;This is a paragraph.&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_howto_internal">亲自试一试</a></p><h2 id="行内-CSS"><a href="#行内-CSS" class="headerlink" title="行内 CSS"></a>行内 CSS</h2><p>行内样式（也称内联样式）可用于为单个元素应用唯一的样式。</p><p>如需使用行内样式，请将 style 属性添加到相关元素。style 属性可包含任何 CSS 属性。</p><h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><p>行内样式在相关元素的 “style” 属性中定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1 style&#x3D;&quot;color:blue;text-align:center;&quot;&gt;This is a heading&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;p style&#x3D;&quot;color:red;&quot;&gt;This is a paragraph.&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_howto_inline">亲自试一试</a></p><p><strong>提示：</strong>行内样式失去了样式表的许多优点（通过将内容与呈现混合在一起）。请谨慎使用此方法。</p><h2 id="多个样式表"><a href="#多个样式表" class="headerlink" title="多个样式表"></a>多个样式表</h2><p>如果在不同样式表中为同一选择器（元素）定义了一些属性，则将使用最后读取的样式表中的值。</p><p>假设某个<em>外部样式表</em>为 <h1> 元素设定的如下样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;</span><br><span class="line">  color: navy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，假设某个<em>内部样式表</em>也为 <h1> 元素设置了如下样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;</span><br><span class="line">  color: orange;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h3><p>如果内部样式是在链接到外部样式表<em>之后</em>定义的，则 <h1> 元素将是橙色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;mystyle.css&quot;&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">h1 &#123;</span><br><span class="line">  color: orange;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_howto_multiple_1">亲自试一试</a></p><h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><p>不过，如果在链接到外部样式表<em>之前</em>定义了内部样式，则 <h1> 元素将是深蓝色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">h1 &#123;</span><br><span class="line">  color: orange;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;mystyle.css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_howto_multiple_2">亲自试一试</a></p><h2 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h2><p>当为某个 HTML 元素指定了多个样式时，会使用哪种样式呢？</p><p>页面中的所有样式将按照以下规则“层叠”为新的“虚拟”样式表，其中第一优先级最高：</p><ol><li>行内样式（在 HTML 元素中）</li><li>外部和内部样式表（在 head 部分）</li><li>浏览器默认样式</li></ol><p>因此，行内样式具有最高优先级，并且将覆盖外部和内部样式以及浏览器默认样式。</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_howto_cascade">亲自试一试</a></p><h1 id="CSS-注释"><a href="#CSS-注释" class="headerlink" title="CSS 注释"></a>CSS 注释</h1><h2 id="CSS-注释-1"><a href="#CSS-注释-1" class="headerlink" title="CSS 注释"></a>CSS 注释</h2><p>注释用于解释代码，以后在您编辑源代码时可能会有所帮助。</p><p>浏览器会忽略注释。</p><p>位于 <style> 元素内的 CSS 注释，以 /* 开始，以 */ 结束：</p><h3 id="实例-13"><a href="#实例-13" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 这是一条单行注释 *&#x2F;</span><br><span class="line">p &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_comments_1">亲自试一试</a></p><p>您可以在代码中的任何位置添加注释：</p><h3 id="实例-14"><a href="#实例-14" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  color: red;  &#x2F;* 把文本设置为红色 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_comments_2">亲自试一试</a></p><p>注释能横跨多行：</p><h3 id="实例-15"><a href="#实例-15" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 这是</span><br><span class="line">一条多行的</span><br><span class="line">注释 *&#x2F; </span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_comments_3">亲自试一试</a></p><h2 id="HTML-和-CSS-注释"><a href="#HTML-和-CSS-注释" class="headerlink" title="HTML 和 CSS 注释"></a>HTML 和 CSS 注释</h2><p>从 HTML 教程中，您学习到可以使用 <!--...--> 语法在 HTML 源代码中添加注释。</p><p>在下面的例子中，我们结合使用了 HTML 和 CSS 注释：</p><h3 id="实例-16"><a href="#实例-16" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">p &#123;</span><br><span class="line">  color: red; &#x2F;* 将文字颜色设置为红色 *&#x2F;</span><br><span class="line">&#125; </span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;My Heading&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 这些段落将是红色的 --&gt;</span><br><span class="line">&lt;p&gt;Hello World!&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;这段文本由 CSS 设置样式。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;CSS 注释不会在输出中显示。&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_comments_4">亲自试一试</a></p><h1 id="CSS-颜色"><a href="#CSS-颜色" class="headerlink" title="CSS 颜色"></a>CSS 颜色</h1><p><strong>指定颜色是通过使用预定义的颜色名称，或 RGB、HEX、HSL、RGBA、HSLA 值。</strong></p><h2 id="CSS-颜色名"><a href="#CSS-颜色名" class="headerlink" title="CSS 颜色名"></a>CSS 颜色名</h2><p>在 CSS 中，可以使用颜色名称来指定颜色：</p><p>Tomato</p><p>Orange</p><p>DodgerBlue</p><p>MediumSeaGreen</p><p>Gray</p><p>SlateBlue</p><p>Violet</p><p>LightGray</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_color_names">亲自试一试</a></p><p>CSS/HTML 支持 <a href="https://www.w3school.com.cn/css/css_colors.asp">140 种标准颜色名</a>。</p><h2 id="CSS-背景色"><a href="#CSS-背景色" class="headerlink" title="CSS 背景色"></a>CSS 背景色</h2><p>您可以为 HTML 元素设置背景色：</p><p>Welcome to China</p><p>China is a great country!</p><h3 id="实例-17"><a href="#实例-17" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 style&#x3D;&quot;background-color:DodgerBlue;&quot;&gt;China&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;p style&#x3D;&quot;background-color:Tomato;&quot;&gt;China is a great country!&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_color_background">亲自试一试</a></p><h2 id="CSS-文本颜色"><a href="#CSS-文本颜色" class="headerlink" title="CSS 文本颜色"></a>CSS 文本颜色</h2><p>您可以设置文本的颜色：</p><h3 id="China"><a href="#China" class="headerlink" title="China"></a>China</h3><p>China is a great country!</p><p>China, officially the People’s Republic of China, is a country in East Asia.</p><h3 id="实例-18"><a href="#实例-18" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 style&#x3D;&quot;color:Tomato;&quot;&gt;China&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;p style&#x3D;&quot;color:DodgerBlue;&quot;&gt;China is a great country!&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p style&#x3D;&quot;color:MediumSeaGreen;&quot;&gt;China, officially the People&#39;s Republic of China...&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_color_text">亲自试一试</a></p><h2 id="CSS-边框颜色"><a href="#CSS-边框颜色" class="headerlink" title="CSS 边框颜色"></a>CSS 边框颜色</h2><p>您可以设置边框的颜色：</p><p>Hello World</p><p>Hello World</p><p>Hello World</p><h3 id="实例-19"><a href="#实例-19" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 style&#x3D;&quot;border:2px solid Tomato;&quot;&gt;Hello World&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;h1 style&#x3D;&quot;border:2px solid DodgerBlue;&quot;&gt;Hello World&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;h1 style&#x3D;&quot;border:2px solid Violet;&quot;&gt;Hello World&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_color_border">亲自试一试</a></p><h2 id="CSS-颜色值"><a href="#CSS-颜色值" class="headerlink" title="CSS 颜色值"></a>CSS 颜色值</h2><p>在 CSS 中，还可以使用 RGB 值、HEX 值、HSL 值、RGBA 值或者 HSLA 值来指定颜色：</p><p>与颜色名 “Tomato” 等效：</p><p>rgb(255, 99, 71)</p><p>#ff6347</p><p>hsl(9, 100%, 64%)</p><p>与颜色名 “Tomato” 等效，但是透明度为 50%：</p><p>rgba(255, 99, 71, 0.5)</p><p>hsla(9, 100%, 64%, 0.5)</p><h3>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 style&#x3D;&quot;background-color:rgb(255, 99, 71);&quot;&gt;...&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;h1 style&#x3D;&quot;background-color:#ff6347;&quot;&gt;...&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;h1 style&#x3D;&quot;background-color:hsl(9, 100%, 64%);&quot;&gt;...&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1 style&#x3D;&quot;background-color:rgba(255, 99, 71, 0.5);&quot;&gt;...&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;h1 style&#x3D;&quot;background-color:hsla(9, 100%, 64%, 0.5);&quot;&gt;...&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_color_values">亲自试一试</a></p><p>了解有关颜色值的更多信息</p><p>在下一章中，您将学习有关 <a href="https://www.w3school.com.cn/css/css_colors.asp">RGB</a>、<a href="https://www.w3school.com.cn/css/css_colors.asp">HEX</a> 和 <a href="https://www.w3school.com.cn/css/css_colors.asp">HSL</a> 的更多知识。</p><h1 id="CSS-RGB-颜色"><a href="#CSS-RGB-颜色" class="headerlink" title="CSS RGB 颜色"></a>CSS RGB 颜色</h1><h2 id="RGB-值"><a href="#RGB-值" class="headerlink" title="RGB 值"></a>RGB 值</h2><p>在 CSS 中，可以使用下面的公式将颜色指定为 RGB 值：</p><h3 id="rgb-red-green-blue"><a href="#rgb-red-green-blue" class="headerlink" title="rgb(red, green, blue)"></a>rgb(<em>red</em>, <em>green</em>, <em>blue</em>)</h3><p>每个参数 (<em>red</em>、<em>green</em> 以及 <em>blue</em>) 定义了 0 到 255 之间的颜色强度。</p><p>例如，rgb(255, 0, 0) 显示为红色，因为红色设置为最大值（255），其他设置为 0。</p><p>要显示黑色，请将所有颜色参数设置为 0，如下所示：rgb(0, 0, 0)。</p><p>要显示白色，请将所有颜色参数设置为 255，如下所示：rgb(255, 255, 255)。</p><p>请通过混合以下 RGB 值来进行实验：</p><p>rgb(255, 99, 71)</p><h3 id="RED"><a href="#RED" class="headerlink" title="RED"></a>RED</h3><p>255</p><h3 id="GREEN"><a href="#GREEN" class="headerlink" title="GREEN"></a>GREEN</h3><p>99</p><h3 id="BLUE"><a href="#BLUE" class="headerlink" title="BLUE"></a>BLUE</h3><p>71</p><h3 id="实例-20"><a href="#实例-20" class="headerlink" title="实例"></a>实例</h3><p>rgb(255, 0, 0)</p><p>rgb(0, 0, 255)</p><p>rgb(60, 179, 113)</p><p>rgb(238, 130, 238)</p><p>rgb(255, 165, 0)</p><p>rgb(106, 90, 205)</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_color_rgb">亲自试一试</a></p><p>通常为所有 3 个光源使用相等的值来定义灰色阴影：</p><h3 id="实例-21"><a href="#实例-21" class="headerlink" title="实例"></a>实例</h3><p>rgb(0, 0, 0)</p><p>rgb(60, 60, 60)</p><p>rgb(120, 120, 120)</p><p>rgb(180, 180, 180)</p><p>rgb(240, 240, 240)</p><p>rgb(255, 255, 255)</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_color_rgb_gray">亲自试一试</a></p><h2 id="RGBA-值"><a href="#RGBA-值" class="headerlink" title="RGBA 值"></a>RGBA 值</h2><p>RGBA 颜色值是具有 alpha 通道的 RGB 颜色值的扩展 - 它指定了颜色的不透明度。</p><p>RGBA 颜色值指定为：</p><h3 id="rgba-red-green-blue-alpha"><a href="#rgba-red-green-blue-alpha" class="headerlink" title="rgba(red, green, blue, alpha)"></a>rgba(<em>red</em>, <em>green</em>, <em>blue</em>, <em>alpha</em>)</h3><p><em>alpha</em> 参数是介于 0.0（完全透明）和 1.0（完全不透明）之间的数字：</p><p>请通过混合以下 RGBA 值来进行实验：</p><p>rgba(255, 99, 71, 0.5)</p><h3 id="RED-1"><a href="#RED-1" class="headerlink" title="RED"></a>RED</h3><p>255</p><h3 id="GREEN-1"><a href="#GREEN-1" class="headerlink" title="GREEN"></a>GREEN</h3><p>99</p><h3 id="BLUE-1"><a href="#BLUE-1" class="headerlink" title="BLUE"></a>BLUE</h3><p>71</p><h3 id="ALPHA"><a href="#ALPHA" class="headerlink" title="ALPHA"></a>ALPHA</h3><p>0.5</p><h3 id="实例-22"><a href="#实例-22" class="headerlink" title="实例"></a>实例</h3><p>rgba(255, 99, 71, 0)</p><p>rgba(255, 99, 71, 0.2)</p><p>rgba(255, 99, 71, 0.4)</p><p>rgba(255, 99, 71, 0.6)</p><p>rgba(255, 99, 71, 0.8)</p><p>rgba(255, 99, 71, 1)</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_color_rgba">亲自试一试</a></p><h1 id="CSS-HEX-颜色"><a href="#CSS-HEX-颜色" class="headerlink" title="CSS HEX 颜色"></a>CSS HEX 颜色</h1><h2 id="HEX-值"><a href="#HEX-值" class="headerlink" title="HEX 值"></a>HEX 值</h2><p>在 CSS 中，可以使用以下格式的十六进制值指定颜色：</p><h3 id="rrggbb"><a href="#rrggbb" class="headerlink" title="#rrggbb"></a>#<em>rrggbb</em></h3><p>其中 rr（红色）、gg（绿色）和 bb（蓝色）是介于 00 和 ff 之间的十六进制值（与十进制 0-255 相同）。</p><p>例如，#ff0000 显示为红色，因为红色设置为最大值（ff），其他设置为最小值（00）。</p><p>请通过混合以下十六进制值来进行实验：</p><p>#ff6347</p><h3 id="RED-2"><a href="#RED-2" class="headerlink" title="RED"></a>RED</h3><p>ff</p><h3 id="GREEN-2"><a href="#GREEN-2" class="headerlink" title="GREEN"></a>GREEN</h3><p>63</p><h3 id="BLUE-2"><a href="#BLUE-2" class="headerlink" title="BLUE"></a>BLUE</h3><p>47</p><h3 id="实例-23"><a href="#实例-23" class="headerlink" title="实例"></a>实例</h3><p>#ff0000</p><p>#0000ff</p><p>#3cb371</p><p>#ee82ee</p><p>#ffa500</p><p>#6a5acd</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_color_hex">亲自试一试</a></p><p>通常为所有 3 个光源使用相等的值来定义灰色阴影：</p><h3 id="实例-24"><a href="#实例-24" class="headerlink" title="实例"></a>实例</h3><p>#000000</p><p>#3c3c3c</p><p>#787878</p><p>#b4b4b4</p><p>#f0f0f0</p><p>#ffffff</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_color_hex_gray">亲自试一试</a></p><h1 id="CSS-HSL-颜色"><a href="#CSS-HSL-颜色" class="headerlink" title="CSS HSL 颜色"></a>CSS HSL 颜色</h1><h2 id="HSL-值"><a href="#HSL-值" class="headerlink" title="HSL 值"></a>HSL 值</h2><p>在 CSS 中，可以使用色相、饱和度和明度（HSL）来指定颜色，格式如下：</p><h3 id="hsla-hue-saturation-lightness"><a href="#hsla-hue-saturation-lightness" class="headerlink" title="hsla(hue, saturation, lightness)"></a>hsla(<em>hue</em>, <em>saturation</em>, <em>lightness</em>)</h3><p>色相（<em>hue</em>）是色轮上从 0 到 360 的度数。0 是红色，120 是绿色，240 是蓝色。</p><p>饱和度（<em>saturation</em>）是一个百分比值，0％ 表示灰色阴影，而 100％ 是全色。</p><p>亮度（<em>lightness</em>）也是百分比，0％ 是黑色，50％ 是既不明也不暗，100％是白色。</p><p>请通过混合以下 HSL 值来进行实验：</p><p>hsl(0, 100%, 50%)</p><h3 id="HUE"><a href="#HUE" class="headerlink" title="HUE"></a>HUE</h3><p>0</p><h3 id="SATURATION"><a href="#SATURATION" class="headerlink" title="SATURATION"></a>SATURATION</h3><p>100%</p><h3 id="LIGHTNESS"><a href="#LIGHTNESS" class="headerlink" title="LIGHTNESS"></a>LIGHTNESS</h3><p>50%</p><h3 id="实例-25"><a href="#实例-25" class="headerlink" title="实例"></a>实例</h3><p>hsl(0, 100%, 50%)</p><p>hsl(240, 100%, 50%)</p><p>hsl(147, 50%, 47%)</p><p>hsl(300, 76%, 72%)</p><p>hsl(39, 100%, 50%)</p><p>hsl(248, 53%, 58%)</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_color_hsl">亲自试一试</a></p><h2 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h2><p>饱和度可以描述为颜色的强度。</p><p>100％ 是纯色，没有灰色阴影</p><p>50％ 是 50％ 灰色，但是您仍然可以看到颜色。</p><p>0％ 是完全灰色，您无法再看到颜色。</p><h3 id="实例-26"><a href="#实例-26" class="headerlink" title="实例"></a>实例</h3><p>hsl(0, 100%, 50%)</p><p>hsl(0, 80%, 50%)</p><p>hsl(0, 60%, 50%)</p><p>hsl(0, 40%, 50%)</p><p>hsl(0, 20%, 50%)</p><p>hsl(0, 0%, 50%)</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_color_hsl_saturation">亲自试一试</a></p><h2 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h2><p>颜色的明暗度可以描述为要赋予颜色多少光，其中 0％ 表示不亮（黑色），50％ 表示 50％ 亮（既不暗也不亮），100％ 表示全明（白）。</p><h3 id="实例-27"><a href="#实例-27" class="headerlink" title="实例"></a>实例</h3><p>hsl(0, 100%, 0%)</p><p>hsl(0, 100%, 25%)</p><p>hsl(0, 100%, 50%)</p><p>hsl(0, 100%, 75%)</p><p>hsl(0, 100%, 90%)</p><p>hsl(0, 100%, 100%)</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_color_hsl_lightness">亲自试一试</a></p><p>通常通过将色调和饱和度设置为 0 来定义灰色阴影，并将亮度从 0％ 到 100％ 进行调整可以得到更深/更浅的阴影：</p><h3 id="实例-28"><a href="#实例-28" class="headerlink" title="实例"></a>实例</h3><p>hsl(0, 0%, 0%)</p><p>hsl(0, 0%, 24%)</p><p>hsl(0, 0%, 47%)</p><p>hsl(0, 0%, 71%)</p><p>hsl(0, 0%, 94%)</p><p>hsl(0, 0%, 100%)</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_color_hsl_gray">亲自试一试</a></p><h2 id="HSLA-值"><a href="#HSLA-值" class="headerlink" title="HSLA 值"></a>HSLA 值</h2><p>HSLA 颜色值是带有 Alpha 通道的 HSL 颜色值的扩展 - 它指定了颜色的不透明度。</p><p>HSLA 颜色值指定为：</p><h3 id="hsla-hue-saturation-lightness-alpha"><a href="#hsla-hue-saturation-lightness-alpha" class="headerlink" title="hsla(hue, saturation, lightness, alpha)"></a>hsla(<em>hue</em>, <em>saturation</em>, <em>lightness</em>, <em>alpha</em>)</h3><p><em>alpha</em> 参数是介于 0.0（完全透明）和 1.0（完全不透明）之间的数字：</p><p>请通过混合以下 HSLA 值进行实验：</p><p>hsla(0, 100%, 50%, 0.5)</p><h3 id="HUE-1"><a href="#HUE-1" class="headerlink" title="HUE"></a>HUE</h3><p>0</p><h3 id="SATURATION-1"><a href="#SATURATION-1" class="headerlink" title="SATURATION"></a>SATURATION</h3><p>100%</p><h3 id="LIGHTNESS-1"><a href="#LIGHTNESS-1" class="headerlink" title="LIGHTNESS"></a>LIGHTNESS</h3><p>50%</p><h3 id="ALPHA-1"><a href="#ALPHA-1" class="headerlink" title="ALPHA"></a>ALPHA</h3><p>0.5</p><h3 id="实例-29"><a href="#实例-29" class="headerlink" title="实例"></a>实例</h3><p>hsla(9, 100%, 64%, 0)</p><p>hsla(9, 100%, 64%, 0.2)</p><p>hsla(9, 100%, 64%, 0.4)</p><p>hsla(9, 100%, 64%, 0.6)</p><p>hsla(9, 100%, 64%, 0.8)</p><p>hsla(9, 100%, 64%, 1)</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_color_hsla">亲自试一试</a></p><h1 id="CSS-背景"><a href="#CSS-背景" class="headerlink" title="CSS 背景"></a>CSS 背景</h1><p>CSS 背景属性用于定义元素的背景效果。</p><p>在这些章节中，您将学习如下 CSS 背景属性：</p><ul><li>background-color</li><li>background-image</li><li>background-repeat</li><li>background-attachment</li><li>background-position</li></ul><h2 id="CSS-background-color"><a href="#CSS-background-color" class="headerlink" title="CSS background-color"></a>CSS background-color</h2><p>background-color 属性指定元素的背景色。</p><h3 id="实例-30"><a href="#实例-30" class="headerlink" title="实例"></a>实例</h3><p>页面的背景色设置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-color: lightblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_background-color_body">亲自试一试</a></p><p>通过 CSS，颜色通常由以下方式指定：</p><ul><li>有效的颜色名称 - 比如 “red”</li><li>十六进制值 - 比如 “#ff0000”</li><li>RGB 值 - 比如 “rgb(255,0,0)”</li></ul><p>请查看 <a href="https://www.w3school.com.cn/cssref/css_colors_legal.asp">CSS 颜色值</a>，获取可能颜色值的完整列表。</p><h2 id="其他元素"><a href="#其他元素" class="headerlink" title="其他元素"></a>其他元素</h2><p>您可以为任何 HTML 元素设置背景颜色：</p><h3 id="实例-31"><a href="#实例-31" class="headerlink" title="实例"></a>实例</h3><p>在这里，<h1>、<p> 和 <div> 元素将拥有不同的背景色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;</span><br><span class="line">  background-color: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div &#123;</span><br><span class="line">  background-color: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p &#123;</span><br><span class="line">  background-color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_background-color_elements">亲自试一试</a></p><h2 id="不透明度-透明度"><a href="#不透明度-透明度" class="headerlink" title="不透明度 / 透明度"></a>不透明度 / 透明度</h2><p>opacity 属性指定元素的不透明度/透明度。取值范围为 0.0 - 1.0。值越低，越透明：</p><p>opacity 1</p><p>opacity 0.6</p><p>opacity 0.3</p><p>opacity 0.1</p><h3 id="实例-32"><a href="#实例-32" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  background-color: green;</span><br><span class="line">  opacity: 0.3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_background_opacity_1">亲自试一试</a></p><p><strong>注意：</strong>使用 <strong>opacity</strong> 属性为元素的背景添加透明度时，其所有子元素都继承相同的透明度。这可能会使完全透明的元素内的文本难以阅读。</p><h2 id="使用-RGBA-的透明度"><a href="#使用-RGBA-的透明度" class="headerlink" title="使用 RGBA 的透明度"></a>使用 RGBA 的透明度</h2><p>如果您不希望对子元素应用不透明度，例如上面的例子，请使用 <em>RGBA</em> 颜色值。下面的例子设置背景色而不是文本的不透明度：</p><p>100% opacity</p><p>60% opacity</p><p>30% opacity</p><p>10% opacity</p><p>您从我们的 <a href="https://www.w3school.com.cn/css/css_background.asp">CSS 颜色</a> 章节中学到了可以将 RGB 用作颜色值。除 RGB 外，还可以将 RGB 颜色值与 <em>alpha</em> 通道一起使用（RGB<em>A</em>） - 该通道指定颜色的不透明度。</p><p>RGBA 颜色值指定为：rgba(<em>red</em>, <em>green</em>, <em>blue</em>, <em>alpha</em>)。<em>alpha</em> 参数是介于 0.0（完全透明）和 1.0（完全不透明）之间的数字。</p><p><strong>提示：</strong>您可在我们的 <a href="https://www.w3school.com.cn/css/css_background.asp">CSS 颜色</a> 一章中学到有关 RGBA 颜色的更多知识。</p><h3 id="实例-33"><a href="#实例-33" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  background: rgba(0, 128, 0, 0.3) &#x2F;* 30% 不透明度的绿色背景 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_background_opacity_2">亲自试一试</a></p><h1 id="CSS-背景图像"><a href="#CSS-背景图像" class="headerlink" title="CSS 背景图像"></a>CSS 背景图像</h1><h2 id="CSS-背景图像-1"><a href="#CSS-背景图像-1" class="headerlink" title="CSS 背景图像"></a>CSS 背景图像</h2><p>background-image 属性指定用作元素背景的图像。</p><p>默认情况下，图像会重复，以覆盖整个元素。</p><h3 id="实例-34"><a href="#实例-34" class="headerlink" title="实例"></a>实例</h3><p>页面的背景图像可以像这样设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-image: url(&quot;paper.gif&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_background-image">亲自试一试</a></p><h3 id="实例-35"><a href="#实例-35" class="headerlink" title="实例"></a>实例</h3><p>本例展示了文本和背景图像的<em>错误组合</em>。文字难以阅读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-image: url(&quot;bgdesert.jpg&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_background-image_bad">亲自试一试</a></p><p><strong>注意：</strong>使用背景图像时，请使用不会干扰文本的图像。</p><p>还可以为特定元素设置背景图像，例如 <p> 元素：</p><h3 id="实例-36"><a href="#实例-36" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">  background-image: url(&quot;paper.gif&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_background-image_p">亲自试一试</a></p><h1 id="CSS-背景重复"><a href="#CSS-背景重复" class="headerlink" title="CSS 背景重复"></a>CSS 背景重复</h1><h2 id="CSS-background-repeat"><a href="#CSS-background-repeat" class="headerlink" title="CSS background-repeat"></a>CSS background-repeat</h2><p>默认情况下，background-image 属性在水平和垂直方向上都重复图像。</p><p>某些图像应只适合水平或垂直方向上重复，否则它们看起来会很奇怪，如下所示：</p><h3 id="实例-37"><a href="#实例-37" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-image: url(&quot;gradient_bg.png&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_background-image_gradient_1">亲自试一试</a></p><p>如果上面的图像仅在水平方向重复 (background-repeat: repeat-x;)，则背景看起来会更好：</p><h3 id="实例-38"><a href="#实例-38" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-image: url(&quot;gradient_bg.png&quot;);</span><br><span class="line">  background-repeat: repeat-x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_background-image_gradient_2">亲自试一试</a></p><p><strong>提示：</strong>如需垂直重复图像，请设置 background-repeat: repeat-y;</p><h2 id="CSS-background-repeat-no-repeat"><a href="#CSS-background-repeat-no-repeat" class="headerlink" title="CSS background-repeat: no-repeat"></a>CSS background-repeat: no-repeat</h2><p>background-repeat 属性还可指定只显示一次背景图像：</p><h3 id="实例-39"><a href="#实例-39" class="headerlink" title="实例"></a>实例</h3><p>背景图像仅显示一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-image: url(&quot;tree.png&quot;);</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_background-image_norepeat">亲自试一试</a></p><p>在上例中，背景图像与文本放置在同一位置。我们想要更改图像的位置，以免图像过多干扰文本。</p><h2 id="CSS-background-position"><a href="#CSS-background-position" class="headerlink" title="CSS background-position"></a>CSS background-position</h2><p>background-position 属性用于指定背景图像的位置。</p><h3 id="实例-40"><a href="#实例-40" class="headerlink" title="实例"></a>实例</h3><p>把背景图片放在右上角：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-image: url(&quot;tree.png&quot;);</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-position: right top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_background-image_position">亲自试一试</a></p><h1 id="CSS-背景附着"><a href="#CSS-背景附着" class="headerlink" title="CSS 背景附着"></a>CSS 背景附着</h1><h2 id="CSS-background-attachment"><a href="#CSS-background-attachment" class="headerlink" title="CSS background-attachment"></a>CSS background-attachment</h2><p>background-attachment 属性指定背景图像是应该滚动还是固定的（不会随页面的其余部分一起滚动）：</p><h3 id="实例-41"><a href="#实例-41" class="headerlink" title="实例"></a>实例</h3><p>指定应该固定背景图像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-image: url(&quot;tree.png&quot;);</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-position: right top;</span><br><span class="line">  background-attachment: fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_background-image_attachment_1">亲自试一试</a></p><h3 id="实例-42"><a href="#实例-42" class="headerlink" title="实例"></a>实例</h3><p>指定背景图像应随页面的其余部分一起滚动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-image: url(&quot;tree.png&quot;);</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-position: right top;</span><br><span class="line">  background-attachment: scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_background-image_attachment_2">亲自试一试</a></p><h1 id="CSS-背景简写"><a href="#CSS-背景简写" class="headerlink" title="CSS 背景简写"></a>CSS 背景简写</h1><h2 id="CSS-background-简写属性"><a href="#CSS-background-简写属性" class="headerlink" title="CSS background - 简写属性"></a>CSS background - 简写属性</h2><p>如需缩短代码，也可以在一个属性中指定所有背景属性。它被称为简写属性。</p><p>而不是这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background-color: #ffffff;</span><br><span class="line">  background-image: url(&quot;tree.png&quot;);</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-position: right top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您能够使用简写属性 <code>background</code>：</p><h3 id="实例-43"><a href="#实例-43" class="headerlink" title="实例"></a>实例</h3><p>使用简写属性在一条声明中设置背景属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background: #ffffff url(&quot;tree.png&quot;) no-repeat right top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_background_shorthand">亲自试一试</a></p><p>在使用简写属性时，属性值的顺序为：</p><ul><li>background-color</li><li>background-image</li><li>background-repeat</li><li>background-attachment</li><li>background-position</li></ul><p>属性值之一缺失并不要紧，只要按照此顺序设置其他值即可。请注意，在上面的例子中，我们没有使用 background-attachment 属性，因为它没有值。</p><h2 id="所有-CSS-背景属性"><a href="#所有-CSS-背景属性" class="headerlink" title="所有 CSS 背景属性"></a>所有 CSS 背景属性</h2><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/cssref/pr_background.asp">background</a></td><td align="left">在一条声明中设置所有背景属性的简写属性。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/cssref/pr_background-attachment.asp">background-attachment</a></td><td align="left">设置背景图像是固定的还是与页面的其余部分一起滚动。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/cssref/pr_background-clip.asp">background-clip</a></td><td align="left">规定背景的绘制区域。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/cssref/pr_background-color.asp">background-color</a></td><td align="left">设置元素的背景色。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/cssref/pr_background-image.asp">background-image</a></td><td align="left">设置元素的背景图像。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/cssref/pr_background-origin.asp">background-origin</a></td><td align="left">规定在何处放置背景图像。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/cssref/pr_background-position.asp">background-position</a></td><td align="left">设置背景图像的开始位置。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/cssref/pr_background-repeat.asp">background-repeat</a></td><td align="left">设置背景图像是否及如何重复。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/cssref/pr_background-size.asp">background-size</a></td><td align="left">规定背景图像的尺寸。</td></tr></tbody></table><h1 id="CSS-边框"><a href="#CSS-边框" class="headerlink" title="CSS 边框"></a>CSS 边框</h1><h2 id="CSS-边框属性"><a href="#CSS-边框属性" class="headerlink" title="CSS 边框属性"></a>CSS 边框属性</h2><p>CSS border 属性允许您指定元素边框的样式、宽度和颜色。</p><p>我的所有边都有边框。</p><p>我有一条红色的下边框。</p><p>我有圆角边框。</p><p>我有一条蓝色的左边框。</p><h2 id="CSS-边框样式"><a href="#CSS-边框样式" class="headerlink" title="CSS 边框样式"></a>CSS 边框样式</h2><p>border-style 属性指定要显示的边框类型。</p><p>允许以下值：</p><ul><li>dotted - 定义点线边框</li><li>dashed - 定义虚线边框</li><li>solid - 定义实线边框</li><li>double - 定义双边框</li><li>groove - 定义 3D 坡口边框。效果取决于 border-color 值</li><li>ridge - 定义 3D 脊线边框。效果取决于 border-color 值</li><li>inset - 定义 3D inset 边框。效果取决于 border-color 值</li><li>outset - 定义 3D outset 边框。效果取决于 border-color 值</li><li>none - 定义无边框</li><li>hidden - 定义隐藏边框</li></ul><p>border-style 属性可以设置一到四个值（用于上边框、右边框、下边框和左边框）。</p><h3 id="实例-44"><a href="#实例-44" class="headerlink" title="实例"></a>实例</h3><p>演示不同的边框样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.dotted &#123;border-style: dotted;&#125;</span><br><span class="line">p.dashed &#123;border-style: dashed;&#125;</span><br><span class="line">p.solid &#123;border-style: solid;&#125;</span><br><span class="line">p.double &#123;border-style: double;&#125;</span><br><span class="line">p.groove &#123;border-style: groove;&#125;</span><br><span class="line">p.ridge &#123;border-style: ridge;&#125;</span><br><span class="line">p.inset &#123;border-style: inset;&#125;</span><br><span class="line">p.outset &#123;border-style: outset;&#125;</span><br><span class="line">p.none &#123;border-style: none;&#125;</span><br><span class="line">p.hidden &#123;border-style: hidden;&#125;</span><br><span class="line">p.mix &#123;border-style: dotted dashed solid double;&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>点状边框。</p><p>虚线边框。</p><p>实线边框。</p><p>双线边框。</p><p>凹槽边框。其效果取决于 border-color 的值。</p><p>垄状边框。其效果取决于 border-color 的值。</p><p>3D inset 边框。其效果取决于 border-color 的值。</p><p>3D outset 边框。其效果取决于 border-color 的值。</p><p>无边框。</p><p>隐藏边框。</p><p>混合边框。</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_border-style">亲自试一试</a></p><p><strong>注意：</strong>除非设置了 <strong>border-style</strong> 属性，否则其他 CSS 边框属性（将在下一章中详细讲解）都不会有任何作用！</p><h1 id="CSS-边框宽度"><a href="#CSS-边框宽度" class="headerlink" title="CSS 边框宽度"></a>CSS 边框宽度</h1><h2 id="CSS-边框宽度-1"><a href="#CSS-边框宽度-1" class="headerlink" title="CSS 边框宽度"></a>CSS 边框宽度</h2><p>border-width 属性指定四个边框的宽度。</p><p>可以将宽度设置为特定大小（以 px、pt、cm、em 计），也可以使用以下三个预定义值之一：thin、medium 或 thick：</p><h3 id="实例-45"><a href="#实例-45" class="headerlink" title="实例"></a>实例</h3><p>演示不同的边框宽度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p.one &#123;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-width: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.two &#123;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-width: medium;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.three &#123;</span><br><span class="line">  border-style: dotted;</span><br><span class="line">  border-width: 2px;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">p.four &#123;</span><br><span class="line">  border-style: dotted;</span><br><span class="line">  border-width: thick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>5px border-width</p><p>medium border-width</p><p>2px border-width</p><p>thick border-width</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_border-width_1">亲自试一试</a></p><h2 id="特定边的宽度"><a href="#特定边的宽度" class="headerlink" title="特定边的宽度"></a>特定边的宽度</h2><p>border-width 属性可以设置一到四个值（用于上边框、右边框、下边框和左边框）：</p><h3 id="实例-46"><a href="#实例-46" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p.one &#123;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-width: 5px 20px; &#x2F;* 上边框和下边框为 5px，其他边为 20px *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.two &#123;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-width: 20px 5px; &#x2F;* 上边框和下边框为 20px，其他边为 5px *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.three &#123;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-width: 25px 10px 4px 35px; &#x2F;* 上边框 25px，右边框 10px，下边框 4px，左边框 35px *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_border-width_2">亲自试一试</a></p><h1 id="CSS-边框颜色-1"><a href="#CSS-边框颜色-1" class="headerlink" title="CSS 边框颜色"></a>CSS 边框颜色</h1><h2 id="CSS-边框颜色-2"><a href="#CSS-边框颜色-2" class="headerlink" title="CSS 边框颜色"></a>CSS 边框颜色</h2><p>border-color 属性用于设置四个边框的颜色。</p><p>可以通过以下方式设置颜色：</p><ul><li>name - 指定颜色名，比如 “red”</li><li>HEX - 指定十六进制值，比如 “#ff0000”</li><li>RGB - 指定 RGB 值，比如 “rgb(255,0,0)”</li><li>HSL - 指定 HSL 值，比如 “hsl(0, 100%, 50%)”</li><li>transparent</li></ul><p><strong>注释：</strong>如果未设置 <code>border-color</code>，则它将继承元素的颜色。</p><h3 id="实例-47"><a href="#实例-47" class="headerlink" title="实例"></a>实例</h3><p>演示不同的边框颜色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p.one &#123;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.two &#123;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-color: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.three &#123;</span><br><span class="line">  border-style: dotted;</span><br><span class="line">  border-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>红色实线边框</p><p>绿色实线边框</p><p>蓝色点状边框</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_border-color_1">亲自试一试</a></p><h2 id="特定边框的颜色"><a href="#特定边框的颜色" class="headerlink" title="特定边框的颜色"></a>特定边框的颜色</h2><p>border-color 属性可以设置一到四个值（用于上边框、右边框、下边框和左边框）。</p><h3 id="实例-48"><a href="#实例-48" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p.one &#123;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-color: red green blue yellow; &#x2F;* 上红、右绿、下蓝、左黄 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_border-color_2">亲自试一试</a></p><h2 id="HEX-值-1"><a href="#HEX-值-1" class="headerlink" title="HEX 值"></a>HEX 值</h2><p>边框的颜色也可以使用十六进制值（HEX）来指定：</p><h3 id="实例-49"><a href="#实例-49" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p.one &#123;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-color: #ff0000; &#x2F;* 红色 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_border-color-hex">亲自试一试</a></p><h2 id="RGB-值-1"><a href="#RGB-值-1" class="headerlink" title="RGB 值"></a>RGB 值</h2><p>或者使用 RGB 值：</p><h3 id="实例-50"><a href="#实例-50" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p.one &#123;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-color: rgb(255, 0, 0); &#x2F;* 红色 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_border-color-rgb">亲自试一试</a></p><h2 id="HSL-值-1"><a href="#HSL-值-1" class="headerlink" title="HSL 值"></a>HSL 值</h2><p>也可以使用 HSL 值：</p><h3 id="实例-51"><a href="#实例-51" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p.one &#123;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-color: hsl(0, 100%, 50%); &#x2F;* 红色 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css_border-color-hsl">亲自试一试</a></p><p>您可以在我们的 <a href="https://www.w3school.com.cn/css/css_colors.asp">CSS 颜色</a> 章节中学到有关 HEX、RGB 和 HSL 值的更多知识。</p></style></p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS参考手册</title>
      <link href="posts/3ec6640a.html"/>
      <url>posts/3ec6640a.html</url>
      
        <content type="html"><![CDATA[<h2 id="CSS-属性">0.1 CSS 属性</h2><h3 id="A">0.1.1 A</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_align-content.asp">align-content</a></th><th>规定弹性容器内的行之间的对齐方式，当项目不使用所有可用空间时。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_align-items.asp">align-items</a></td><td>规定弹性容器内项目的对齐方式。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_align-self.asp">align-self</a></td><td>规定弹性容器内所选项目的对齐方式。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_all.asp">all</a></td><td>重置所有属性（除了 unicode-bidi 和 direction）。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_animation.asp">animation</a></td><td>所有 animation-* 属性的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_animation-delay.asp">animation-delay</a></td><td>规定开始动画的延迟。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_animation-direction.asp">animation-direction</a></td><td>规定动画是向前播放、向后播放还是交替播放。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_animation-duration.asp">animation-duration</a></td><td>规定动画完成一个周期应花费的时间。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_animation-fill-mode.asp">animation-fill-mode</a></td><td>规定元素在不播放动画时（在开始之前、结束之后、或同时）的样式。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_animation-iteration-count.asp">animation-iteration-count</a></td><td>规定动画的播放次数。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_animation-name.asp">animation-name</a></td><td>规定 @keyframes 动画的名称。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_animation-play-state.asp">animation-play-state</a></td><td>规定动画是播放还是暂停。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_animation-timing-function.asp">animation-timing-function</a></td><td>规定动画的速度曲线。</td></tr></tbody></table><h3 id="B">0.1.2 B</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_backface-visibility.asp">backface-visibility</a></th><th>定义当面对用户时元素的背面是否应可见。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_background.asp">background</a></td><td>所有 background-* 属性的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_background-attachment.asp">background-attachment</a></td><td>设置背景图像是与页面的其余部分一起滚动还是固定的。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_background-blend-mode.asp">background-blend-mode</a></td><td>规定每个背景图层（颜色/图像）的混合模式。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_background-clip.asp">background-clip</a></td><td>定义背景（颜色或图像）应在元素内延伸的距离。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_background-color.asp">background-color</a></td><td>规定元素的背景色。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_background-image.asp">background-image</a></td><td>规定元素的一幅或多幅背景图像。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_background-origin.asp">background-origin</a></td><td>规定背景图像的初始位置。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_background-position.asp">background-position</a></td><td>规定背景图像的位置。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_background-repeat.asp">background-repeat</a></td><td>设置是否以及如何重复背景图像。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_background-size.asp">background-size</a></td><td>规定背景图像的尺寸。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border.asp">border</a></td><td>border-width、border-style 以及 border-color 的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-bottom.asp">border-bottom</a></td><td>border-bottom-width、border-bottom-style 以及 border-bottom-color 的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-bottom-color.asp">border-bottom-color</a></td><td>设置下边框的颜色。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-bottom-left-radius.asp">border-bottom-left-radius</a></td><td>定义左下角的边框圆角。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-bottom-right-radius.asp">border-bottom-right-radius</a></td><td>定义右下角的边框圆角。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-bottom_style.asp">border-bottom-style</a></td><td>设置下边框的样式。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-bottom_width.asp">border-bottom-width</a></td><td>设置下边框的宽度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-collapse.asp">border-collapse</a></td><td>设置表格边框是折叠为单一边框还是分开的。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-color.asp">border-color</a></td><td>设置四条边框的颜色。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-image.asp">border-image</a></td><td>border-image-* 属性的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-image-outset.asp">border-image-outset</a></td><td>规定边框图像区域超出边框的量。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-image-repeat.asp">border-image-repeat</a></td><td>规定边框图像应重复、圆角、还是拉伸。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-image-slice.asp">border-image-slice</a></td><td>规定如何裁切边框图像。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-image-source.asp">border-image-source</a></td><td>规定用作边框的图像的路径。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-image-width.asp">border-image-width</a></td><td>规定边框图像的宽度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-left.asp">border-left</a></td><td>所有 border-left-* 属性的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-left-color.asp">border-left-color</a></td><td>设置左边框的颜色。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-left-style.asp">border-left-style</a></td><td>设置左边框的样式。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-left-width.asp">border-left-width</a></td><td>设置左边框的宽度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-radius.asp">border-radius</a></td><td>四个 border-*-radius 属性的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-right.asp">border-right</a></td><td>所有 border-right-* 属性的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-right_color.asp">border-right-color</a></td><td>设置右边框的颜色。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-right-style.asp">border-right-style</a></td><td>设置右边框的样式。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-right-width.asp">border-right-width</a></td><td>设置右边框的宽度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-spacing.asp">border-spacing</a></td><td>设置相邻单元格边框之间的距离。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-style.asp">border-style</a></td><td>设置四条边框的样式。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-top.asp">border-top</a></td><td>border-top-width、border-top-style 以及 border-top-color 的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-top-color.asp">border-top-color</a></td><td>设置上边框的颜色。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-top-left-radius.asp">border-top-left-radius</a></td><td>定义左上角的边框圆角。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-top-right-radius.asp">border-top-right-radius</a></td><td>定义右上角的边框圆角。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-top-style.asp">border-top-style</a></td><td>设置上边框的样式。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-top-width.asp">border-top-width</a></td><td>设置上边框的宽度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_border-width.asp">border-width</a></td><td>设置四条边框的宽度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_pos_bottom.asp">bottom</a></td><td>设置元素相对于其父元素底部的位置。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_box-decoration-break.asp">box-decoration-break</a></td><td>设置元素在分页符处的背景和边框的行为，或对于行内元素在换行符处的行为。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_box-shadow.asp">box-shadow</a></td><td>将一个或多个阴影附加到元素。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_box-sizing.asp">box-sizing</a></td><td>定义元素的宽度和高度的计算方式：它们是否应包含内边距和边框。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_break-after.asp">break-after</a></td><td>规定指定元素之后是否应出现 page-、column- 或 region-break。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_break-before.asp">break-before</a></td><td>规定指定元素之前是否应出现 page-、column- 或 region-break。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_break-inside.asp">break-inside</a></td><td>规定指定元素内部是否应出现 page-、column- 或 region-break。</td></tr></tbody></table><h3 id="C">0.1.3 C</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_tab_caption-side.asp">caption-side</a></th><th>规定表格标题的放置方式。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_caret-color.asp">caret-color</a></td><td>规定光标在 input、textarea 或任何可编辑元素中的颜色。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_charset_rule.asp">@charset</a></td><td>规定样式表中使用的字符编码。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_class_clear.asp">clear</a></td><td>规定不允许在元素的哪一侧浮动元素</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_pos_clip.asp">clip</a></td><td>剪裁绝对定位的元素。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_clip-path.asp">clip-path</a></td><td>将元素裁剪为基本形状或 SVG 源。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_text_color.asp">color</a></td><td>设置文本的颜色。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_column-count.asp">column-count</a></td><td>规定元素应分为的列数。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_column-fill.asp">column-fill</a></td><td>指定如何填充列（是否 balanced）。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_column-gap.asp">column-gap</a></td><td>规定列间隙。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_column-rule.asp">column-rule</a></td><td>所有 column-rule-* 属性的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_column-rule-color.asp">column-rule-color</a></td><td>规定列之间规则的颜色。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_column-rule-style.asp">column-rule-style</a></td><td>规定列之间的规则样式。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_column-rule-width.asp">column-rule-width</a></td><td>规定列之间的规则宽度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_column-span.asp">column-span</a></td><td>规定元素应该跨越多少列。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_column-width.asp">column-width</a></td><td>规定列宽度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_columns.asp">columns</a></td><td>column-width 和 column-count 的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_gen_content.asp">content</a></td><td>与 :before 和 :after 伪元素一起使用，来插入生成的内容。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_gen_counter-increment.asp">counter-increment</a></td><td>增加或减少一个或多个 CSS 计数器的值。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_gen_counter-reset.asp">counter-reset</a></td><td>创建或重置一个或多个 CSS 计数器。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_class_cursor.asp">cursor</a></td><td>规定当指向元素时要显示的鼠标光标。</td></tr></tbody></table><h3 id="D">0.1.4 D</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_text_direction.asp">direction</a></th><th>规定文本方向/书写方向。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_class_display.asp">display</a></td><td>规定如何显示某个 HTML 元素。</td></tr></tbody></table><h3 id="E">0.1.5 E</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_tab_empty-cells.asp">empty-cells</a></th><th>规定是否在表格中的空白单元格上显示边框和背景。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="F">0.1.6 F</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_filter.asp">filter</a></th><th>定义元素显示之前的效果（例如，模糊或颜色偏移）。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_flex.asp">flex</a></td><td>flex-grow、flex-shrink 以及 flex-basis 的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_flex-basis.asp">flex-basis</a></td><td>规定弹性项目的初始长度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_flex-direction.asp">flex-direction</a></td><td>规定弹性项目的方向。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_flex-flow.asp">flex-flow</a></td><td>flex-direction 和 flex-wrap 的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_flex-grow.asp">flex-grow</a></td><td>规定项目相对于其余项目的增量。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_flex-shrink.asp">flex-shrink</a></td><td>规定项目相对于其余项目的减量。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_flex-wrap.asp">flex-wrap</a></td><td>规定弹性项目是否应该换行。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_class_float.asp">float</a></td><td>规定是否应该对盒（box）进行浮动。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_font_font.asp">font</a></td><td>font-style、font-variant、font-weight、font-size/line-height 以及 font-family 的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_font-face_rule.asp">@font-face</a></td><td>允许网站下载和使用 “web-safe” 字体以外的其他字体的规则。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_font_font-family.asp">font-family</a></td><td>规定文本的字体族（字体系列）。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_font-feature-settings.asp">font-feature-settings</a></td><td>允许控制 OpenType 字体中的高级印刷特性。</td></tr><tr><td>@font-feature-values</td><td>允许创作者使用 font-variant-alternate 中的通用名来实现在 OpenType 中以不同方式激活的特性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_font-kerning.asp">font-kerning</a></td><td>控制字距调整信息的使用（字母间距）。</td></tr><tr><td>font-language-override</td><td>控制特定语言的字形在字体的使用。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_font_font-size.asp">font-size</a></td><td>规定文本的字体大小。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_font-size-adjust.asp">font-size-adjust</a></td><td>保持发生字体回退时的可读性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_font-stretch.asp">font-stretch</a></td><td>从字体系列中选择一个普通的、压缩的或扩展的字体。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_font_font-style.asp">font-style</a></td><td>规定文本的字体样式。</td></tr><tr><td>font-synthesis</td><td>控制哪些缺失的字体（粗体或斜体）可以由浏览器合成。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_font_font-variant.asp">font-variant</a></td><td>规定是否应该以小型大写字体显示文本。</td></tr><tr><td>font-variant-alternates</td><td>控制与 @font-feature-values 中定义的备用名称关联的备用字形的使用。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_font-variant-caps.asp">font-variant-caps</a></td><td>控制大写字母的备用字形的使用。</td></tr><tr><td>font-variant-east-asian</td><td>控制东亚文字（例如中文和日语）的备用字形的使用。</td></tr><tr><td>font-variant-ligatures</td><td>控制在适用于元素的文本内容中使用哪些连字和上下文形式。</td></tr><tr><td>font-variant-numeric</td><td>控制数字、分数和序号标记的备用字形的使用。</td></tr><tr><td>font-variant-position</td><td>控制较小字体的替代字形的使用，这些字形相对于字体基线定位为上标或下标。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_font-weight.asp">font-weight</a></td><td>规定字体的粗细。</td></tr></tbody></table><h3 id="G">0.1.7 G</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_grid.asp">grid</a></th><th>grid-template-rows、grid-template-columns、grid-template-areas、grid-auto-rows、grid-auto-columns 以及 grid-auto-flow 属性的简写属性。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-area.asp">grid-area</a></td><td>即可规定网格项的名称，也可以是 grid-row-start、grid-column-start、grid-row-end 以及 grid-column-end 属性的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-auto-columns.asp">grid-auto-columns</a></td><td>规定默认的列尺寸。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-auto-flow.asp">grid-auto-flow</a></td><td>规定如何在网格中插入自动放置的项目。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-auto-rows.asp">grid-auto-rows</a></td><td>规定默认的行尺寸。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-column.asp">grid-column</a></td><td>grid-column-start 和 grid-column-end 属性的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-column-end.asp">grid-column-end</a></td><td>规定如何结束网格项目。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-column-gap.asp">grid-column-gap</a></td><td>规定列间隙的尺寸。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-column-start.asp">grid-column-start</a></td><td>规定网格项目从何处开始。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-gap.asp">grid-gap</a></td><td>grid-row-gap 和 grid-column-gap 的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-row.asp">grid-row</a></td><td>grid-row-start 和 grid-row-end 属性的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-row-end.asp">grid-row-end</a></td><td>规定网格项目在何处结束。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-row-gap.asp">grid-row-gap</a></td><td>规定列间隙的尺寸。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-row-start.asp">grid-row-start</a></td><td>规定网格项目从何处开始。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-template.asp">grid-template</a></td><td>grid-template-rows、grid-template-columns 以及 grid-areas 属性的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-template-areas.asp">grid-template-areas</a></td><td>规定如何使用命名的网格项显示列和行。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-template-columns.asp">grid-template-columns</a></td><td>指定列的尺寸以及网格布局中的列数。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_grid-template-rows.asp">grid-template-rows</a></td><td>指定网格布局中的行的尺寸。</td></tr></tbody></table><h3 id="H">0.1.8 H</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_hanging-punctuation.asp">hanging-punctuation</a></th><th>规定是否可以在行框外放置标点符号。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_dim_height.asp">height</a></td><td>设置元素的高度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_hyphens.asp">hyphens</a></td><td>设置如何分割单词以改善段落的布局。</td></tr></tbody></table><h3 id="I">0.1.9 I</h3><table><thead><tr><th>image-rendering</th><th>当图像被缩放时，向浏览器提供关于保留图像的哪些最重要的方面的信息。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_import_rule.asp">@import</a></td><td>允许您将样式表导入另一张样式表。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_isolation.asp">isolation</a></td><td>定义元素是否必须创建新的堆叠内容。</td></tr></tbody></table><h3 id="J">0.1.10 J</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_justify-content.asp">justify-content</a></th><th>规定项目在弹性容器内的对齐方式，当项目未用到所有可用空间时。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="K">0.1.11 K</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_keyframes.asp">@keyframes</a></th><th>规定动画代码。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="L">0.1.12 L</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_pos_left.asp">left</a></th><th>规定定位元素的左侧位置。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_text_letter-spacing.asp">letter-spacing</a></td><td>增加或减少文本中的字符间距。</td></tr><tr><td>line-break</td><td>如何如何/是否换行。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_dim_line-height.asp">line-height</a></td><td>设置行高。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_list-style.asp">list-style</a></td><td>在一条声明中设置所有列表属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_list-style-image.asp">list-style-image</a></td><td>把图像指定为列表项标记。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_list-style-position.asp">list-style-position</a></td><td>规定列表项标记的位置。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_list-style-type.asp">list-style-type</a></td><td>规定列表项标记的类型。</td></tr></tbody></table><h3 id="M">0.1.13 M</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_margin.asp">margin</a></th><th>在一条声明中设置所有外边距属性。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_margin-bottom.asp">margin-bottom</a></td><td>设置元素的下外边距。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_margin-left.asp">margin-left</a></td><td>设置元素的左外边距。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_margin-right.asp">margin-right</a></td><td>设置元素的右外边距。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_margin-top.asp">margin-top</a></td><td>设置元素的上外边距。</td></tr><tr><td>mask</td><td>通过在特定位置遮罩或剪切图像来隐藏元素。</td></tr><tr><td>mask-type</td><td>规定将遮罩元素用作亮度或 Alpha 遮罩。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_dim_max-height.asp">max-height</a></td><td>设置元素的最大高度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_dim_max-width.asp">max-width</a></td><td>设置元素的最大宽度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_mediaquery.asp">@media</a></td><td>为不同的媒体类型、设备、尺寸设置样式规则。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_dim_min-height.asp">min-height</a></td><td>设置元素的最小高度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_dim_min-width.asp">min-width</a></td><td>设置元素的最小宽度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_mix-blend-mode.asp">mix-blend-mode</a></td><td>规定元素内容应如何与其直接父的背景相混合。</td></tr></tbody></table><h3 id="O">0.1.14 O</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_object-fit.asp">object-fit</a></th><th>规定替换元素的内容应如何适合其所用高度和宽度建立的框。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_object-position.asp">object-position</a></td><td>指定替换元素在其框内的对齐方式。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_opacity.asp">opacity</a></td><td>设置元素的不透明等级。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_order.asp">order</a></td><td>设置弹性项目相对于其余项目的顺序。</td></tr><tr><td>orphans</td><td>设置在元素内发生分页时必须保留在页面底部的最小行数。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_outline.asp">outline</a></td><td>outline-width、outline-style 以及 outline-color 属性的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_outline-color.asp">outline-color</a></td><td>设置轮廓的颜色。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_outline-offset.asp">outline-offset</a></td><td>对轮廓进行偏移，并将其绘制到边框边缘之外。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_outline-style.asp">outline-style</a></td><td>设置轮廓的样式。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_outline-width.asp">outline-width</a></td><td>设置轮廓的宽度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_pos_overflow.asp">overflow</a></td><td>规定如果内容溢出元素框会发生什么情况。</td></tr><tr><td>overflow-wrap</td><td>规定浏览器是否可能为了防止溢出而在单词内折行（当字符串太长而无法适应其包含框时）。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_overflow-x.asp">overflow-x</a></td><td>规定是否剪裁内容的左右边缘，如果它溢出了元素的内容区域。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_overflow-y.asp">overflow-y</a></td><td>规定是否剪裁内容的上下边缘，如果它溢出了元素的内容区域。</td></tr></tbody></table><h3 id="P">0.1.15 P</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_padding.asp">padding</a></th><th>所有 padding-* 属性的简写属性。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_padding-bottom.asp">padding-bottom</a></td><td>设置元素的下内边距。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_padding-left.asp">padding-left</a></td><td>设置元素的左内边距。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_padding-right.asp">padding-right</a></td><td>设置元素的右内边距。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_padding-top.asp">padding-top</a></td><td>设置元素的上内边距。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_page-break-after.asp">page-break-after</a></td><td>设置元素之后的分页（page-break）行为。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_page-break-before.asp">page-break-before</a></td><td>设置元素之前的分页（page-break）行为。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_page-break-inside.asp">page-break-inside</a></td><td>设置元素内的分页（page-break）行为。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_perspective.asp">perspective</a></td><td>为 3D 定位元素提供透视。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_perspective-origin.asp">perspective-origin</a></td><td>定义用户观看 3D 定位元素的位置。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_pointer-events.asp">pointer-events</a></td><td>定义元素是否对指针事件做出反应。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_class_position.asp">position</a></td><td>规定用于元素的定位方法的类型（静态、相对、绝对或固定）。</td></tr></tbody></table><h3 id="Q">0.1.16 Q</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_gen_quotes.asp">quotes</a></th><th>设置引号类型。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="R">0.1.17 R</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_resize.asp">resize</a></th><th>定义用户是否以及如何调整元素的尺寸。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_pos_right.asp">right</a></td><td>规定定位元素的左侧位置。</td></tr></tbody></table><h3 id="S">0.1.18 S</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_scroll-behavior.asp">scroll-behavior</a></th><th>规定可滚动框中是否平滑地滚动，而不是直接跳跃。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="T">0.1.19 T</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_tab-size.asp">tab-size</a></th><th>规定制表符的宽度。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_tab_table-layout.asp">table-layout</a></td><td>定义用于对单元格、行和列进行布局的算法。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_text_text-align.asp">text-align</a></td><td>规定文本的水平对齐方式。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_text-align-last.asp">text-align-last</a></td><td>描述当 text-align 为 “justify” 时，如何在强制换行之前对齐块或行的最后一行。</td></tr><tr><td>text-combine-upright</td><td>将多个字符组合到到单个字符的空间中。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_text_text-decoration.asp">text-decoration</a></td><td>规定文本装饰。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_text-decoration-color.asp">text-decoration-color</a></td><td>规定文本装饰（text-decoration）的颜色。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_text-decoration-line.asp">text-decoration-line</a></td><td>规定文本装饰（text-decoration）中的的行类型。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_text-decoration-style.asp">text-decoration-style</a></td><td>规定文本装饰（text-decoration）中的行样式。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_text_text-indent.asp">text-indent</a></td><td>规定文本块（text-block）中的的首行缩进。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_text-justify.asp">text-justify</a></td><td>规定当 text-align 为 “justify” 时使用的对齐方法。</td></tr><tr><td>text-orientation</td><td>定义行中的文本方向。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_text-overflow.asp">text-overflow</a></td><td>规定当文本溢出包含元素时应该发生的情况。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_text-shadow.asp">text-shadow</a></td><td>添加文本阴影。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_text_text-transform.asp">text-transform</a></td><td>控制文本的大写。</td></tr><tr><td>text-underline-position</td><td>规定使用 text-decoration 属性设置的下划线的位置。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_pos_top.asp">top</a></td><td>规定定位元素的顶端位置。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_transform.asp">transform</a></td><td>向元素应用 2D 或 3D 转换。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_transform-origin.asp">transform-origin</a></td><td>允许您更改转换元素的位置。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_transform-style.asp">transform-style</a></td><td>规定如何在 3D 空间中渲染嵌套的元素。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_transition.asp">transition</a></td><td>所有 transition-* 属性的简写属性。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_transition-delay.asp">transition-delay</a></td><td>规定合适开始过渡效果。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_transition-duration.asp">transition-duration</a></td><td>规定完成过渡效果所需的秒或毫秒数。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_transition-property.asp">transition-property</a></td><td>规定过渡效果对应的 CSS 属性的名称。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_transition-timing-function.asp">transition-timing-function</a></td><td>规定过渡效果的速度曲线。</td></tr></tbody></table><h3 id="U">0.1.20 U</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_unicode-bidi.asp">unicode-bidi</a></th><th>与 direction 属性一起使用，设置或返回是否应覆写文本来支持同一文档中的多种语言。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_user-select.asp">user-select</a></td><td>规定是否能选取元素的文本。</td></tr></tbody></table><h3 id="V">0.1.21 V</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_pos_vertical-align.asp">vertical-align</a></th><th>设置元素的垂直对齐方式。</th></tr></thead><tbody><tr><td><a href="https://www.w3school.com.cn/cssref/pr_class_visibility.asp">visibility</a></td><td>规定元素是否可见。</td></tr></tbody></table><h3 id="W">0.1.22 W</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_text_white-space.asp">white-space</a></th><th>规定如何处理元素内的空白字符。</th></tr></thead><tbody><tr><td>widows</td><td>设置如果元素内发生分页，必须在页面顶部保留的最小行数。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_dim_width.asp">width</a></td><td>设置元素的宽度。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_word-break.asp">word-break</a></td><td>规定单词到达行末后如何换行。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_text_word-spacing.asp">word-spacing</a></td><td>增加或减少文本中的单词间距。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_word-wrap.asp">word-wrap</a></td><td>允许长的、不能折行的单词换到下一行。</td></tr><tr><td><a href="https://www.w3school.com.cn/cssref/pr_writing-mode.asp">writing-mode</a></td><td>规定文本行是水平还是垂直布局。</td></tr></tbody></table><h3 id="Z">0.1.23 Z</h3><table><thead><tr><th><a href="https://www.w3school.com.cn/cssref/pr_pos_z-index.asp">z-index</a></th><th>设置定位元素的堆叠顺序。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora css 语法</title>
      <link href="posts/a487ab94.html"/>
      <url>posts/a487ab94.html</url>
      
        <content type="html"><![CDATA[<h1 id="typora每级标题生成序号">1 typora每级标题生成序号</h1><ul><li>在主题根目录新建一个base.user.css文件，写入如下代码，重启typora即可生效。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** initialize css counter */</span></span><br><span class="line"><span class="selector-id">#write</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h4</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h5</span> &#123;</span><br><span class="line">    <span class="attribute">counter-reset</span>: h6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** put counter result into headings */</span></span><br><span class="line"><span class="selector-id">#write</span> <span class="selector-tag">h1</span>:before &#123;</span><br><span class="line">    counter-increment: h1;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;. &quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#write</span> <span class="selector-tag">h2</span>:before &#123;</span><br><span class="line">    counter-increment: h2;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;. &quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#write</span> <span class="selector-tag">h3</span>:before,</span><br><span class="line">h3.md-focus.md-heading:before /** override the default style for focused headings */ &#123;</span><br><span class="line">    counter-increment: h3;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;. &quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#write</span> <span class="selector-tag">h4</span>:before,</span><br><span class="line">h4.md-focus.md-heading:before &#123;</span><br><span class="line">    counter-increment: h4;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;. &quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#write</span> <span class="selector-tag">h5</span>:before,</span><br><span class="line">h5.md-focus.md-heading:before &#123;</span><br><span class="line">    counter-increment: h5;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h5) <span class="string">&quot;. &quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#write</span> <span class="selector-tag">h6</span>:before,</span><br><span class="line">h6.md-focus.md-heading:before &#123;</span><br><span class="line">    counter-increment: h6;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h5) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h6) <span class="string">&quot;. &quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** override the default style for focused headings */</span></span><br><span class="line"><span class="selector-id">#write</span>&gt;<span class="selector-tag">h3</span><span class="selector-class">.md-focus</span>:before,</span><br><span class="line">#write&gt;h4.md-focus:before,</span><br><span class="line">#write&gt;h5.md-focus:before,</span><br><span class="line">#write&gt;h6.md-focus:before,</span><br><span class="line">h3.md-focus:before,</span><br><span class="line">h4.md-focus:before,</span><br><span class="line">h5.md-focus:before,</span><br><span class="line">h6.md-focus:before &#123;</span><br><span class="line">    color: inherit;</span><br><span class="line">    <span class="attribute">border</span>: inherit;</span><br><span class="line">    <span class="attribute">border-radius</span>: inherit;</span><br><span class="line">    <span class="attribute">position</span>: inherit;</span><br><span class="line">    <span class="attribute">left</span>:initial;</span><br><span class="line">    <span class="attribute">float</span>: none;</span><br><span class="line">    <span class="attribute">top</span>:initial;</span><br><span class="line">    <span class="attribute">font-size</span>: inherit;</span><br><span class="line">    <span class="attribute">padding-left</span>: inherit;</span><br><span class="line">    <span class="attribute">padding-right</span>: inherit;</span><br><span class="line">    <span class="attribute">vertical-align</span>: inherit;</span><br><span class="line">    <span class="attribute">font-weight</span>: inherit;</span><br><span class="line">    <span class="attribute">line-height</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="导出PDF大标题自动分页">2 导出PDF大标题自动分页</h1><ul><li>打开主题文件夹，编辑对应的主题css文件，添加如下代码</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> print &#123;</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">13px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">page-break-before</span>: always;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:first</span>-of-type&#123;</span><br><span class="line"><span class="attribute">page-break-before</span>: avoid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="添加目录">3 添加目录</h1><ul><li>在需要的地方加入**<code>[TOC]</code>**就会自动生成目录</li></ul><h1 id="添加主题，上面操作一步到位">4 添加主题，上面操作一步到位</h1><ul><li>使用vlook主题</li><li><a href="https://github.com/MadMaxChow/VLOOK">https://github.com/MadMaxChow/VLOOK</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MARKDOWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MARKDOWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TLS、OPENSSL代码分析</title>
      <link href="posts/3a5a5f39.html"/>
      <url>posts/3a5a5f39.html</url>
      
        <content type="html"><![CDATA[<h1 id="例程">1 例程</h1><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>example/protocals/https_mbedtls/</td><td>mbedtls库用例</td></tr><tr><td>example/protocals/https_request/</td><td>esp tls用例</td></tr><tr><td>example/protocals/https_x509_bundle/</td><td>esp tls用例</td></tr></tbody></table><h1 id="ESP-TLS">2 ESP TLS</h1><p>Esp tls库是乐鑫对mbedlts和wolfssl库的进一步封装，使得对外使用统一的api接口。</p><p>默认配置使用mbedtls</p><h2 id="http-tls-用例（删减）">2.1 http tls 用例（删减）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">esp_tls_cfg_t</span> cfg = &#123;</span><br><span class="line">            .crt_bundle_attach = esp_crt_bundle_attach,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">esp_tls</span> *<span class="title">tls</span> =</span> esp_tls_conn_http_new(WEB_URL, &amp;cfg);<span class="comment">// 新建https连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ret = esp_tls_conn_write(tls,<span class="comment">// 写入http请求</span></span><br><span class="line">                             REQUEST + written_bytes,</span><br><span class="line">                             <span class="built_in">strlen</span>(REQUEST) - written_bytes);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ESP_LOGI(TAG, <span class="string">&quot;%d bytes written&quot;</span>, ret);</span><br><span class="line">        written_bytes += ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span>(written_bytes &lt; <span class="built_in">strlen</span>(REQUEST));</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    len = <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>;</span><br><span class="line">    bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ret = esp_tls_conn_read(tls, (<span class="keyword">char</span> *)buf, len);<span class="comment">// 接收数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Print response directly to stdout as it is read */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">esp_tls_conn_delete(tls);<span class="comment">// 删除连接</span></span><br></pre></td></tr></table></figure><h1 id="openssl-client示例代码（删减）">3 openssl client示例代码（删减）</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">SSL_CTX *ctx;</span><br><span class="line">SSL *ssl;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sock_addr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip4_addr</span> *<span class="title">ip4_addr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> recv_bytes = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> recv_buf[OPENSSL_EXAMPLE_RECV_BUF_LEN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> send_data[] = OPENSSL_EXAMPLE_REQUEST;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> send_bytes = <span class="keyword">sizeof</span>(send_data);</span><br><span class="line"></span><br><span class="line">ctx = SSL_CTX_new(TLSv1_1_client_method());</span><br><span class="line"></span><br><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">ret = bind(sockfd, (struct sockaddr*)&amp;sock_addr, <span class="keyword">sizeof</span>(sock_addr));</span><br><span class="line">ret = connect(sockfd, (struct sockaddr*)&amp;sock_addr, <span class="keyword">sizeof</span>(sock_addr));</span><br><span class="line"></span><br><span class="line">ssl = SSL_new(ctx);</span><br><span class="line">SSL_set_fd(ssl, sockfd);</span><br><span class="line">ret = SSL_connect(ssl);</span><br><span class="line">ret = SSL_write(ssl, send_data, send_bytes);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ret = SSL_read(ssl, recv_buf, OPENSSL_EXAMPLE_RECV_BUF_LEN - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recv_buf[ret] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    recv_bytes += ret;</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;%s&quot;</span>, recv_buf);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">SSL_shutdown(ssl);</span><br><span class="line">SSL_free(ssl);</span><br><span class="line">close(sockfd);</span><br><span class="line">SSL_CTX_free(ctx);</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> ESP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建</title>
      <link href="posts/afcbc60d.html"/>
      <url>posts/afcbc60d.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装-Node-js和npm">1 安装 Node.js和npm</h1><blockquote><p>sudo apt-get update<br>sudo apt-get install nodejs<br>sudo apt-get install npm</p></blockquote><p>如果报错,请更改软件源–<a href="https://link.jianshu.com/?t=https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学开源软件源</a>,并更新</p><p>查看nodejs和npm版本号</p><blockquote><p>nodejs -v<br>npm -v</p></blockquote><p>可以正常打印版本号说明,安装成功</p><h1 id="安装-Hexo">2 安装 Hexo</h1><p>创建博客所在目录</p><blockquote><p>mkdir hexo</p></blockquote><p>安装 Hexo</p><blockquote><p>创建目录<br>mkdir hexo<br>切换目录<br>cd hexo<br>全局安装 Hexo，需要最高权限，记得输入root密码<br>sudo npm install -g hexo-cli<br>初始化 Hexo<br>hexo init</p></blockquote><p>如果报错执行代码,不报错忽略</p><blockquote><p>sudo npm config set user 0<br>sudo npm config set unsafe-perm true<br>sudo npm install -g hexo-cli</p></blockquote><p>安装插件</p><blockquote><p>npm install hexo-generator-index –save<br>npm install hexo-generator-archive –save<br>npm install hexo-generator-category –save<br>npm install hexo-generator-tag –save<br>npm install hexo-server –save<br>npm install hexo-deployer-git –save<br>npm install hexo-deployer-heroku –save<br>npm install hexo-deployer-rsync –save<br>npm install hexo-deployer-openshift –save<br>npm install hexo-renderer-marked –save<br>npm install hexo-renderer-stylus –save<br>npm install hexo-generator-feed –save<br>npm install hexo-generator-sitemap –save</p></blockquote><p>测试安装成功</p><blockquote><p>hexo server</p></blockquote><p><img "" class="lazyload placeholder" data-original="https://upload-images.jianshu.io/upload_images/2598556-5265065995c5159c?imageMogr2/auto-orient/strip%7CimageView2/2/w/406/format/webp" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><p>成功的提示</p><p>浏览器输入 <a href="http://localhost:4000/">http://localhost:4000</a> 可以访问到首页</p><p><img "" class="lazyload placeholder" data-original="https://upload-images.jianshu.io/upload_images/2598556-4f669806bd1340e6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><p>这里写图片描述</p><p>修改Hexo配置文件hexo/_config.yml</p><blockquote><p>提示：key对应没有值的时候，冒号后面一定要有空格！否则会报错<br>例如: timezone:会报错，timezone: 则不会。<br>下边列出了常用的配置信息</p></blockquote><p>站点信息设置</p><blockquote><p>title: ZTFDeveloper’s Blog #站名<br>subtitle:  #副标题<br>description: 前进的开发者#站描述<br>author:  ZTF#作者<br>language: zh-CN #语言<br>timezone:</p></blockquote><p>想把博客部署到自己的服务器,并通过IP或域名访问需要配置url</p><blockquote><p>url: <a href="https://link.jianshu.com/?t=http://blog.prozin.xyz">http://blog.prozin.xyz</a><br>root: /<br>permalink: :year/:month/:day/:title/<br>permalink_defaults:</p></blockquote><p>Deployment 这里设置了Git,mocorochio为你的github用户名</p><blockquote><p>deploy:<br>type: git<br>repo: <a href="https://link.jianshu.com/?t=mailto:git@github.com">git@github.com</a>:mocorochio/<a href="https://link.jianshu.com/?t=http://micorochio.github.io.git">micorochio.github.io.git</a><br>branch: master</p></blockquote><h1 id="三、Hexo-相关命令">3 三、Hexo 相关命令</h1><p>新建文章(会在 hexo/source/_post 下生成对应.md 文件)</p><blockquote><p>hexo n “文章名称”</p></blockquote><p>生成静态文件(位于 hexo/public 目录)</p><blockquote><p>hexo g</p></blockquote><p>启动 Hexo 预览</p><blockquote><p>hexo s</p></blockquote><p>提交部署(需要相关配置)</p><blockquote><p>hexo d</p></blockquote><h1 id="安装nginx">4 安装nginx</h1><p>省略。。。</p><h1 id="部署网站">5 部署网站</h1><h3 id="下载静态网站">5.0.1 下载静态网站</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /www</span><br><span class="line">cd /www</span><br><span class="line">git clone -b public https://github.com/flyghost/flyghost.github.io.git</span><br></pre></td></tr></table></figure><p>将<strong>flyghost</strong>改为你自己的用户名，由于我将静态网站发布到<strong>public</strong>分支，所以需要加上**<code>-b public</code>**</p><h3 id="申请SSL证书">5.0.2 申请SSL证书</h3><p>阿里云申请，省略。。。</p><h3 id="下载SSL证书">5.0.3 下载SSL证书</h3><p>将SSL证书放入**<code>/ssl/www.creekwater.cn/</code>**路径下</p><h3 id="配置nginx">5.0.4 配置nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果刚安装的nginx，该路径下为空</span></span><br><span class="line">cd /etc/nginx/conf.d</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个配置文件</span></span><br><span class="line">vim www.creekwater.cn.conf</span><br></pre></td></tr></table></figure><h3 id="编辑配置文件">5.0.5 编辑配置文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;                                              # http端口</span><br><span class="line">    server_name  www.creekwater.cn;                        # 改为自己的域名</span><br><span class="line">    rewrite ^(.*)$ https:<span class="comment">//$&#123;server_name&#125;$1 permanent;      # http重定向到https，可以实现所有访问都转到https</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    server_name www.creekwater.cn;     # 改为域名</span><br><span class="line">    listen 443 ssl;                     # 一定要改为443，因为https端口为443，同时开启SSL</span><br><span class="line"></span><br><span class="line">    ssl_certificate /ssl/www.creekwater.cn/www.creekwater.cn.pem;         # 改为自己申请得到的 crt 文件的名称</span><br><span class="line">    ssl_certificate_key /ssl/www.creekwater.cn/www.creekwater.cn.key;     # 改为自己申请得到的 key 文件的名称</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1<span class="number">.1</span> TLSv1<span class="number">.2</span>;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    root /www/flyghost.github.io;                                           # 静态网站路径，注意权限</span><br><span class="line">    index index.html;                                                       # 主页名字</span><br><span class="line">    location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt)&#123;</span><br><span class="line">        root /www/flyghost.github.io;                                       # 静态网站路径</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重启nginx">5.0.6 重启nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h1 id="常见问题">6 常见问题</h1><h2 id="解决图片显示和typora显示">6.1 解决图片显示和typora显示</h2><p>安装hexo-asset-image，使用相对路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><h2 id="文章路径显示为固定的加密字符串">6.2 文章路径显示为固定的加密字符串</h2><p>安装hexo-abbrlink</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>在hexo根目录下的_config.yml中，修改为如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">permalink: posts&#x2F;:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: hex    # 进制：dec(default) and hex</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks</span><br></pre></td></tr></table></figure><h2 id="hexo-abbrlink和hexo-asset-image冲突导致图片显示不出来">6.3 hexo-abbrlink和hexo-asset-image冲突导致图片显示不出来</h2><ul><li>打开<code>\node_modules\hexo-asset-image\index.js</code></li><li>修改<code>var endPos = link.length-1;</code>为<code>var endPos = link.length-5;</code></li></ul><h2 id="添加PDF链接">6.4 添加PDF链接</h2><ul><li><pre><code>  npm install --save hexo-pdf  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在source文件夹下新建一个books文件夹，并将PDF文件放入</span><br><span class="line"></span><br><span class="line">- 使用方法：在markdown文件中使用链接，譬如&#96;&#96;&#96;[Future-and-Indoor-Networks](&#x2F;books&#x2F;Future-and-Indoor-Networks.pdf)&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">## 修改文稿后网页实时预览</span><br><span class="line"></span><br><span class="line">安装插件</span><br><span class="line"></span><br></pre></td></tr></table></figure>npm install hexo-browsersync --save</code></pre></li></ul><p>其中 3001 端口是 browsersync 的配置页面, 4000 端口就是我们的调试页面了.</p>]]></content>
      
      
      <categories>
          
          <category> BLOG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BLOG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT协议简介及移植</title>
      <link href="posts/41fa605b.html"/>
      <url>posts/41fa605b.html</url>
      
        <content type="html"><![CDATA[<h1 id="MQTT协议">1 MQTT协议</h1><h2 id="MQTT协议简介">1.1 MQTT协议简介</h2><p>MQTT协议全称是Message Queuing Telemetry Transport，翻译过来就是消息队列遥测传输协议，它是物联网常用的应用层协议，运行在TCP/IP中的应用层中，依赖TCP协议，因此它具有非常高的可靠性，同时它是基于TCP协议的&lt;客户端-服务器&gt;模型发布/订阅主题消息的轻量级协议，也是我们常说的发送与接收数据，下面我们来初步了解一下mqtt相关的名称与功能。</p><h2 id="MQTT通信模型">1.2 MQTT通信模型</h2><p>MQTT 协议提供一对多的消息发布，可以降低应用程序的耦合性，用户只需要编写极少量的应用代码就能完成一对多的消息发布与订阅，该协议是基于&lt;客户端-服务器&gt;模型，在协议中主要有三种身份：发布者（Publisher）、服务器（Broker）以及订阅者（Subscriber）。其中，MQTT消息的发布者和订阅者都是客户端，服务器只是作为一个中转的存在，将发布者发布的消息进行转发给所有订阅该主题的订阅者；发布者可以发布在其权限之内的所有主题，并且消息发布者可以同时是订阅者，实现了生产者与消费者的脱耦，发布的消息可以同时被多个订阅者订阅。</p><p><img "" class="lazyload placeholder" data-original="/posts/41fa605b/MQTT%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="MQTT通信模型"></p><p>MQTT客户端的功能：</p><ol><li>发布消息给其它相关的客户端。</li><li>订阅主题请求接收相关的应用消息。</li><li>取消订阅主题请求移除接收应用消息。</li><li>从服务端终止连接。</li></ol><p>MQTT 服务器常被称为 Broker（消息代理），以是一个应用程序或一台设备，它一般为云服务器，比如BTA三巨头的一些物联网平台就是常使用MQTT协议，它是位于消息发布者和订阅者之间，以便用于接收消息并发送到订阅者之中，它的功能有：</p><ol><li>接受来自客户端的网络连接请求。</li><li>接受客户端发布的应用消息。</li><li>处理客户端的订阅和取消订阅请求。</li><li>转发应用消息给符合条件的已订阅客户端（包括发布者自身）。</li></ol><h2 id="消息主题与服务质量">1.3 消息主题与服务质量</h2><p>什么是主题？MQTT服务器为每个连接的客户端（订阅者）添加一个标签，该标签与服务器中的所有订阅相匹配，服务器会将消息转发给与标签相匹配的每个客户端（订阅者），当然订阅者也是需要有权限才能订阅对应的主题，比如像阿里云中的，订阅者只能订阅同一个产品下的主题，而不能跨产品订阅，这样子的处理就能达到信息的安全性以及多个订阅者能及时收到消息。一个主题可以有多个级别，各个级别之间用斜杠字符分隔，例如/test 和 /test/test1/test2都 是有效的主题。</p><p>发布者与订阅者可以通过主题名字，一般为UTF-8编码（反正用英文字符串就不会错）的形式发布和订阅主题，比如我们可以直接定义一个名字为“test”的主题，绝大多数的MQTT服务器支持动态发布/定阅主题，即当前服务器中没有某个主题，但是客户端直接可以向该主题发布/订阅消息，这样子服务器就会创建对应的主题，当然，服务器中一般也会默认提供多个系统主题，所有连接的客户端均可订阅。</p><p>每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间会有状态交互，订阅是基于会话之上，每个订阅中，都会包含一个主题过滤器，它是一个表达式，用于标识订阅相关的一个或多个主题，主题过滤器可以使用通配符，因此订阅者需要指定订阅的主题名字与服务质量（QoS），订阅者能订阅多个主题，也就能接收到多个发布者发布的消息。同理，发布者也需要首先与服务器建立会话，并且指定发送的主题名字与服务质量，同时它也能向多个不同的主题发送消息。</p><p>那么什么是服务质量呢？MQTT的服务质量提供3个等级：</p><ol><li>QoS0：最多发送一次消息，在消息发送出去后，接收者不会发送回应，发送者也不会重发消息，消息可能送达一次也可能根本没送达， 这个服务质量常用在不重要的消息传递中，因为即使消息丢了也没有太大关系。</li><li>QoS1：最少发送一次消息（消息最少需要送达一次，也有可送达多次），QoS1的PUBLISH报文的可变报头中包含一个报文标识符， 需要PUBACK报文确认。即需要接收者返回PUBACK应答报文。</li><li>QoS2：这是最高等级的服务质量，消息丢失和重复都是不可接受的，只不过使用这个服务质量等级会有额外的开销， 这个等级常用于支付中，因为支付是必须有且仅有一次成功，总不能没给钱或者给了多次钱吧。</li></ol><h2 id="MQTT控制报文">1.4 MQTT控制报文</h2><h3 id="固定报头">1.4.1 固定报头</h3><p>MQTT协议工作在TCP协议之上，因为客户端和服务器都是应用层，那么必然需要一种协议在两者之间进行通信，那么随之而来的就是MQTT控制报文， MQTT控制报文有3个部分组成，分别是<strong>固定报头（fixed header）</strong>、<strong>可变报头（variable header）</strong>、<strong>有效荷载（数据区域payload）</strong>。固定报头，所有的MQTT控制报文都包含，可变报头与有效载荷是部分MQTT控制报文包含。</p><p>固定报头占据两字节的空间，具体见图 <a href="%E5%9B%BA%E5%AE%9A%E6%8A%A5%E5%A4%B4.png">固定报头</a>。</p><p><img "" class="lazyload placeholder" data-original="/posts/41fa605b/%E5%9B%BA%E5%AE%9A%E6%8A%A5%E5%A4%B4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="固定报头"></p><p>固定报头的第一个字节分为<strong>控制报文的类型</strong>（4bit），以及控<strong>制报文类型的标志位</strong>。</p><p>控制类型共有14种，其中0与15被系统保留出来，其他的类型具体见表格固定报头类型。</p><table><thead><tr><th>类型</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>Reserved</td><td>0</td><td><strong>系统保留</strong></td></tr><tr><td>CONNECT</td><td>1</td><td>客户端请求连接服务端</td></tr><tr><td>CONNACK</td><td>2</td><td>连接报文确认</td></tr><tr><td>PUBLISH</td><td>3</td><td>发布消息</td></tr><tr><td>PUBACK</td><td>4</td><td>消息发布收到确认（QoS 1）</td></tr><tr><td>PUBREC</td><td>5</td><td>发布收到（QoS2）</td></tr><tr><td>PUBREL</td><td>6</td><td>发布释放（QoS2）</td></tr><tr><td>PUBCOMP</td><td>7</td><td>消息发布完成（QoS2）</td></tr><tr><td>SUBSCRIBE</td><td>8</td><td>客户端订阅请求</td></tr><tr><td>SUBACK</td><td>9</td><td>订阅请求报文确认</td></tr><tr><td>UNSUBSCRIBE</td><td>10</td><td>客户端取消订阅请求</td></tr><tr><td>UNSUBACK</td><td>11</td><td>取消订阅报文确认</td></tr><tr><td>PINGREQ</td><td>12</td><td>心跳请求</td></tr><tr><td>PINGRESP</td><td>13</td><td>心跳响应</td></tr><tr><td>DISCONNECT</td><td>14</td><td>客户端断开连接</td></tr><tr><td>Reserved</td><td>15</td><td><strong>系统保留</strong></td></tr></tbody></table><p>固定报头的bit0-bit3为标志位，依照报文类型有不同的含义。</p><p>事实上，<strong>除了PUBLISH类型报文以外，其他报文的标志位均为系统保留</strong>，PUBLISH报文的第一字节<strong>bit3是控制报文的重复分发标志</strong>（DUP），<strong>bit1-bit2是服务质量等级</strong>，<strong>bit0是PUBLISH报文的保留标志</strong>，用于标识PUBLISH是否保留，当客户端发送一个PUBLISH消息到服务器，如果保留标识位置1，那么服务器应该保留这条消息，当一个新的订阅者订阅这个主题的时候，最后保留的主题消息应被发送到新订阅的用户。</p><p>固定报头的第二个字节开始是<strong>剩余长度字段</strong>，是用于记录剩余报文长度的，表示当前的消息剩余的字节数，包括可变报头和有效载荷区域（如果存在），但剩余长度<strong>不包括用于编码剩余长度字段本身的字节数</strong>。</p><p>剩余长度字段使用一个<strong>变长度编码</strong>方案，对小于128的值它使用单字节编码，而对于更大的数值则按下面的方式处理：每个字节的低7位用于编码数据长度，最高位（bit7）用于标识剩余长度字段是否有更多的字节，且按照大端模式进行编码，因此每个字节可以编码128个数值和一个延续位，剩余长度字段最大可拥有4个字节。</p><p>当剩余长度使用1个字节存储时，其取值范围为0(0x00)~127(0x7f)。</p><p>当使用2个字节时，其取值范围为128(0x80,0x01)~16383(0Xff,0x7f)。</p><p>当使用3个字节时，其取值范围为16384(0x80,0x80,0x01)~2097151(0xFF,0xFF,0x7F)。</p><p>当使用4个字节时，其取值范围为2097152(0x80,0x80,0x80,0x01)~268435455(0xFF,0xFF,0xFF,0x7F)。</p><p>总的来说，MQTT报文理论上可以发送最大256M的报文，当然，这种情况是非常少的。</p><h3 id="可变报头">1.4.2 可变报头</h3><p>可变报头并不是所有的MQTT报文都带有的（比如PINGREQ心跳请求与PINGRESP心跳响应报文就没有可变报头），只有某些报文才拥有可变报头，它在固定报头和有效负载之间，可变报头的内容会根据报文类型的不同而有所不同，但可变报头的报文标识符（Packet Identifier）字段存在于在多个类型的报文里，而有一些报文又没有报文标识符字段，具体见表格，报文标识符结构具体见图 <a href="%E6%8A%A5%E6%96%87%E6%A0%87%E8%AF%86%E7%AC%A6.png">报文标识符</a>。</p><p><img "" class="lazyload placeholder" data-original="/posts/41fa605b/%E6%8A%A5%E6%96%87%E6%A0%87%E8%AF%86%E7%AC%A6.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="报文标识符"></p><table><thead><tr><th>报文类型</th><th>是否需要报文标识符字段</th></tr></thead><tbody><tr><td>CONNECT</td><td>不需要</td></tr><tr><td>CONNACK</td><td>不需要</td></tr><tr><td>PUBLISH</td><td>需要（如果QoS &gt; 0）</td></tr><tr><td>PUBACK</td><td>需要</td></tr><tr><td>PUBREC</td><td>需要</td></tr><tr><td>PUBREL</td><td>需要</td></tr><tr><td>PUBCOMP</td><td>需要</td></tr><tr><td>SUBSCRIBE</td><td>需要</td></tr><tr><td>SUBACK</td><td>需要</td></tr><tr><td>UNSUBSCRIBE</td><td>需要</td></tr><tr><td>UNSUBACK</td><td>需要</td></tr><tr><td>PINGREQ</td><td>不需要</td></tr><tr><td>PINGRESP</td><td>不需要</td></tr><tr><td>DISCONNECT</td><td>不需要</td></tr></tbody></table><p>因为对于不同的报文，可变报头是不一样的，下面就简单讲解几个报文的可变报头。</p><h4 id="CONNECT">1.4.2.1 CONNECT</h4><p>在一个会话中，客户端只能发送一次CONNECT报文，它是客户端用于请求连接服务器的报文，常称之为连接报文，如果客户端发送多次连接报文，那么服务端必须将客户端发送的第二个CONNECT报文当作协议违规处理并断开客户端的连接。</p><p>CONNECT报文的可变报头包含四个字段：<strong>协议名</strong>（Protocol Name）、<strong>协议级别</strong>（Protocol Level）、<strong>连接标志</strong>（Connect Flags）以及<strong>保持连接</strong>（Keep Alive）字段。</p><p>协议名是MQTT 的UTF-8编码的字符串，其中还包含用于记录协议名长度的两字节字段MSB与LSB。</p><p>在协议名之后的是协议级别，MQTT协议使用8位的无符号值表示协议的修订版本，对于MQTT3.1版的协议，协议级别字段的值是3(0x03)，而对于MQTT3.1.1版的协议，协议级别字段的值是4(0x04)。如果服务器发现连接报文中的协议级别字段是不支持的协议级别，服务端必须给发送一个返回码为0x01（不支持的协议级别）的CONNACK响应连接报文，然后终止客户端的连接请求。</p><p>连接标志字段涉及的内容比较多，它在协议级别之后使用一个字节表示，但分成很多个标志位，具体见 <a href="%E8%BF%9E%E6%8E%A5%E6%A0%87%E8%AF%86%E5%AD%97%E6%AE%B5.png">连接标识字段</a>。</p><p><img "" class="lazyload placeholder" data-original="/posts/41fa605b/%E8%BF%9E%E6%8E%A5%E6%A0%87%E8%AF%86%E5%AD%97%E6%AE%B5.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="连接标志字段"></p><p>bit0是MQTT保留的标志位，在连接过程中，服务器会检测连接标志的bit0是否为0，如果不为0则服务器认为这个连接报文是不合法的，会终止连接请求。</p><p>bit1是清除会话标志Clean Session，一般来说，客户端在请求连接服务器时总是将清除会话标志设置为0或1，在建立会话连接后，这个值就固定了，当然这个值的选择取决于具体的应用，如果清除会话标志设置为1，那么客户端不会收到旧的应用消息，而且在每次连接成功后都需要重新订阅相关的主题。清除会话标志设置为0的客户端在重新连接后会收到所有在它连接断开期间（其他发布者）发布的QoS1和QoS2级别的消息。因此，要确保不丢失连接断开期间的消息，需要使用QoS1或 QoS2级别，同时将清除会话标志设置为0。</p><p>bit2是遗嘱标志 Will Flag，如果该位被设置为1，表示如果客户端与服务器建立了会话，遗嘱消息（Will Message）将必须被存储在服务器中，当这个客户端断开连接的时候，遗嘱消息将被发送到订阅这个会话主题的所有订阅者，这个消息是很有用的，我们可以知道这个设备的状况，它是否已经掉线了，以备启动备用方案，当然，想要不发送遗嘱消息也是可以的，只需要让服务器端收到DISCONNECT报文时删除这个遗嘱消息即可。</p><p>bit3-bit4用于指定发布遗嘱消息时使用的服务质量等级，与其他消息的服务质量是一样的，遗嘱QoS的值可以等于0(0x00)，1(0x01)，2(0x02)，当然，使用遗嘱消息的前提是遗嘱标志位为1。</p><p>bit5表示遗嘱保留标志位，当客户端意外断开连接时，如果 Will Retain置一，那么服务器必须将遗嘱消息当作保留消息发布，反之则无需保留。</p><p>bit6是密码标志位Password Flag，如果密码标志被设置为0，有效载荷中不能包含密码字段，反之则必须包含密码字段。</p><p>bit6是用户名标志位User Name Flag，如果用户名标志被设置为0，有效载荷中不能包含用户名字段，反之则必须包含用户名字段。</p><p>保持连接字段是一个以秒为单位的时间间隔，它使用了两个字节来记录允许客户端最大空闲时间间隔，简单来说就是，客户端必须在这段时间中与服务器进行通信，让服务器知道客户端还处于连接状态而不是断开了，当然，如果没有任何其它的控制报文可以发送，客户端也必须要发送一个PINGREQ报文，以告知服务器还是处于连接状态的。</p><p>总的来说，整个CONNECT报文可变报头的内容如下，具体见 <a href="%E6%8A%A5%E6%96%87%E5%8F%AF%E5%8F%98%E6%8A%A5%E5%A4%B4.png">报文可变报头</a>。</p><p><img "" class="lazyload placeholder" data-original="/posts/41fa605b/%E6%8A%A5%E6%96%87%E5%8F%AF%E5%8F%98%E6%8A%A5%E5%A4%B4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="报文可变报头"></p><h4 id="CONNACK">1.4.2.2 CONNACK</h4><p>我们再来讲解一下CONNACK报文的可变报头部分，其实有了上一个的经验，这部分对大家来说是很简单的，它是由连接确认标志字段（Connect Acknowledge Flags）与连接返回码字段 （Connect Return code）组成，各占用1个字节。</p><p>它的第1个字节是 连接确认标志字段，bit1-bit7是保留位且必须设置为0， bit0是当前会话（Session Present）标志位。</p><p>它的第2个字节是返回码字段，如果服务器收到一个CONNECT报文，但出于某些原因无法处理它，服务器会返回一个包含返回码的CONNACK报文。如果服务器返回了一个返回码字段是非0的CONNACK报文，那么它必须关闭网络连接，返回码描述具体见表格21‑3。</p><p>表格 21‑3返回码值与对应的描述</p><table><thead><tr><th>返回码值</th><th>描述</th></tr></thead><tbody><tr><td>0x00</td><td>连接已被服务端接受</td></tr><tr><td>0x01</td><td>连接已拒绝，服务端不支持客户端请求的MQTT协议级别</td></tr><tr><td>0x02</td><td>连接已拒绝，服务器标识符是正确的UTF-8编码，但不允许使用</td></tr><tr><td>0x03</td><td>连接已拒绝，网络连接已建立，但MQTT服务不可用</td></tr><tr><td>0x04</td><td>连接已拒绝，用户名或密码的数据格式无效</td></tr><tr><td>0x05</td><td>连接已拒绝，客户端未被授权连接到此服务器</td></tr><tr><td>0x06~0xFF</td><td>保留未使用</td></tr></tbody></table><p>提示：如果服务端收到清理会话（CleanSession）标志为1的连接，除了将CONNACK报文中的返回码设置为0之外，还必须将CONNACK报文中的当前会话设置（Session Present）标志为0。</p><p>那么总的来说，CONNACK报文的可变报头部分内容具体见 <a href="CONNACK%E5%8F%AF%E5%8F%98%E6%8A%A5%E5%A4%B4.png">CONNACK可变报头</a>。</p><p><img "" class="lazyload placeholder" data-original="/posts/41fa605b/CONNACK%E5%8F%AF%E5%8F%98%E6%8A%A5%E5%A4%B4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="CONNACK可变报头"></p><p>在此，就不再对MQTT报文的可变报头部分过多赘述，大家可以参考MQTT协议手册，里面有很详细的描述。</p><h3 id="有效载荷">1.4.3 有效载荷</h3><p>有效载荷也是存在与某些报文中，不同的报文有效载荷也是不一样的，比如：</p><p>CONNECT报文的有效载荷（payload）包含一个或多个以长度为前缀的字段，可变报头中的标志决定是否包含这些字段。如果包含的话，必须按这个顺序出现：客户端标识符，遗嘱主题，遗嘱消息，用户名，密码 。</p><p>SUBSCRIBE报文的有效载荷包含了一个主题过滤器列表，它们标识着客户端想要订阅的主题，每一个过滤器后面跟着一个字节，这个字节被叫做服务质量要求（Requested QoS），它给出了服务端向客户端发送应用消息所允许的最大QoS等级。</p><p>这里只是讲述了一小部分内容，关于具体的有效载荷部分也可以去看MQTT手册，此处就不再赘述。</p><h2 id="移植MQTT协议">1.5 移植MQTT协议</h2><p>初步了解了MQTT协议，那么我们怎么在开发板上运行它呢？首先，LwIP协议肯定是要的，因为MQTT是应用层协议，基于TCP协议至少，首先我们就需要把LwIP协议跑通，我们就使用Socket API来进行移植。</p><p>首先下载MQTT的库： <a href="https://github.com/eclipse/paho.mqtt.embedded-c%E3%80%82">https://github.com/eclipse/paho.mqtt.embedded-c。</a></p><p>然后创建一个MQTT文件夹，再将MQTTPacketsrc目录下的文件添加到工程目录MQTT文件夹， 再将MQTTPacketsamples目录下的transport.c、transport.h添加到这个文件夹下， 添加完成后文件夹内容具体见 <a href="MQTT%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E5%86%85%E5%AE%B9.png">MQTT文件夹下的内容</a>。</p><p><img "" class="lazyload placeholder" data-original="/posts/41fa605b/MQTT%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E5%86%85%E5%AE%B9.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="MQTT文件夹下的内容"></p><p>我们把这些文件加入我们的工程之中，并且指定头文件路径，然后实现transport.c文件的移植层接口，其内容具体见代码清单</p><p>代码清单 transport.c文件内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;transport.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lwip/opt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lwip/arch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lwip/api.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lwip/inet.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lwip/sockets.h&quot;</span>                   (1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> mysock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">** 函数名称: transport_sendPacketBuffer</span></span><br><span class="line"><span class="comment">** 函数功能: 以TCP方式发送数据</span></span><br><span class="line"><span class="comment">** 入口参数: unsigned char* buf：数据缓冲区</span></span><br><span class="line"><span class="comment">**           int buflen：数据长度</span></span><br><span class="line"><span class="comment">** 出口参数: &lt;0发送数据失败</span></span><br><span class="line"><span class="comment">************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">transport_sendPacketBuffer</span><span class="params">( <span class="keyword">uint8_t</span>* buf, <span class="keyword">int32_t</span> buflen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> rc;</span><br><span class="line">    rc = write(mysock, buf, buflen);                (<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">** 函数名称: transport_getdata</span></span><br><span class="line"><span class="comment">** 函数功能: 接收TCP数据</span></span><br><span class="line"><span class="comment">** 入口参数: unsigned char* buf：数据缓冲区</span></span><br><span class="line"><span class="comment">**           int count：数据长度</span></span><br><span class="line"><span class="comment">** 出口参数: &lt;=0接收数据失败</span></span><br><span class="line"><span class="comment">************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">transport_getdata</span><span class="params">(<span class="keyword">uint8_t</span>* buf, <span class="keyword">int32_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> rc;</span><br><span class="line"></span><br><span class="line">    rc = recv(mysock, buf, count, <span class="number">0</span>);               (<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">** 函数名称: transport_open</span></span><br><span class="line"><span class="comment">** 函数功能: 打开一个接口，并且和服务器 建立连接</span></span><br><span class="line"><span class="comment">** 入口参数: char* servip:服务器域名</span></span><br><span class="line"><span class="comment">**           int   port:端口号</span></span><br><span class="line"><span class="comment">** 出口参数: &lt;0打开连接失败</span></span><br><span class="line"><span class="comment">************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">transport_open</span><span class="params">(<span class="keyword">int8_t</span>* servip, <span class="keyword">int32_t</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> *sock = &amp;mysock;</span><br><span class="line">    <span class="keyword">int32_t</span> ret;</span><br><span class="line"><span class="comment">//  int32_t opt;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化服务器信息</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sin_len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//填写服务器端口号</span></span><br><span class="line">    addr.sin_port = PP_HTONS(port);</span><br><span class="line">    <span class="comment">//填写服务器IP地址</span></span><br><span class="line">    addr.sin_addr.s_addr = inet_addr((<span class="keyword">const</span> <span class="keyword">char</span>*)servip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建SOCK</span></span><br><span class="line">    *sock = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);  (<span class="number">4</span>)</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    ret = connect(*sock,(struct sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(addr));      (<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//关闭链接</span></span><br><span class="line">        close(*sock);</span><br><span class="line">        <span class="comment">//连接失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接成功,设置超时时间1000ms</span></span><br><span class="line"><span class="comment">//  opt = 1000;</span></span><br><span class="line"><span class="comment">//  setsockopt(*sock,SOL_SOCKET,SO_RCVTIMEO,&amp;opt,sizeof(int));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回套接字</span></span><br><span class="line">    <span class="keyword">return</span> *sock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">** 函数名称: transport_close</span></span><br><span class="line"><span class="comment">** 函数功能: 关闭套接字</span></span><br><span class="line"><span class="comment">** 入口参数: unsigned char* buf：数据缓冲区</span></span><br><span class="line"><span class="comment">**           int buflen：数据长度</span></span><br><span class="line"><span class="comment">** 出口参数: &lt;0发送数据失败</span></span><br><span class="line"><span class="comment">************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transport_close</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"><span class="comment">//  rc = close(mysock);</span></span><br><span class="line">    rc = shutdown(mysock, SHUT_WR);</span><br><span class="line">    rc = recv(mysock, <span class="literal">NULL</span>, (<span class="keyword">size_t</span>)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    rc = close(mysock);                     (<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码清单 **(1)**：添加头文件，我们使用Socket API就添加LwIP中对应的头文件。</p><p>代码清单 (2)**：transport_sendPacketBuffer()函数是MQTT发送数据函数，这个函数必须以TCP协议发送数据， 参数buf指定数据缓冲区，buflen指定了数据长度，调用write()函数进行发送数据，并且返回发送状态。</p><p>代码清单 **(3)**：transport_getdata()函数是MQTT接收数据的函数，需要我们用Socket API获取接收到的数据，参数buf指定数据缓冲区，count指定了获取数据长度，我们只要调用recv()将数据获取回来即可。</p><p>代码清单 **(4)(5)**：transport_open()函数用于打开一个连接接口，并且让客户端和服务器建立连接， 这个函数是实现MQTT的前提，必须产生TCP连接才能进入下一步操作，因此我们在函数中需要根据配置信息连接到服务器中， socket()用于创建一个套接字，并且调用connect()函数连接到服务器上，如果连接失败则关闭套接字，返回-1。</p><p>代码清单 (6)**：transport_close()是MQTT与服务器断开的时候会调用的函数，它用来关闭一个套接字的。</p><p>然后我们在工程中实现两个线程，一个是MQTT发送线程，另一个是MQTT接收线程，这样子的话，我们的MQTT协议就在开发板中跑起来了， 我们提供了完整的MQTT客户端连接到服务器demo，下面简单实现两个线程的处理，更多的代码请参考我们的工程，我们首先在USER目录下创建一个mqttclient.c文件，然后加入 代码清单所示代码。</p><p>代码清单mqttclient.c文件内容（部分）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mqtt_recv_thread</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> curtick;</span><br><span class="line">    <span class="keyword">uint8_t</span> no_mqtt_msg_exchange = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> buf[MSG_MAX_LEN];</span><br><span class="line">    <span class="keyword">int32_t</span> buflen = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="keyword">int32_t</span> type;</span><br><span class="line">    fd_set readfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span>      <span class="comment">//等待时间</span></span><br><span class="line">    tv.tv_sec = <span class="number">0</span>;</span><br><span class="line">    tv.tv_usec = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MQTT_START:</span><br><span class="line">    <span class="comment">//开始连接</span></span><br><span class="line">    Client_Connect();</span><br><span class="line">    <span class="comment">//获取当前滴答，作为心跳包起始时间</span></span><br><span class="line">    curtick = xTaskGetTickCount();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//表明无数据交换</span></span><br><span class="line">        no_mqtt_msg_exchange = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        FD_ZERO(&amp;readfd);</span><br><span class="line">        FD_SET(MQTT_Socket,&amp;readfd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待可读事件</span></span><br><span class="line">        select(MQTT_Socket+<span class="number">1</span>,&amp;readfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;tv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断MQTT服务器是否有数据</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(MQTT_Socket,&amp;readfd) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//读取数据包--注意这里参数为0，不阻塞</span></span><br><span class="line">            type = ReadPacketTimeout(MQTT_Socket,buf,buflen,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (type != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mqtt_pktype_ctl(type,buf,buflen);</span><br><span class="line">                <span class="comment">//表明有数据交换</span></span><br><span class="line">                no_mqtt_msg_exchange = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//获取当前滴答，作为心跳包起始时间</span></span><br><span class="line">                curtick = xTaskGetTickCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里主要目的是定时向服务器发送PING保活命令</span></span><br><span class="line">        <span class="keyword">if</span> ((xTaskGetTickCount() - curtick) &gt;(KEEPLIVE_TIME/<span class="number">2</span>*<span class="number">1000</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            curtick = xTaskGetTickCount();</span><br><span class="line">            <span class="comment">//判断是否有数据交换</span></span><br><span class="line">            <span class="keyword">if</span> (no_mqtt_msg_exchange == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果有数据交换，这次就不需要发送PING消息</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MQTT_PingReq(MQTT_Socket) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//重连服务器</span></span><br><span class="line">                PRINT_DEBUG(<span class="string">&quot;发送保持活性ping失败....\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> CLOSE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//心跳成功</span></span><br><span class="line">            PRINT_DEBUG(<span class="string">&quot;发送保持活性ping作为心跳成功....\n&quot;</span>);</span><br><span class="line">            <span class="comment">//表明有数据交换</span></span><br><span class="line">            no_mqtt_msg_exchange = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">CLOSE:</span><br><span class="line">    <span class="comment">//关闭链接</span></span><br><span class="line">    transport_close();</span><br><span class="line">    <span class="comment">//重新链接服务器</span></span><br><span class="line">    <span class="keyword">goto</span> MQTT_START;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mqtt_send_thread</span><span class="params">(<span class="keyword">void</span> *pvParameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> ret;</span><br><span class="line">    <span class="keyword">uint8_t</span> no_mqtt_msg_exchange = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> curtick;</span><br><span class="line">    <span class="keyword">uint8_t</span> res;</span><br><span class="line">    <span class="comment">/* 定义一个创建信息返回值，默认为pdTRUE */</span></span><br><span class="line">    BaseType_t xReturn = pdTRUE;</span><br><span class="line">    <span class="comment">/* 定义一个接收消息的变量 */</span></span><br><span class="line"> <span class="comment">// uint32_t* r_data;</span></span><br><span class="line">    DHT11_Data_TypeDef* recv_data;</span><br><span class="line">    <span class="comment">//初始化json数据</span></span><br><span class="line">    cJSON* cJSON_Data = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON_Data = cJSON_Data_Init();</span><br><span class="line">    <span class="keyword">double</span> a,b;</span><br><span class="line">    </span><br><span class="line">MQTT_SEND_START:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        xReturn = xQueueReceive( MQTT_Data_Queue,    <span class="comment">/* 消息队列的句柄 */</span></span><br><span class="line">                                &amp;recv_data,      <span class="comment">/* 发送的消息内容 */</span></span><br><span class="line">                                <span class="number">3000</span>); <span class="comment">/* 等待时间 3000ms */</span></span><br><span class="line">        <span class="keyword">if</span> (xReturn == pdTRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            a = recv_data-&gt;temperature;</span><br><span class="line">            b = recv_data-&gt;humidity;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a = %f,b = %f\n&quot;</span>,a,b);</span><br><span class="line">            <span class="comment">//更新数据</span></span><br><span class="line">            res = cJSON_Update(cJSON_Data,TEMP_NUM,&amp;a);</span><br><span class="line">            res = cJSON_Update(cJSON_Data,HUM_NUM,&amp;b);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (UPDATE_SUCCESS == res)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//更新数据成功，</span></span><br><span class="line">                <span class="keyword">char</span>* p = cJSON_Print(cJSON_Data);</span><br><span class="line">                <span class="comment">//发布消息</span></span><br><span class="line">                ret = MQTTMsgPublish(MQTT_Socket,(<span class="keyword">char</span>*)TOPIC,QOS0,(<span class="keyword">uint8_t</span>*)p);</span><br><span class="line">                <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//表明有数据交换</span></span><br><span class="line">                    no_mqtt_msg_exchange = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//获取当前滴答，作为心跳包起始时间</span></span><br><span class="line">                    curtick = xTaskGetTickCount();</span><br><span class="line">                &#125;</span><br><span class="line">                vPortFree(p);</span><br><span class="line">                p = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                PRINT_DEBUG(<span class="string">&quot;update fail\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里主要目的是定时向服务器发送PING保活命令</span></span><br><span class="line">        <span class="keyword">if</span> ((xTaskGetTickCount() - curtick) &gt;(KEEPLIVE_TIME/<span class="number">2</span>*<span class="number">1000</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            curtick = xTaskGetTickCount();</span><br><span class="line">            <span class="comment">//判断是否有数据交换</span></span><br><span class="line">            <span class="keyword">if</span> (no_mqtt_msg_exchange == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果有数据交换，这次就不需要发送PING消息</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MQTT_PingReq(MQTT_Socket) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//重连服务器</span></span><br><span class="line">                PRINT_DEBUG(<span class="string">&quot;发送保持活性ping失败....\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> MQTT_SEND_CLOSE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//心跳成功</span></span><br><span class="line">            PRINT_DEBUG(<span class="string">&quot;发送保持活性ping作为心跳成功....\n&quot;</span>);</span><br><span class="line">            <span class="comment">//表明有数据交换</span></span><br><span class="line">            no_mqtt_msg_exchange = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">MQTT_SEND_CLOSE:</span><br><span class="line">    <span class="comment">//关闭链接</span></span><br><span class="line">    transport_close();</span><br><span class="line">    <span class="comment">//开始连接</span></span><br><span class="line">    Client_Connect();</span><br><span class="line">    <span class="keyword">goto</span> MQTT_SEND_START;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mqtt_thread_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sys_thread_new(<span class="string">&quot;mqtt_recv_thread&quot;</span>, mqtt_recv_thread, <span class="literal">NULL</span>, <span class="number">2048</span>, <span class="number">6</span>);</span><br><span class="line">    sys_thread_new(<span class="string">&quot;mqtt_send_thread&quot;</span>, mqtt_send_thread, <span class="literal">NULL</span>, <span class="number">2048</span>, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cJSON移植">1.6 cJSON移植</h2><p>其实在mqttclient.c文件中我们就使用了cJSON的内容，而且，在连接到各大云平台中经常使用JSON格式发送和接收数据，因此我们必须将cJSON也移植到我们的工程中。cJSON是一个用于解析JSON包的C语言库，库文件为cJSON.c和cJSON.h， 所有的实现都在这两个文件中。</p><p>cJSON的移植很简单，首先我们首先下载到cJSON的源码文件：<a href="https://github.com/DaveGamble/cJSON%E3%80%82">https://github.com/DaveGamble/cJSON。</a></p><p>然后在文件目录下找到cJSON.c和cJSON.h，将它们拷贝到我们的工程目录下的cJSON文件夹下（如果没有就创建它）， 然后添加到工程中，并且指定头文件路径即可，因为我们使用的是FreeRTOS操作系统，那么cJSON中的动态内存分配、 释放函数就需要配合操作系统的动态内存分配函数与释放函数，在cJSON.c文件中修改 代码清单所示的代码即可， 当然还需要注意包含FreeRTOS相关的头文件。</p><p>代码清单 cJSON.c文件修改的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * CJSON_CDECL <span class="title">internal_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    return malloc(size);</span></span><br><span class="line">    <span class="keyword">return</span> pvPortMalloc(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> CJSON_CDECL <span class="title">internal_free</span><span class="params">(<span class="keyword">void</span> *pointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    free(pointer);</span></span><br><span class="line">    vPortFree(pointer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * CJSON_CDECL <span class="title">internal_realloc</span><span class="params">(<span class="keyword">void</span> *pointer,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    return realloc(pointer, size);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_malloc pvPortMalloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_free vPortFree</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> internal_realloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>为了更好利用cJSON提供的函数来处理我们的程序，我们简单对cJSON进行了封装，包含cJSON格式数据的初始化、更新、解析等，当然大家也可以自行封装使用，我们创建一个cJSON_Process.c文件，并添加以下代码，具体见 代码清单。</p><p>代码清单 cJSON_Process.c文件内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cJSON_Process.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">cJSON* <span class="title">cJSON_Data_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cJSON* cJSON_Root = <span class="literal">NULL</span>;    <span class="comment">//json根节点</span></span><br><span class="line"></span><br><span class="line">    cJSON_Root = cJSON_CreateObject();   <span class="comment">/*创建项目*/</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == cJSON_Root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="comment">/*添加元素  键值对*/</span></span><br><span class="line">    cJSON_AddStringToObject(cJSON_Root, NAME, DEFAULT_NAME);</span><br><span class="line">    cJSON_AddNumberToObject(cJSON_Root, TEMP_NUM, DEFAULT_TEMP_NUM);</span><br><span class="line">    cJSON_AddNumberToObject(cJSON_Root, HUM_NUM, DEFAULT_HUM_NUM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* p = cJSON_Print(cJSON_Root);  <span class="comment">/*p 指向的字符串是json格式的*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  PRINT_DEBUG(&quot;%s\n&quot;,p);</span></span><br><span class="line"></span><br><span class="line">    vPortFree(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cJSON_Root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">cJSON_Update</span><span class="params">(<span class="keyword">const</span> cJSON * <span class="keyword">const</span> object,<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> <span class="built_in">string</span>,<span class="keyword">void</span> *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cJSON* node = <span class="literal">NULL</span>;    <span class="comment">//json根节点</span></span><br><span class="line">    node = cJSON_GetObjectItem(object,<span class="built_in">string</span>);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (cJSON_IsBool(node))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> *b = (<span class="keyword">int</span>*)d;</span><br><span class="line"><span class="comment">//    printf (&quot;d = %d&quot;,*b);</span></span><br><span class="line">        cJSON_GetObjectItem(object,<span class="built_in">string</span>)-&gt;type = *b ? cJSON_True : cJSON_False;</span><br><span class="line"><span class="comment">//    char* p = cJSON_Print(object);    /*p 指向的字符串是json格式的*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cJSON_IsString(node))</span><br><span class="line">    &#123;</span><br><span class="line">        cJSON_GetObjectItem(object,<span class="built_in">string</span>)-&gt;valuestring = (<span class="keyword">char</span>*)d;</span><br><span class="line"><span class="comment">//    char* p = cJSON_Print(object);    /*p 指向的字符串是json格式的*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cJSON_IsNumber(node))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> *num = (<span class="keyword">double</span>*)d;</span><br><span class="line"><span class="comment">//    printf (&quot;num = %f&quot;,*num);</span></span><br><span class="line"><span class="comment">//    cJSON_GetObjectItem(object,string)-&gt;valueint = (double)*num;</span></span><br><span class="line">        cJSON_GetObjectItem(object,<span class="built_in">string</span>)-&gt;valuedouble = (<span class="keyword">double</span>)*num;</span><br><span class="line"><span class="comment">//    char* p = cJSON_Print(object);    /*p 指向的字符串是json格式的*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Proscess</span><span class="params">(<span class="keyword">void</span>* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PRINT_DEBUG(<span class="string">&quot;开始解析JSON数据&quot;</span>);</span><br><span class="line">    cJSON *root,*json_name,*json_temp_num,*json_hum_num;</span><br><span class="line">    root = cJSON_Parse((<span class="keyword">char</span>*)data); <span class="comment">//解析成json形式</span></span><br><span class="line"></span><br><span class="line">    json_name = cJSON_GetObjectItem( root , NAME);  <span class="comment">//获取键值内容</span></span><br><span class="line">    json_temp_num = cJSON_GetObjectItem( root , TEMP_NUM );</span><br><span class="line">    json_hum_num = cJSON_GetObjectItem( root , HUM_NUM );</span><br><span class="line"></span><br><span class="line">    PRINT_DEBUG(<span class="string">&quot;name:%s\n temp_num:%f\n hum_num:%f\n&quot;</span>,</span><br><span class="line">                json_name-&gt;valuestring,</span><br><span class="line">                json_temp_num-&gt;valuedouble,</span><br><span class="line">                json_hum_num-&gt;valuedouble);</span><br><span class="line"></span><br><span class="line">    cJSON_Delete(root);  <span class="comment">//释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里，我们的整个MQTT的程序框架基本完成了，下面我们就开始使用MQTT程序</p>]]></content>
      
      
      <categories>
          
          <category> ESP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQTT协议详解</title>
      <link href="posts/308177ca.html"/>
      <url>posts/308177ca.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-概述-Introduction">1 第一章 概述 Introduction</h1><h2 id="1-1-MQTT协议的组织结构-Organization-of-MQTT">1.1 1.1 MQTT协议的组织结构 Organization of MQTT</h2><p>本规范分为七个章节：</p><ul><li>第一章 – 介绍</li><li>第二章 – MQTT控制报文格式</li><li>第三章 – MQTT控制报文</li><li>第四章 – 操作行为</li><li>第五章 – 安全</li><li>第六章 – 使用WebSocket</li><li>第七章 – 一致性目标</li><li>附录B – 强制性规范声明</li></ul><h2 id="1-2-术语-Terminology">1.2 1.2 术语 Terminology</h2><p>本规范中用到的关键字 <strong>必须</strong> MUST，<strong>不能</strong> MUST NOT，<strong>要求</strong> REQUIRED，<strong>将会</strong> SHALL，<strong>不会</strong> SHALL NOT，<strong>应该</strong> SHOULD，<strong>不应该</strong> SHOULD NOT，<strong>推荐</strong> RECOMMENDED，<strong>可以</strong> MAY，<strong>可选</strong> OPTIONAL 都是按照 IETF RFC 2119 中的描述解释。</p><p><strong>网络连接 Network Connection</strong></p><p>MQTT使用的底层传输协议基础设施。</p><ul><li>客户端使用它连接服务端。</li><li>它提供有序的、可靠的、双向字节流传输。</li></ul><p>例子见4.2节。</p><p><strong>应用消息 Application Message</strong> MQTT协议通过网络传输应用数据。应用消息通过MQTT传输时，它们有关联的服务质量（QoS）和主题（Topic）。</p><p><strong>客户端 Client</strong><br>使用MQTT的程序或设备。客户端总是通过网络连接到服务端。它可以</p><ul><li>发布应用消息给其它相关的客户端。</li><li>订阅以请求接受相关的应用消息。</li><li>取消订阅以移除接受应用消息的请求。</li><li>从服务端断开连接。</li></ul><p><strong>服务端 Server</strong><br>一个程序或设备，作为发送消息的客户端和请求订阅的客户端之间的中介。服务端</p><ul><li>接受来自客户端的网络连接。</li><li>接受客户端发布的应用消息。</li><li>处理客户端的订阅和取消订阅请求。</li><li>转发应用消息给符合条件的已订阅客户端。</li></ul><p><strong>订阅 Subscription</strong><br>订阅包含一个主题过滤器（Topic Filter）和一个最大的服务质量（QoS）等级。订阅与单个会话（Session）关联。会话可以包含多于一个的订阅。会话的每个订阅都有一个不同的主题过滤器。</p><p><strong>主题名 Topic Name</strong><br>附加在应用消息上的一个标签，服务端已知且与订阅匹配。服务端发送应用消息的一个副本给每一个匹配的客户端订阅。</p><p><strong>主题过滤器 Topic Filter</strong><br>订阅中包含的一个表达式，用于表示相关的一个或多个主题。主题过滤器可以使用通配符。</p><p><strong>会话 Session</strong><br>客户端和服务端之间的状态交互。一些会话持续时长与网络连接一样，另一些可以在客户端和服务端的多个连续网络连接间扩展。</p><p><strong>控制报文 MQTT Control Packet</strong><br>通过网络连接发送的信息数据包。MQTT规范定义了十四种不同类型的控制报文，其中一个（PUBLISH报文）用于传输应用消息。</p><h2 id="1-5-数据表示-Data-representations">1.3 1.5 数据表示 Data representations</h2><h3 id="1-5-1-二进制位-Bits">1.3.1 1.5.1 二进制位 Bits</h3><p>字节中的位从0到7。第7位是最高有效位，第0位是最低有效位。</p><h3 id="1-5-2-整数数值-Integer-data-values">1.3.2 1.5.2 整数数值 Integer data values</h3><p>整数数值是16位，使用大端序（big-endian，高位字节在低位字节前面）。这意味着一个16位的字在网络上表示为最高有效字节（MSB），后面跟着最低有效字节（LSB）。</p><h3 id="1-5-3-UTF-8编码字符串-UTF-8-encoded-strings">1.3.3 1.5.3 UTF-8编码字符串 UTF-8 encoded strings</h3><p>后面会描述的控制报文中的文本字段编码为UTF-8格式的字符串。UTF-8 是一个高效的Unicode字符编码格式，为了支持基于文本的通信，它对ASCII字符的编码做了优化。</p><p>每一个字符串都有一个两字节的长度字段作为前缀，它给出这个字符串UTF-8编码的字节数，它们在图例 1.1 UTF-8编码字符串的结构中描述。因此可以传送的UTF-8编码的字符串大小有一个限制，不能超过 65535字节。</p><p>除非另有说明，所有的UTF-8编码字符串的长度都必须在0到65535字节这个范围内。</p><h5 id="图例-1-1-UTF-8编码字符串的结构-Structure-of-UTF-8-encoded-strings">1.3.3.0.1 图例 1.1 UTF-8编码字符串的结构 Structure of UTF-8 encoded strings</h5><table><thead><tr><th><strong>二进制位</strong></th><th>7-0</th></tr></thead><tbody><tr><td>byte 1</td><td>字符串长度的最高有效字节（MSB）</td></tr><tr><td>byte 2</td><td>字符串长度的最低有效字节（LSB）</td></tr><tr><td>byte 3 ….</td><td>如果长度大于0，这里是UTF-8编码的字符数据。</td></tr></tbody></table><p>UTF-8编码字符串中的字符数据<strong>必须</strong>是按照Unicode规范Unicode定义的和在RFC3629中重申的有效的UTF-8格式。特别需要指出的是，这些数据<strong>不能</strong>包含字符码在U+D800和U+DFFF之间的数据。如果服务端或客户端收到了一个包含无效UTF-8字符的控制报文，它<strong>必须</strong>关闭网络连接 [MQTT-1.5.3-1]。</p><p>UTF-8编码的字符串<strong>不能</strong>包含空字符U+0000。如果客户端或服务端收到了一个包含U+0000的控制报文，它<strong>必须</strong>关闭网络连接 [MQTT-1.5.3-2]。</p><p>数据中<strong>不应该</strong>包含下面这些Unicode代码点的编码。如果一个接收者（服务端或客户端）收到了包含下列任意字符的控制报文，它<strong>可以</strong>关闭网络连接：</p><ul><li>U+0001和U+001F之间的控制字符</li><li>U+007F和U+009F之间的控制字符</li><li>Unicode规范定义的非字符代码点（例如U+0FFFF）</li><li>Unicode规范定义的保留字符（例如U+0FFFF）</li></ul><p>UTF-8编码序列0XEF 0xBB 0xBF总是被解释为U+FEFF（零宽度非换行空白字符），无论它出现在字符串的什么位置，报文接收者都不能跳过或者剥离它 [MQTT-1.5.3-3]。</p><h4 id="非规范示例-Non-normative-example">1.3.3.1 非规范示例 Non normative example</h4><blockquote><p>例如，字符串 A𪛔 是一个拉丁字母A后面跟着一个代码点U+2A6D4(它表示一个中日韩统一表意文字扩展B中的字符)，这个字符串编码如下：</p></blockquote><h5 id="图例-1-2-UTF-8编码字符串非规范示例-UTF-8-encoded-string-non-normative-example">1.3.3.1.1 图例 1.2 UTF-8编码字符串非规范示例 UTF-8 encoded string non normative example</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>字符串长度 MSB (0x00)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>字符串长度 LSB (0x05)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>byte 3</td><td>‘A’ (0x41)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>byte 4</td><td>(0xF0)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 5</td><td>(0xAA)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>byte 6</td><td>(0x9B)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>byte 7</td><td>(0x94)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><h3 id="1-6-编辑约定-Editing-conventions">1.3.4 1.6 编辑约定 Editing conventions</h3><p>本规范用黄色高亮的文本标识一致性声明，每个一致性声明都分配了一个这种格式的引用：[MQTT-x.x.x-y]。</p><h1 id="第二章-MQTT控制报文格式-MQTT-Control-Packet-format">2 第二章 MQTT控制报文格式 MQTT Control Packet format</h1><h2 id="2-1-MQTT控制报文的结构-Structure-of-an-MQTT-Control-Packet">2.1 2.1 MQTT控制报文的结构 Structure of an MQTT Control Packet</h2><p>MQTT协议通过交换预定义的MQTT控制报文来通信。这一节描述这些报文的格式。</p><p>MQTT控制报文由三部分组成，按照图例 2.1 –MQTT控制报文的结构描述的顺序：</p><h5 id="图例-2-1-–MQTT控制报文的结构">2.1.0.0.1 图例 2.1 –MQTT控制报文的结构</h5><table><thead><tr><th>Fixed header</th><th>固定报头，所有控制报文都包含</th></tr></thead><tbody><tr><td>Variable header</td><td>可变报头，部分控制报文包含</td></tr><tr><td>Payload</td><td>有效载荷，部分控制报文包含</td></tr></tbody></table><h2 id="2-2-固定报头-Fixed-header">2.2 2.2 固定报头 Fixed header</h2><p>每个MQTT控制报文都包含一个固定报头。[图例 2.2 -固定报头的格式]描述了固定报头的格式。</p><h5 id="图例-2-2-固定报头的格式">2.2.0.0.1 图例 2.2 -固定报头的格式</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文的类型</td><td>用于指定控制报文类型的标志位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2…</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="2-2-1-MQTT控制报文的类型-MQTT-Control-Packet-type">2.2.1 2.2.1 MQTT控制报文的类型 MQTT Control Packet type</h3><p><strong>位置：</strong>第1个字节，二进制位7-4。</p><p>表示为4位无符号值，这些值的定义见 [表格 2.1 -控制报文的类型]</p><h5 id="表格-2-1-控制报文的类型">2.2.1.0.1 表格 2.1 -控制报文的类型</h5><table><thead><tr><th><strong>名字</strong></th><th><strong>值</strong></th><th><strong>报文流动方向</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Reserved</td><td>0</td><td>禁止</td><td>保留</td></tr><tr><td>CONNECT</td><td>1</td><td>客户端到服务端</td><td>客户端请求连接服务端</td></tr><tr><td>CONNACK</td><td>2</td><td>服务端到客户端</td><td>连接报文确认</td></tr><tr><td>PUBLISH</td><td>3</td><td>两个方向都允许</td><td>发布消息</td></tr><tr><td>PUBACK</td><td>4</td><td>两个方向都允许</td><td>QoS 1消息发布收到确认</td></tr><tr><td>PUBREC</td><td>5</td><td>两个方向都允许</td><td>发布收到（保证交付第一步）</td></tr><tr><td>PUBREL</td><td>6</td><td>两个方向都允许</td><td>发布释放（保证交付第二步）</td></tr><tr><td>PUBCOMP</td><td>7</td><td>两个方向都允许</td><td>QoS 2消息发布完成（保证交互第三步）</td></tr><tr><td>SUBSCRIBE</td><td>8</td><td>客户端到服务端</td><td>客户端订阅请求</td></tr><tr><td>SUBACK</td><td>9</td><td>服务端到客户端</td><td>订阅请求报文确认</td></tr><tr><td>UNSUBSCRIBE</td><td>10</td><td>客户端到服务端</td><td>客户端取消订阅请求</td></tr><tr><td>UNSUBACK</td><td>11</td><td>服务端到客户端</td><td>取消订阅报文确认</td></tr><tr><td>PINGREQ</td><td>12</td><td>客户端到服务端</td><td>心跳请求</td></tr><tr><td>PINGRESP</td><td>13</td><td>服务端到客户端</td><td>心跳响应</td></tr><tr><td>DISCONNECT</td><td>14</td><td>客户端到服务端</td><td>客户端断开连接</td></tr><tr><td>Reserved</td><td>15</td><td>禁止</td><td>保留</td></tr></tbody></table><h3 id="2-2-2-标志-Flags">2.2.2 2.2.2 标志 Flags</h3><p>固定报头第1个字节的剩余的4位 [3-0]包含每个MQTT控制报文类型特定的标志，见 [表格 2.2 -标志位]。表格 2.2中任何标记为“保留”的标志位，都是保留给以后使用的，<strong>必须</strong>设置为表格中列出的值 [MQTT-2.2.2-1]。如果收到非法的标志，接收者<strong>必须</strong>关闭网络连接。有关错误处理的详细信息见 4.8节 [MQTT-2.2.2-2]。</p><h5 id="表格-2-2-标志位-Flag-Bits">2.2.2.0.1 表格 2.2 - 标志位 Flag Bits</h5><table><thead><tr><th><strong>控制报文</strong></th><th><strong>固定报头标志</strong></th><th><strong>Bit 3</strong></th><th><strong>Bit 2</strong></th><th><strong>Bit 1</strong></th><th><strong>Bit 0</strong></th></tr></thead><tbody><tr><td>CONNECT</td><td>Reserved</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>CONNACK</td><td>Reserved</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>PUBLISH</td><td>Used in MQTT 3.1.1</td><td>DUP1</td><td>QoS2</td><td>QoS2</td><td>RETAIN3</td></tr><tr><td>PUBACK</td><td>Reserved</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>PUBREC</td><td>Reserved</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>PUBREL</td><td>Reserved</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>PUBCOMP</td><td>Reserved</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>SUBSCRIBE</td><td>Reserved</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>SUBACK</td><td>Reserved</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>UNSUBSCRIBE</td><td>Reserved</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>UNSUBACK</td><td>Reserved</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>PINGREQ</td><td>Reserved</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>PINGRESP</td><td>Reserved</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>DISCONNECT</td><td>Reserved</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><ul><li>DUP1 =控制报文的重复分发标志</li><li>QoS2 = PUBLISH报文的服务质量等级</li><li>RETAIN3 = PUBLISH报文的保留标志</li></ul><p>PUBLISH控制报文中的DUP, QoS和RETAIN标志的描述见 3.3.1节。</p><h3 id="2-2-3-剩余长度-Remaining-Length">2.2.3 2.2.3 剩余长度 Remaining Length</h3><p><strong>位置：</strong>从第2个字节开始。</p><p>剩余长度（Remaining Length）表示当前报文剩余部分的字节数，包括可变报头和负载的数据。剩余长度不包括用于编码剩余长度字段本身的字节数。</p><p>剩余长度字段使用一个变长度编码方案，对小于128的值它使用单字节编码。更大的值按下面的方式处理。低7位有效位用于编码数据，最高有效位用于指示是否有更多的字节。因此每个字节可以编码128个数值和一个<em>延续位（continuation bit）</em>。剩余长度字段最大4个字节。</p><blockquote><p><strong>非规范评注</strong></p><p>例如，十进制数64会被编码为一个字节，数值是64，十六进制表示为0x40,。十进制数字321(=65+2*128)被编码为两个字节，最低有效位在前。第一个字节是 65+128=193。注意最高位为1表示后面至少还有一个字节。第二个字节是2。</p><p><strong>非规范评注</strong></p><p>这允许应用发送最大256MB(268,435,455)大小的控制报文。这个数值在报文中的表示是：0xFF,0xFF,0xFF,0x7F。</p><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/02-ControlPacketFormat.html#_Table_2.4_Size">表格 2.4剩余长度字段的大小</a>展示了剩余长度字段所表示的值随字节增长。</p></blockquote><h5 id="表格-2-4剩余长度字段的大小-Size-of-Remaining-Length-field">2.2.3.0.1 表格 2.4剩余长度字段的大小 Size of Remaining Length field</h5><table><thead><tr><th><strong>字节数</strong></th><th><strong>最小值</strong></th><th><strong>最大值</strong></th></tr></thead><tbody><tr><td>1</td><td>0 (0x00)</td><td>127 (0x7F)</td></tr><tr><td>2</td><td>128 (0x80, 0x01)</td><td>16 383 (0xFF, 0x7F)</td></tr><tr><td>3</td><td>16 384 (0x80, 0x80, 0x01)</td><td>2 097 151 (0xFF, 0xFF, 0x7F)</td></tr><tr><td>4</td><td>2 097 152 (0x80, 0x80, 0x80, 0x01)</td><td>268 435 455 (0xFF, 0xFF, 0xFF, 0x7F)</td></tr></tbody></table><p>分别表示（每个字节的低7位用于编码数据，最高位是标志位）：</p><ul><li>1个字节时，从0(0x00)到127(0x7f)</li><li>2个字节时，从128(0x80,0x01)到16383(0Xff,0x7f)</li><li>3个字节时，从16384(0x80,0x80,0x01)到2097151(0xFF,0xFF,0x7F)</li><li>4个字节时，从2097152(0x80,0x80,0x80,0x01)到268435455(0xFF,0xFF,0xFF,0x7F)</li></ul><blockquote><p><strong>非规范评注</strong></p><p>非负整数X使用变长编码方案的算法如下：</p><p>``` do encodedByte = X MOD 128 X = X DIV 128 // if there are more data to encode, set the top bit of this byte if ( X &gt; 0 ) encodedByte = encodedByte OR 128 endif ‘output’ encodedByte while ( X &gt; 0 )</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;MOD是模运算，DIV是整数除法，OR是位操作或（C语言中分别是%，&#x2F;，|）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;**非规范评注**</span><br><span class="line">&gt;</span><br><span class="line">&gt;剩余长度字段的解码算法如下：</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>multiplier = 1 value = 0 do encodedByte = ‘next byte from stream’ value += (encodedByte AND 127) <em>multiplier if (multiplier &gt; 128</em>128<em>128) throw Error(Malformed Remaining Length) multiplier</em> = 128 while ((encodedByte AND 128) != 0) ```</p><blockquote><p>AND是位操作与（C语言中的&amp;）</p><p>这个算法终止时，value包含的就是剩余长度的值。</p></blockquote><h2 id="2-3-可变报头-Variable-header">2.3 2.3 可变报头 Variable header</h2><p>某些MQTT控制报文包含一个可变报头部分。它在固定报头和负载之间。可变报头的内容根据报文类型的不同而不同。可变报头的报文标识符（Packet Identifier）字段存在于在多个类型的报文里。</p><h3 id="2-3-1-报文标识符-Packet-Identifier">2.3.1 2.3.1 报文标识符 Packet Identifier</h3><h5 id="图例-2-3-报文标识符字节-Packet-Identifier-bytes">2.3.1.0.1 图例 2.3 -报文标识符字节 Packet Identifier bytes</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong> - <strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td></tr></tbody></table><p>很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是PUBLISH（QoS &gt; 0时）， PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCRIBE，UNSUBACK。</p><p>SUBSCRIBE，UNSUBSCRIBE和PUBLISH（QoS大于0）控制报文<strong>必须</strong>包含一个非零的16位报文标识符（Packet Identifier）[MQTT-2.3.1-1]。客户端每次发送一个新的这些类型的报文时都<strong>必须</strong>分配一个当前未使用的报文标识符 [MQTT-2.3.1-2]。如果一个客户端要重发这个特殊的控制报文，在随后重发那个报文时，它<strong>必须</strong>使用相同的标识符。当客户端处理完这个报文对应的确认后，这个报文标识符就释放可重用。QoS 1的PUBLISH对应的是PUBACK，QoS 2的PUBLISH对应的是PUBCOMP，与SUBSCRIBE或UNSUBSCRIBE对应的分别是SUBACK或UNSUBACK [MQTT-2.3.1-3]。发送一个QoS 0的PUBLISH报文时，相同的条件也适用于服务端 [MQTT-2.3.1-4]。</p><p>QoS等于0的PUBLISH报文<strong>不能</strong>包含报文标识符 [MQTT-2.3.1-5]。</p><p>PUBACK, PUBREC, PUBREL报文<strong>必须</strong>包含与最初发送的PUBLISH报文相同的报文标识符 [MQTT-2.3.1-6]。类似地，SUBACK和UNSUBACK<strong>必须</strong>包含在对应的SUBSCRIBE和UNSUBSCRIBE报文中使用的报文标识符 [MQTT-2.3.1-7]。</p><p>需要报文标识符的控制报文在 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/02-ControlPacketFormat.html#_Table_2.5_-">表格 2.5 -包含报文标识符的控制报文</a> 中列出。</p><h5 id="表格-2-5-包含报文标识符的控制报文-Control-Packets-that-contain-a-Packet-Identifier">2.3.1.0.2 表格 2.5 -包含报文标识符的控制报文 Control Packets that contain a Packet Identifier</h5><table><thead><tr><th><strong>控制报文</strong></th><th><strong>报文标识符字段</strong></th></tr></thead><tbody><tr><td>CONNECT</td><td>不需要</td></tr><tr><td>CONNACK</td><td>不需要</td></tr><tr><td>PUBLISH</td><td>需要（如果QoS &gt; 0）</td></tr><tr><td>PUBACK</td><td>需要</td></tr><tr><td>PUBREC</td><td>需要</td></tr><tr><td>PUBREL</td><td>需要</td></tr><tr><td>PUBCOMP</td><td>需要</td></tr><tr><td>SUBSCRIBE</td><td>需要</td></tr><tr><td>SUBACK</td><td>需要</td></tr><tr><td>UNSUBSCRIBE</td><td>需要</td></tr><tr><td>UNSUBACK</td><td>需要</td></tr><tr><td>PINGREQ</td><td>不需要</td></tr><tr><td>PINGRESP</td><td>不需要</td></tr><tr><td>DISCONNECT</td><td>不需要</td></tr></tbody></table><p>客户端和服务端彼此独立地分配报文标识符。因此，客户端服务端组合使用相同的报文标识符可以实现并发的消息交换。</p><p><strong>非规范评注</strong></p><p>客户端发送标识符为0x1234的PUBLISH报文，它有可能会在收到那个报文的PUBACK之前，先收到服务端发送的另一个不同的但是报文标识符也为0x1234的PUBLISH报文。</p><table><thead><tr><th>Client</th><th>Server</th></tr></thead><tbody><tr><td>PUBLISH</td><td>Packet Identifier=0x1234—</td></tr><tr><td>–PUBLISH</td><td>Packet Identifier=0x1234</td></tr><tr><td>PUBACK</td><td>Packet Identifier=0x1234—</td></tr><tr><td>–PUBACK</td><td>Packet Identifier=0x1234</td></tr></tbody></table><h2 id="2-4-有效载荷-Payload">2.4 2.4 有效载荷 Payload</h2><p>某些MQTT控制报文在报文的最后部分包含一个有效载荷，这将在第三章论述。对于PUBLISH来说有效载荷就是应用消息。<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/02-ControlPacketFormat.html#_Table_2.6_-">表格 2.6 – 包含有效载荷的控制报文</a> 列出了需要有效载荷的控制报文。</p><h5 id="表格-2-6-–-包含有效载荷的控制报文-Control-Packets-that-contain-a-Payload">2.4.0.0.1 表格 2.6 – 包含有效载荷的控制报文 Control Packets that contain a Payload</h5><table><thead><tr><th><strong>控制报文</strong></th><th><strong>有效载荷</strong></th></tr></thead><tbody><tr><td>CONNECT</td><td>需要</td></tr><tr><td>CONNACK</td><td>不需要</td></tr><tr><td>PUBLISH</td><td>可选</td></tr><tr><td>PUBACK</td><td>不需要</td></tr><tr><td>PUBREC</td><td>不需要</td></tr><tr><td>PUBREL</td><td>不需要</td></tr><tr><td>PUBCOMP</td><td>不需要</td></tr><tr><td>SUBSCRIBE</td><td>需要</td></tr><tr><td>SUBACK</td><td>需要</td></tr><tr><td>UNSUBSCRIBE</td><td>需要</td></tr><tr><td>UNSUBACK</td><td>不需要</td></tr><tr><td>PINGREQ</td><td>不需要</td></tr><tr><td>PINGRESP</td><td>不需要</td></tr><tr><td>DISCONNECT</td><td>不需要</td></tr></tbody></table><h1 id="第三章-MQTT控制报文-MQTT-Control-Packets">3 第三章 MQTT控制报文 MQTT Control Packets</h1><h2 id="3-1-CONNECT-–-连接服务端">3.1 3.1 CONNECT – 连接服务端</h2><p>客户端到服务端的网络连接建立后，客户端发送给服务端的第一个报文<strong>必须</strong>是CONNECT报文 [MQTT-3.1.0-1]。</p><p>在一个网络连接上，客户端只能发送一次CONNECT报文。服务端<strong>必须</strong>将客户端发送的第二个CONNECT报文当作协议违规处理并断开客户端的连接 [MQTT-3.1.0-2]。有关错误处理的信息请查看4.8节。</p><p>有效载荷包含一个或多个编码的字段。包括客户端的唯一标识符，Will主题，Will消息，用户名和密码。除了客户端标识之外，其它的字段都是可选的，基于标志位来决定可变报头中是否需要包含这些字段。</p><h3 id="3-1-1-固定报头-Fixed-header">3.1.1 3.1.1 固定报头 Fixed header</h3><h5 id="图例-3-1-–CONNECT报文的固定报头">3.1.1.0.1 图例 3.1 –CONNECT报文的固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT报文类型 (1)</td><td>Reserved 保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2…</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>剩余长度字段</strong></p><p>剩余长度等于可变报头的长度（10字节）加上有效载荷的长度。编码方式见 2.2.3节的说明。</p><h3 id="3-1-2-可变报头-Variable-header">3.1.2 3.1.2 可变报头 Variable header</h3><p>CONNECT报文的可变报头按下列次序包含四个字段：协议名（Protocol Name），协议级别（Protocol Level），连接标志（Connect Flags）和保持连接（Keep Alive）。</p><h4 id="协议名-Protocol-Name">3.1.2.1 协议名 Protocol Name</h4><h5 id="图例-3-2-协议名字节构成">3.1.2.1.1 图例 3.2 -协议名字节构成</h5><table><thead><tr><th></th><th><strong>说明</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>协议名</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 1</td><td>长度 MSB (0)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>长度 LSB (4)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>byte 3</td><td>‘M’</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>byte 4</td><td>‘Q’</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>byte 5</td><td>‘T’</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>byte 6</td><td>‘T’</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><p>协议名是表示协议名 <em>MQTT</em> 的UTF-8编码的字符串。MQTT规范的后续版本不会改变这个字符串的偏移和长度。</p><p>如果协议名不正确服务端<strong>可以</strong>断开客户端的连接，也<strong>可以</strong>按照某些其它规范继续处理CONNECT报文。对于后一种情况，按照本规范，服务端<strong>不能</strong>继续处理CONNECT报文 [MQTT-3.1.2-1]。</p><blockquote><p><strong>非规范评注</strong></p><p>数据包检测工具，例如防火墙，可以使用协议名来识别MQTT流量。</p></blockquote><h4 id="协议级别-Protocol-Level">3.1.2.2 协议级别 Protocol Level</h4><h5 id="图例-3-3-Protocol-Level-byte协议级别字节构成">3.1.2.2.1 图例 3.3 - Protocol Level byte协议级别字节构成</h5><table><thead><tr><th></th><th><strong>说明</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>协议级别</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 7</td><td>Level(4)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><p>客户端用8位的无符号值表示协议的修订版本。对于3.1.1版协议，协议级别字段的值是4(0x04)。如果发现不支持的协议级别，服务端<strong>必须</strong>给发送一个返回码为0x01（不支持的协议级别）的CONNACK报文响应CONNECT报文，然后断开客户端的连接 [MQTT-3.1.2-2]。</p><h4 id="连接标志-Connect-Flags">3.1.2.3 连接标志 Connect Flags</h4><p>连接标志字节包含一些用于指定MQTT连接行为的参数。它还指出有效载荷中的字段是否存在。</p><h5 id="图例-3-4-连接标志位">3.1.2.3.1 图例 3.4 -连接标志位</h5><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0301-CONNECT.html"><img "" class="lazyload placeholder" data-original="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/images/figure0304.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="figure-3.4"></a></p><p>服务端<strong>必须</strong>验证CONNECT控制报文的保留标志位（第0位）是否为0，如果不为0必须断开客户端连接 [MQTT-3.1.2-3]。</p><h4 id="清理会话-Clean-Session">3.1.2.4 清理会话 Clean Session</h4><p><strong>位置：</strong>连接标志字节的第1位</p><p>这个二进制位指定了会话状态的处理方式。</p><p>客户端和服务端可以保存会话状态，以支持跨网络连接的可靠消息传输。这个标志位用于控制会话状态的生存时间。</p><p>如果清理会话（CleanSession）标志被设置为0，服务端<strong>必须</strong>基于当前会话（使用客户端标识符识别）的状态恢复与客户端的通信。如果没有与这个客户端标识符关联的会话，服务端<strong>必须</strong>创建一个新的会话。在连接断开之后，当连接断开后，客户端和服务端<strong>必须</strong>保存会话信息 [MQTT-3.1.2-4]。当清理会话标志为0的会话连接断开之后，服务端<strong>必须</strong>将之后的QoS 1和QoS 2级别的消息保存为会话状态的一部分，如果这些消息匹配断开连接时客户端的任何订阅 [<a href="https://tools.oasis-open.org/issues/browse/MQTT-3">MQTT-3</a>.1.2-5]。服务端也<strong>可以</strong>保存满足相同条件的QoS 0级别的消息。</p><p>如果清理会话（CleanSession）标志被设置为1，客户端和服务端<strong>必须</strong>丢弃之前的任何会话并开始一个新的会话。会话仅持续和网络连接同样长的时间。与这个会话关联的状态数据<strong>不能</strong>被任何之后的会话重用 [MQTT-3.1.2-6]。</p><p>客户端的会话状态包括：</p><ul><li>已经发送给服务端，但是还没有完成确认的QoS 1和QoS 2级别的消息</li><li>已从服务端接收，但是还没有完成确认的QoS 2级别的消息。</li></ul><p>服务端的会话状态包括：</p><ul><li>会话是否存在，即使会话状态的其它部分都是空。</li><li>客户端的订阅信息。</li><li>已经发送给客户端，但是还没有完成确认的QoS 1和QoS 2级别的消息。</li><li>即将传输给客户端的QoS 1和QoS 2级别的消息。</li><li>已从客户端接收，但是还没有完成确认的QoS 2级别的消息。</li><li>可选，准备发送给客户端的QoS 0级别的消息。</li></ul><p>保留消息不是服务端会话状态的一部分，会话终止时<strong>不能</strong>删除保留消息 [MQTT-3.1.2.7]。</p><p>有关状态存储的限制和细节见第 4.1节。</p><p>当清理会话标志被设置为1时，客户端和服务端的状态删除不需要是原子操作。</p><blockquote><p><strong>非规范评注</strong></p><p>为了确保在发生故障时状态的一致性，客户端应该使用会话状态标志1重复请求连接，直到连接成功。</p><p><strong>非规范评注</strong></p><p>一般来说，客户端连接时总是将清理会话标志设置为0或1，并且不交替使用两种值。这个选择取决于具体的应用。清理会话标志设置为1的客户端不会收到旧的应用消息，而且在每次连接成功后都需要重新订阅任何相关的主题。清理会话标志设置为0的客户端会收到所有在它连接断开期间发布的QoS 1和QoS 2级别的消息。因此，要确保不丢失连接断开期间的消息，需要使用QoS 1或 QoS 2级别，同时将清理会话标志设置为0。</p><p><strong>非规范评注</strong></p><p>清理会话标志0的客户端连接时，它请求服务端在连接断开后保留它的MQTT会话状态。如果打算在之后的某个时间点重连到这个服务端，客户端连接应该只使用清理会话标志0。当客户端决定之后不再使用这个会话时，应该将清理会话标志设置为1最后再连接一次，然后断开连接。</p></blockquote><h4 id="遗嘱标志-Will-Flag">3.1.2.5 遗嘱标志 Will Flag</h4><p><strong>位置：</strong>连接标志的第2位。</p><p>遗嘱标志（Will Flag）被设置为1，表示如果连接请求被接受了，遗嘱（Will Message）消息<strong>必须</strong>被存储在服务端并且与这个网络连接关联。之后网络连接关闭时，服务端<strong>必须</strong>发布这个遗嘱消息，除非服务端收到DISCONNECT报文时删除了这个遗嘱消息 [MQTT-3.1.2-8] 。</p><p>遗嘱消息发布的条件，包括但不限于：</p><ul><li>服务端检测到了一个I/O错误或者网络故障。</li><li>客户端在保持连接（Keep Alive）的时间内未能通讯。</li><li>客户端没有先发送DISCONNECT报文直接关闭了网络连接。</li><li>由于协议错误服务端关闭了网络连接。</li></ul><p>如果遗嘱标志被设置为1，连接标志中的Will QoS和Will Retain字段会被服务端用到，同时有效载荷中<strong>必须</strong>包含Will Topic和Will Message字段 [MQTT-3.1.2-9]。</p><p>一旦被发布或者服务端收到了客户端发送的DISCONNECT报文，遗嘱消息就<strong>必须</strong>从存储的会话状态中移除 [MQTT-3.1.2-10]。</p><p>如果遗嘱标志被设置为0，连接标志中的Will QoS和Will Retain字段<strong>必须</strong>设置为0，并且有效载荷中<strong>不能</strong>包含Will Topic和Will Message字段 [MQTT-3.1.2-11]。</p><p>如果遗嘱标志被设置为0，网络连接断开时，<strong>不能</strong>发送遗嘱消息 [MQTT-3.1.2-12]。</p><p>服务端应该迅速发布遗嘱消息。在关机或故障的情况下，服务端可以推迟遗嘱消息的发布直到之后的重启。如果发生了这种情况，在服务器故障和遗嘱消息被发布之间可能会有一个延迟。</p><h4 id="遗嘱QoS-Will-QoS">3.1.2.6 遗嘱QoS Will QoS</h4><p><strong>位置：</strong>连接标志的第4和第3位。</p><p>这两位用于指定发布遗嘱消息时使用的服务质量等级。</p><p>如果遗嘱标志被设置为0，遗嘱QoS也<strong>必须</strong>设置为0(0x00) [MQTT-3.1.2-13]。</p><p>如果遗嘱标志被设置为1，遗嘱QoS的值可以等于0(0x00)，1(0x01)，2(0x02)。它的值<strong>不能</strong>等于3 [MQTT-3.1.2-14]。</p><h4 id="遗嘱保留-Will-Retain">3.1.2.7 遗嘱保留 Will Retain</h4><p><strong>位置：</strong>连接标志的第5位。</p><p>如果遗嘱消息被发布时需要保留，需要指定这一位的值。</p><p>如果遗嘱标志被设置为0，遗嘱保留（Will Retain）标志也<strong>必须</strong>设置为0 [MQTT-3.1.2-15]。</p><p>如果遗嘱标志被设置为1：</p><ul><li>如果遗嘱保留被设置为0，服务端<strong>必须</strong>将遗嘱消息当作非保留消息发布 [MQTT-3.1.2-16]。</li><li>如果遗嘱保留被设置为1，服务端<strong>必须</strong>将遗嘱消息当作保留消息发布 [MQTT-3.1.2-17]。</li></ul><h4 id="用户名标志-User-Name-Flag">3.1.2.8 用户名标志 User Name Flag</h4><p><strong>位置：</strong>连接标志的第7位。</p><p>如果用户名（User Name）标志被设置为0，有效载荷中<strong>不能</strong>包含用户名字段 [MQTT-3.1.2-18]。</p><p>如果用户名（User Name）标志被设置为1，有效载荷中<strong>必须</strong>包含用户名字段 [MQTT-3.1.2-19]。</p><h4 id="密码标志-Password-Flag">3.1.2.9 密码标志 Password Flag</h4><p><strong>位置：</strong>连接标志的第6位。</p><p>如果密码（Password）标志被设置为0，有效载荷中<strong>不能</strong>包含密码字段 [MQTT-3.1.2-20]。</p><p>如果密码（Password）标志被设置为1，有效载荷中<strong>必须</strong>包含密码字段 [MQTT-3.1.2-21]。</p><p>如果用户名标志被设置为0，密码标志也<strong>必须</strong>设置为0 [MQTT-3.1.2-22]。</p><h4 id="保持连接-Keep-Alive">3.1.2.10 保持连接 Keep Alive</h4><h5 id="图例-3-5保持连接字节">3.1.2.10.1 图例 3.5保持连接字节</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 9</td><td>保持连接 Keep Alive MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 10</td><td>保持连接 Keep Alive LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>保持连接（Keep Alive）是一个以秒为单位的时间间隔，表示为一个16位的字，它是指在客户端传输完成一个控制报文的时刻到发送下一个报文的时刻，两者之间允许空闲的最大时间间隔。客户端负责保证控制报文发送的时间间隔不超过保持连接的值。如果没有任何其它的控制报文可以发送，客户端<strong>必须</strong>发送一个PINGREQ报文 [MQTT-3.1.2-23]。</p><p>不管保持连接的值是多少，客户端任何时候都可以发送PINGREQ报文，并且使用PINGRESP报文判断网络和服务端的活动状态。</p><p>如果保持连接的值非零，并且服务端在一点五倍的保持连接时间内没有收到客户端的控制报文，它<strong>必须</strong>断开客户端的网络连接，认为网络连接已断开 [MQTT-3.1.2-24]。</p><p>客户端发送了PINGREQ报文之后，如果在合理的时间内仍没有收到PINGRESP报文，它<strong>应该</strong>关闭到服务端的网络连接。</p><p>保持连接的值为零表示关闭保持连接功能。这意味着，服务端不需要因为客户端不活跃而断开连接。注意：不管保持连接的值是多少，任何时候，只要服务端认为客户端是不活跃或无响应的，可以断开客户端的连接。</p><blockquote><p><strong>非规范评注</strong></p><p>保持连接的实际值是由应用指定的，一般是几分钟。允许的最大值是18小时12分15秒。</p></blockquote><h4 id="可变报头非规范示例">3.1.2.11 可变报头非规范示例</h4><h5 id="图例-3-6-可变报头非规范示例">3.1.2.11.1 图例 3.6 -可变报头非规范示例</h5><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0301-CONNECT.html"><img "" class="lazyload placeholder" data-original="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/images/figure0306.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="figure-3.6"></a></p><h3 id="3-1-3-有效载荷-Payload">3.1.3 3.1.3 有效载荷 Payload</h3><p>CONNECT报文的有效载荷（payload）包含一个或多个以长度为前缀的字段，可变报头中的标志决定是否包含这些字段。如果包含的话，<strong>必须</strong>按这个顺序出现：客户端标识符，遗嘱主题，遗嘱消息，用户名，密码 [MQTT-3.1.3-1]。</p><h4 id="客户端标识符-Client-Identifier">3.1.3.1 客户端标识符 Client Identifier</h4><p>服务端使用客户端标识符 (ClientId) 识别客户端。连接服务端的每个客户端都有唯一的客户端标识符（ClientId）。客户端和服务端都必须使用ClientId识别两者之间的MQTT会话相关的状态 [MQTT-3.1.3-2]。</p><p>客户端标识符 (ClientId) <strong>必须</strong>存在而且<strong>必须</strong>是CONNECT报文有效载荷的第一个字段 [MQTT-3.1.3-3]。</p><p>客户端标识符<strong>必须</strong>是1.5.3节定义的UTF-8编码字符串 [MQTT-3.1.3-4]。</p><p>服务端<strong>必须</strong>允许1到23个字节长的UTF-8编码的客户端标识符，客户端标识符只能包含这些字符：“0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”（大写字母，小写字母和数字）[MQTT-3.1.3-5]。</p><p>服务端<strong>可以</strong>允许编码后超过23个字节的客户端标识符 (ClientId)。服务端<strong>可以</strong>允许包含不是上面列表字符的客户端标识符 (ClientId)。</p><p>服务端<strong>可以</strong>允许客户端提供一个零字节的客户端标识符 (ClientId) ，如果这样做了，服务端<strong>必须</strong>将这看作特殊情况并分配唯一的客户端标识符给那个客户端。然后它<strong>必须</strong>假设客户端提供了那个唯一的客户端标识符，正常处理这个CONNECT报文 [MQTT-3.1.3-6]。</p><p>如果客户端提供了一个零字节的客户端标识符，它<strong>必须</strong>同时将清理会话标志设置为1 [MQTT-3.1.3-7]。</p><p>如果客户端提供的ClientId为零字节且清理会话标志为0，服务端<strong>必须</strong>发送返回码为0x02（表示标识符不合格）的CONNACK报文响应客户端的CONNECT报文，然后关闭网络连接 [MQTT-3.1.3-8]。</p><p>如果服务端拒绝了这个ClientId，它<strong>必须</strong>发送返回码为0x02（表示标识符不合格）的CONNACK报文响应客户端的CONNECT报文，然后关闭网络连接 [MQTT-3.1.3-9]。</p><blockquote><p><strong>非规范评注</strong></p><p>客户端实现可以提供一个方便的方法用于生成随机的ClientId。当清理会话标志被设置为0时应该主动放弃使用这种方法。</p></blockquote><h4 id="遗嘱主题-Will-Topic">3.1.3.2 遗嘱主题 Will Topic</h4><p>如果遗嘱标志被设置为1，有效载荷的下一个字段是遗嘱主题（Will Topic）。遗嘱主题<strong>必须</strong>是 1.5.3节定义的UTF-8编码字符串 [MQTT-3.1.3-10]。</p><h4 id="遗嘱消息-Will-Message">3.1.3.3 遗嘱消息 Will Message</h4><p>如果遗嘱标志被设置为1，有效载荷的下一个字段是遗嘱消息。遗嘱消息定义了将被发布到遗嘱主题的应用消息，见3.1.2.5节的描述。这个字段由一个两字节的长度和遗嘱消息的有效载荷组成，表示为零字节或多个字节序列。长度给出了跟在后面的数据的字节数，不包含长度字段本身占用的两个字节。</p><p>遗嘱消息被发布到遗嘱主题时，它的有效载荷只包含这个字段的数据部分，不包含开头的两个长度字节。</p><h4 id="用户名-User-Name">3.1.3.4 用户名 User Name</h4><p>如果用户名（User Name）标志被设置为1，有效载荷的下一个字段就是它。用户名<strong>必须</strong>是 1.5.3节定义的UTF-8编码字符串 [MQTT-3.1.3-11]。服务端可以将它用于身份验证和授权。</p><h4 id="密码-Password">3.1.3.5 密码 Password</h4><p>如果密码（Password）标志被设置为1，有效载荷的下一个字段就是它。密码字段包含一个两字节的长度字段，长度表示二进制数据的字节数（不包含长度字段本身占用的两个字节），后面跟着0到65535字节的二进制数据。</p><h5 id="图例-3-7-密码字节">3.1.3.5.1 图例 3.7 - 密码字节</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong> - <strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>数据长度 MSB</td></tr><tr><td>byte 2</td><td>数据长度 LSB</td></tr><tr><td>byte 3 ….</td><td>如果长度大于0，这里就是数据部分</td></tr></tbody></table><h3 id="3-1-4-响应-Response">3.1.4 3.1.4 响应 Response</h3><p>注意：服务器可以在同一个TCP端口或其他网络端点上支持多种协议（包括本协议的早期版本）。如果服务器确定协议是MQTT 3.1.1，那么它按照下面的方法验证连接请求。</p><ol><li>网络连接建立后，如果服务端在合理的时间内没有收到CONNECT报文，服务端<strong>应该</strong>关闭这个连接。</li><li>服务端<strong>必须</strong>按照3.1节的要求验证CONNECT报文，如果报文不符合规范，服务端不发送CONNACK报文直接关闭网络连接 [MQTT-3.1.4-1]。</li><li>服务端<strong>可以</strong>检查CONNECT报文的内容是不是满足任何进一步的限制，<strong>可以</strong>执行身份验证和授权检查。如果任何一项检查没通过，按照3.2节的描述，它<strong>应该</strong>发送一个适当的、返回码非零的CONNACK响应，并且<strong>必须</strong>关闭这个网络连接。</li></ol><p>如果验证成功，服务端会执行下列步骤。</p><ol><li>如果ClientId表明客户端已经连接到这个服务端，那么服务端<strong>必须</strong>断开原有的客户端连接 [MQTT-3.1.4-2]。</li><li>服务端<strong>必须</strong>按照 3.1.2.4节的描述执行清理会话的过程 [MQTT-3.1.4-3]。</li><li>服务端<strong>必须</strong>发送返回码为零的CONNACK报文作为CONNECT报文的确认响应 [MQTT-3.1.4-4]。</li><li>开始消息分发和保持连接状态监视。</li></ol><p>允许客户端在发送CONNECT报文之后立即发送其它的控制报文；客户端不需要等待服务端的CONNACK报文。如果服务端拒绝了CONNECT，它<strong>不能</strong>处理客户端在CONNECT报文之后发送的任何数据 [MQTT-3.1.4-5]。</p><blockquote><p><strong>非规范评注</strong></p><p>客户端通常会等待一个CONNACK报文。然而客户端有权在收到CONNACK之前发送控制报文，由于不需要维持连接状态，这可以简化客户端的实现。</p></blockquote><h2 id="3-2-CONNACK-–-确认连接请求">3.2 3.2 CONNACK – 确认连接请求</h2><p>服务端发送CONNACK报文响应从客户端收到的CONNECT报文。服务端发送给客户端的第一个报文<strong>必须</strong>是CONNACK [MQTT-3.2.0-1]。</p><p>如果客户端在合理的时间内没有收到服务端的CONNACK报文，客户端<strong>应该</strong>关闭网络连接。<em>合理</em> 的时间取决于应用的类型和通信基础设施。</p><h3 id="3-2-1-固定报头">3.2.1 3.2.1 固定报头</h3><p>固定报头的格式见 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0302-CONNACK.html#_Figure_3.8_%E2%80%93">图例 3.8 – CONNACK 报文固定报头</a> 的描述。</p><h5 id="图例-3-8-–-CONNACK-报文固定报头">3.2.1.0.1 图例 3.8 – CONNACK 报文固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT报文类型 (2)</td><td>Reserved 保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2…</td><td>剩余长度 (2)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p><strong>剩余长度字段</strong></p><p>表示可变报头的长度。对于CONNACK报文这个值等于2。</p><h3 id="3-2-2-可变报头">3.2.2 3.2.2 可变报头</h3><p>可变报头的格式见 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0302-CONNACK.html#_%E5%9B%BE%E4%BE%8B_3.9_%E2%80%93CONNACK%E6%8A%A5%E6%96%87%E5%8F%AF%E5%8F%98%E6%8A%A5%E5%A4%B4">图例 3.9 –CONNACK报文可变报头</a> 的描述。</p><h5 id="图例-3-9-–CONNACK报文可变报头">3.2.2.0.1 图例 3.9 –CONNACK报文可变报头</h5><table><thead><tr><th></th><th><strong>描述</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>连接确认标志</td><td>Reserved 保留位</td><td>SP1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 1</td><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>X</td></tr><tr><td>连接返回码</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td></td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr></tbody></table><table><thead><tr><th></th><th><strong>描述</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>连接确认标志</td><td>Reserved 保留位</td><td>SP1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 1</td><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>X</td></tr><tr><td>连接返回码</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td></td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr></tbody></table><h4 id="连接确认标志-Connect-Acknowledge-Flags">3.2.2.1 连接确认标志 Connect Acknowledge Flags</h4><p>第1个字节是 <em>连接确认标志</em>，位7-1是保留位且<strong>必须</strong>设置为0。 第0 (SP)位 是当前会话（Session Present）标志。</p><h4 id="当前会话-Session-Present">3.2.2.2 当前会话 Session Present</h4><p><strong>位置：</strong>连接确认标志的第0位。</p><p>如果服务端收到清理会话（CleanSession）标志为1的连接，除了将CONNACK报文中的返回码设置为0之外，还<strong>必须</strong>将CONNACK报文中的当前会话设置（Session Present）标志为0 [MQTT-3.2.2-1]。</p><p>如果服务端收到一个CleanSession为0的连接，当前会话标志的值取决于服务端是否已经保存了ClientId对应客户端的会话状态。如果服务端已经保存了会话状态，它<strong>必须</strong>将CONNACK报文中的当前会话标志设置为1 [MQTT-3.2.2-2]。如果服务端没有已保存的会话状态，它<strong>必须</strong>将CONNACK报文中的当前会话设置为0。还需要将CONNACK报文中的返回码设置为0 [MQTT-3.2.2-3]。</p><p>当前会话标志使服务端和客户端在是否有已存储的会话状态上保持一致。</p><p>一旦完成了会话的初始化设置，已经保存会话状态的客户端将期望服务端维持它存储的会话状态。如果客户端从服务端收到的当前的值与预期的不同，客户端可以选择继续这个会话或者断开连接。客户端可以丢弃客户端和服务端之间的会话状态，方法是，断开连接，将清理会话标志设置为1，再次连接，然后再次断开连接。</p><p>如果服务端发送了一个包含非零返回码的CONNACK报文，它<strong>必须</strong>将当前会话标志设置为0 [MQTT-3.2.2-4]。</p><h4 id="连接返回码-Connect-Return-code">3.2.2.3 连接返回码 Connect Return code</h4><p><strong>位置：</strong>可变报头的第2个字节。</p><p>连接返回码字段使用一个字节的无符号值，在 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0302-CONNACK.html#_%E8%A1%A8%E6%A0%BC_3.1_%E2%80%93%E8%BF%9E%E6%8E%A5%E8%BF%94%E5%9B%9E%E7%A0%81%E7%9A%84%E5%80%BC">表格 3.1 –连接返回码的值</a> 中列出。如果服务端收到一个合法的CONNECT报文，但出于某些原因无法处理它，服务端应该尝试发送一个包含非零返回码（表格中的某一个）的CONNACK报文。如果服务端发送了一个包含非零返回码的CONNACK报文，那么它<strong>必须</strong>关闭网络连接 [MQTT-3.2.2-5].。</p><h5 id="表格-3-1-–连接返回码的值">3.2.2.3.1 表格 3.1 –连接返回码的值</h5><table><thead><tr><th><strong>值</strong></th><th><strong>返回码响应</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>0</td><td>0x00连接已接受</td><td>连接已被服务端接受</td></tr><tr><td>1</td><td>0x01连接已拒绝，不支持的协议版本</td><td>服务端不支持客户端请求的MQTT协议级别</td></tr><tr><td>2</td><td>0x02连接已拒绝，不合格的客户端标识符</td><td>客户端标识符是正确的UTF-8编码，但服务端不允许使用</td></tr><tr><td>3</td><td>0x03连接已拒绝，服务端不可用</td><td>网络连接已建立，但MQTT服务不可用</td></tr><tr><td>4</td><td>0x04连接已拒绝，无效的用户名或密码</td><td>用户名或密码的数据格式无效</td></tr><tr><td>5</td><td>0x05连接已拒绝，未授权</td><td>客户端未被授权连接到此服务器</td></tr><tr><td>6-255</td><td></td><td>保留</td></tr></tbody></table><p>如果认为上表中的所有连接返回码都不太合适，那么服务端<strong>必须</strong>关闭网络连接，不需要发送CONNACK报文 [MQTT-3.2.2-6]。</p><h3 id="3-2-3-有效载荷">3.2.3 3.2.3 有效载荷</h3><p>CONNACK报文没有有效载荷。</p><h2 id="3-3-PUBLISH-–-发布消息">3.3 3.3 PUBLISH – 发布消息</h2><p>PUBLISH控制报文是指从客户端向服务端或者服务端向客户端传输一个应用消息。</p><h3 id="3-3-1-固定报头">3.3.1 3.3.1 固定报头</h3><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_%E5%9B%BE%E4%BE%8B_3.10_%E2%80%93">图例 3.10 – PUBLISH报文固定报头</a>描述了固定报头的格式</p><h5 id="图例-3-10-–-PUBLISH报文固定报头">3.3.1.0.1 图例 3.10 – PUBLISH报文固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (3)</td><td>DUP</td><td>QoS-H</td><td>QoS-</td><td>RETAIN</td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>1</td><td>1</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>byte 2…</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="重发标志-DUP">3.3.1.1 重发标志 DUP</h4><p><strong>位置：</strong>第1个字节，第3位</p><p>如果DUP标志被设置为0，表示这是客户端或服务端第一次请求发送这个PUBLISH报文。如果DUP标志被设置为1，表示这可能是一个早前报文请求的重发。</p><p>客户端或服务端请求重发一个PUBLISH报文时，<strong>必须</strong>将DUP标志设置为1 [MQTT-3.3.1.-1].。对于QoS 0的消息，DUP标志<strong>必须</strong>设置为0 [MQTT-3.3.1-2]。</p><p>服务端发送PUBLISH报文给订阅者时，收到（入站）的PUBLISH报文的DUP标志的值不会被传播。发送（出站）的PUBLISH报文与收到（入站）的PUBLISH报文中的DUP标志是独立设置的，它的值<strong>必须</strong>单独的根据发送（出站）的PUBLISH报文是否是一个重发来确定 [MQTT-3.3.1-3]。</p><blockquote><p><strong>非规范评注</strong></p><p>接收者收到一个DUP标志为1的控制报文时，不能假设它看到了一个这个报文之前的一个副本。</p><p><strong>非规范评注</strong></p><p>需要特别指出的是，DUP标志关注的是控制报文本身，与它包含的应用消息无关。当使用QoS 1时，客户端可能会收到一个DUP标志为0的PUBLISH报文，这个报文包含一个它之前收到过的应用消息的副本，但是用的是不同的报文标识符。 2.3.1节提供了有关报文标识符的更多信息。</p></blockquote><h4 id="服务质量等级-QoS">3.3.1.2 服务质量等级 QoS</h4><p><strong>位置：</strong>第1个字节，第2-1位。</p><p>这个字段表示应用消息分发的服务质量等级保证。服务质量等级在 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_%E8%A1%A8%E6%A0%BC_3.2_-%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F%E5%AE%9A%E4%B9%89">表格 3.2 -服务质量定义</a> 中列出。</p><h5 id="表格-3-2-服务质量定义">3.3.1.2.1 表格 3.2 -服务质量定义</h5><table><thead><tr><th><strong>QoS值</strong></th><th><strong>Bit 2</strong></th><th><strong>Bit 1</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>最多分发一次</td></tr><tr><td>1</td><td>0</td><td>1</td><td>至少分发一次</td></tr><tr><td>2</td><td>1</td><td>0</td><td>只分发一次</td></tr><tr><td>-</td><td>1</td><td>1</td><td>保留位</td></tr></tbody></table><p>PUBLISH报文<strong>不能</strong>将QoS所有的位设置为1。如果服务端或客户端收到QoS所有位都为1的PUBLISH报文，它<strong>必须</strong>关闭网络连接 [MQTT-3.3.1-4]。</p><h4 id="保留标志-RETAIN">3.3.1.3 保留标志 RETAIN</h4><p><strong>位置：</strong>第1个字节，第0位。</p><p>如果客户端发给服务端的PUBLISH报文的保留（RETAIN）标志被设置为1，服务端<strong>必须</strong>存储这个应用消息和它的服务质量等级（QoS），以便它可以被分发给未来的主题名匹配的订阅者 [MQTT-3.3.1-5]。一个新的订阅建立时，对每个匹配的主题名，如果存在最近保留的消息，它<strong>必须</strong>被发送给这个订阅者 [MQTT-3.3.1-6]。如果服务端收到一条保留（RETAIN）标志为1的QoS 0消息，它<strong>必须</strong>丢弃之前为那个主题保留的任何消息。它<strong>应该</strong>将这个新的QoS 0消息当作那个主题的新保留消息，但是任何时候都<strong>可以</strong>选择丢弃它 — 如果这种情况发生了，那个主题将没有保留消息 [MQTT-3.3.1-7]。有关存储状态的更多信息见 4.1节。</p><p>服务端发送PUBLISH报文给客户端时，如果消息是作为客户端一个新订阅的结果发送，它<strong>必须</strong>将报文的保留标志设为1 [MQTT-3.3.1-8]。当一个PUBLISH报文发送给客户端是因为匹配一个已建立的订阅时，服务端<strong>必须</strong>将保留标志设为0，不管它收到的这个消息中保留标志的值是多少 [MQTT-3.3.1-9]。</p><p>保留标志为1且有效载荷为零字节的PUBLISH报文会被服务端当作正常消息处理，它会被发送给订阅主题匹配的客户端。此外，同一个主题下任何现存的保留消息必须被移除，因此这个主题之后的任何订阅者都不会收到一个保留消息 [MQTT-3.3.1-10]。<em>当作正常</em> 意思是现存的客户端收到的消息中保留标志未被设置。服务端<strong>不能</strong>存储零字节的保留消息 [MQTT-3.3.1-11]。</p><p>如果客户端发给服务端的PUBLISH报文的保留标志位0，服务端<strong>不能</strong>存储这个消息也<strong>不能</strong>移除或替换任何现存的保留消息 [MQTT-3.3.1-12]。</p><blockquote><p><strong>非规范评注</strong></p><p>对于发布者不定期发送状态消息这个场景，保留消息很有用。新的订阅者将会收到最近的状态。</p></blockquote><p><strong>剩余长度字段</strong></p><p>等于可变报头的长度加上有效载荷的长度。</p><h3 id="3-3-2-可变报头">3.3.2 3.3.2 可变报头</h3><p>可变报头按顺序包含主题名和报文标识符。</p><h4 id="主题名-Topic-Name">3.3.2.1 主题名 Topic Name</h4><p>主题名（Topic Name）用于识别有效载荷数据应该被发布到哪一个信息通道。</p><p>主题名<strong>必须</strong>是PUBLISH报文可变报头的第一个字段。它<strong>必须</strong>是 1.5.3节定义的UTF-8编码的字符串 [MQTT-3.3.2-1]。</p><p>PUBLISH报文中的主题名<strong>不能</strong>包含通配符 [MQTT-3.3.2-2]。</p><p>服务端发送给订阅客户端的PUBLISH报文的主题名<strong>必须</strong>匹配该订阅的主题过滤器（根据 4.7节定义的匹配过程）[MQTT-3.3.2-3]。</p><h4 id="报文标识符-Packet-Identifier">3.3.2.2 报文标识符 Packet Identifier</h4><p>只有当QoS等级是1或2时，报文标识符（Packet Identifier）字段才能出现在PUBLISH报文中。2.3.1节提供了有关报文标识符的更多信息。</p><h4 id="可变报头非规范示例-1">3.3.2.3 可变报头非规范示例</h4><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_Figure_3.11_-">图例 3.11 – PUBLISH报文可变报头非规范示例</a> 举例说明了 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0303-PUBLISH.html#_%E8%A1%A8%E6%A0%BC_3.3_-">表格 3.3 - PUBLISH报文非规范示例</a> 中简要描述的PUBLISH报文的可变报头。</p><h5 id="表格-3-3-PUBLISH报文非规范示例">3.3.2.3.1 表格 3.3 - PUBLISH报文非规范示例</h5><table><thead><tr><th><strong>Field</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td>主题名</td><td>a/b</td></tr><tr><td>报文标识符</td><td>10</td></tr></tbody></table><h5 id="图例-3-11-–-PUBLISH报文可变报头非规范示例">3.3.2.3.2 图例 3.11 – PUBLISH报文可变报头非规范示例</h5><table><thead><tr><th></th><th><strong>描述</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>Topic Name 主题名</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 1</td><td>Length MSB (0)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>Length LSB (3)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>byte 3</td><td>‘a’ (0x61)</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>byte 4</td><td>‘/’ (0x2F)</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>byte 5</td><td>‘b’ (0x62)</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>报文标识符</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 6</td><td>报文标识符 MSB (0)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 7</td><td>报文标识符 LSB (10)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p>示例中的主题名为 “a/b”，长度等于3，报文标识符为 “10”</p><h3 id="3-3-3-有效载荷">3.3.3 3.3.3 有效载荷</h3><p>有效载荷包含将被发布的应用消息。数据的内容和格式是应用特定的。有效载荷的长度这样计算：用固定报头中的剩余长度字段的值减去可变报头的长度。包含零长度有效载荷的PUBLISH报文是合法的。</p><h3 id="3-3-4-响应">3.3.4 3.3.4 响应</h3><p>PUBLISH报文的接收者<strong>必须</strong>按照根据PUBLISH报文中的QoS等级发送响应，见下面表格的描述 [MQTT-3.3.4-1]。</p><h5 id="表格-3-4-–-PUBLISH报文的预期响应">3.3.4.0.1 表格 3.4 – PUBLISH报文的预期响应</h5><table><thead><tr><th><strong>服务质量等级</strong></th><th><strong>预期响应</strong></th></tr></thead><tbody><tr><td>QoS 0</td><td>无响应</td></tr><tr><td>QoS 1</td><td>PUBACK报文</td></tr><tr><td>QoS 2</td><td>PUBREC报文</td></tr></tbody></table><h3 id="3-3-5-动作-Actions">3.3.5 3.3.5 动作 Actions</h3><p>客户端使用PUBLISH报文发送应用消息给服务端，目的是分发到其它订阅匹配的客户端。</p><p>服务端使用PUBLISH报文发送应用消息给每一个订阅匹配的客户端。</p><p>客户端使用带通配符的主题过滤器请求订阅时，客户端的订阅可能会重复，因此发布的消息可能会匹配多个过滤器。对于这种情况，服务端<strong>必须</strong>将消息分发给所有订阅匹配的QoS等级最高的客户端 [MQTT-3.3.5-1]。服务端之后可以按照订阅的QoS等级，分发消息的副本给每一个匹配的订阅者。</p><p>收到一个PUBLISH报文时，接收者的动作取决于4.3节描述的QoS等级。</p><p>如果服务端实现不授权某个客户端发布PUBLISH报文，它没有办法通知那个客户端。它<strong>必须</strong>按照正常的QoS规则发送一个正面的确认，或者关闭网络连接 [MQTT-3.3.5-2]。</p><h2 id="3-4-PUBACK-–发布确认">3.4 3.4 PUBACK –发布确认</h2><p>PUBACK报文是对QoS 1等级的PUBLISH报文的响应。</p><h3 id="3-4-1-固定报头">3.4.1 3.4.1 固定报头</h3><h5 id="图例-3-12-PUBACK报文固定报头">3.4.1.0.1 图例 3.12 - PUBACK报文固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT报文类型 (4)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2…</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p><strong>剩余长度字段</strong></p><p>表示可变报头的长度。对PUBACK报文这个值等于2.</p><h3 id="3-4-2-可变报头">3.4.2 3.4.2 可变报头</h3><p>包含等待确认的PUBLISH报文的报文标识符。</p><h5 id="图例-3-13-–-PUBACK报文可变报头">3.4.2.0.1 图例 3.13 – PUBACK报文可变报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="3-4-3-有效载荷">3.4.3 3.4.3 有效载荷</h3><p>PUBACK报文没有有效载荷。</p><h3 id="3-4-4-动作">3.4.4 3.4.4 动作</h3><p>完整的描述见 4.3.2节。</p><h2 id="3-5-PUBREC-–-发布收到（QoS-2，第一步）">3.5 3.5 PUBREC – 发布收到（QoS 2，第一步）</h2><p>PUBREC报文是对QoS等级2的PUBLISH报文的响应。它是QoS 2等级协议交换的第二个报文。</p><h3 id="3-5-1-固定报头">3.5.1 3.5.1 固定报头</h3><h5 id="图例-3-14-–-PUBREC报文固定报头">3.5.1.0.1 图例 3.14 – PUBREC报文固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (5)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (2)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p><strong>剩余长度字段</strong></p><p>表示可变报头的长度。对PUBREC报文它的值等于2。</p><h3 id="3-5-2-可变报头">3.5.2 3.5.2 可变报头</h3><p>可变报头包含等待确认的PUBLISH报文的报文标识符。</p><h5 id="图例-3-15-–-PUBREC报文可变报头">3.5.2.0.1 图例 3.15 – PUBREC报文可变报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="3-5-3-有效载荷">3.5.3 3.5.3 有效载荷</h3><p>PUBREC报文没有有效载荷。</p><h3 id="3-5-4-动作">3.5.4 3.5.4 动作</h3><p>完整的描述见 4.3.3节。</p><h2 id="3-6-PUBREL-–-发布释放（QoS-2，第二步）">3.6 3.6 PUBREL – 发布释放（QoS 2，第二步）</h2><p>PUBREL报文是对PUBREC报文的响应。它是QoS 2等级协议交换的第三个报文。</p><h3 id="3-6-1-固定报头">3.6.1 3.6.1 固定报头</h3><h5 id="图例-3-16-–-PUBREL报文固定报头">3.6.1.0.1 图例 3.16 – PUBREL报文固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (6)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (2)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p>PUBREL控制报文固定报头的第3,2,1,0位是保留位，<strong>必须</strong>被设置为0,0,1,0。服务端<strong>必须</strong>将其它的任何值都当做是不合法的并关闭网络连接 [MQTT-3.6.1-1]。</p><p><strong>剩余长度字段</strong></p><p>表示可变报头的长度。对PUBREL报文这个值等于2.</p><h3 id="3-6-2-可变报头">3.6.2 3.6.2 可变报头</h3><p>可变报头包含与等待确认的PUBREC报文相同的报文标识符。</p><h5 id="图例-3-17-–-PUBREL报文可变报头">3.6.2.0.1 图例 3.17 – PUBREL报文可变报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="3-6-3-有效载荷">3.6.3 3.6.3 有效载荷</h3><p>PUBREL报文没有有效载荷。</p><h3 id="3-6-4-动作">3.6.4 3.6.4 动作</h3><p>完整的描述见 4.3.3节。</p><h2 id="3-7-PUBCOMP-–-发布完成（QoS-2，第三步）">3.7 3.7 PUBCOMP – 发布完成（QoS 2，第三步）</h2><p>PUBCOMP报文是对PUBREL报文的响应。它是QoS 2等级协议交换的第四个也是最后一个报文。</p><h3 id="3-7-1-固定报头">3.7.1 3.7.1 固定报头</h3><h5 id="图例-3-18-–-PUBCOMP报文固定报头">3.7.1.0.1 图例 3.18 – PUBCOMP报文固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (7)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (2)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p><strong>剩余长度字段</strong></p><p>表示可变报头的长度。对PUBCOMP报文这个值等于2。</p><h3 id="3-7-2-可变报头">3.7.2 3.7.2 可变报头</h3><p>可变报头包含与等待确认的PUBREL报文相同的报文标识符。</p><h5 id="图例-3-19-–-PUBCOMP报文可变报头">3.7.2.0.1 图例 3.19 – PUBCOMP报文可变报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="3-7-3-有效载荷">3.7.3 3.7.3 有效载荷</h3><p>PUBCOMP报文没有有效载荷。</p><h3 id="3-7-4-动作">3.7.4 3.7.4 动作</h3><p>完整的描述见4.3.3节。</p><h2 id="3-8-SUBSCRIBE-订阅主题">3.8 3.8 SUBSCRIBE - 订阅主题</h2><p>客户端向服务端发送SUBSCRIBE报文用于创建一个或多个订阅。每个订阅注册客户端关心的一个或多个主题。为了将应用消息转发给与那些订阅匹配的主题，服务端发送PUBLISH报文给客户端。SUBSCRIBE报文也（为每个订阅）指定了最大的QoS等级，服务端根据这个发送应用消息给客户端。</p><h3 id="3-8-1-固定报头">3.8.1 3.8.1 固定报头</h3><h5 id="图例-3-20-–-SUBSCRIBE报文固定报头">3.8.1.0.1 图例 3.20 – SUBSCRIBE报文固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (8)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (8)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>SUBSCRIBE控制报固定报头的第3,2,1,0位是保留位，<strong>必须</strong>分别设置为0,0,1,0。服务端<strong>必须</strong>将其它的任何值都当做是不合法的并关闭网络连接 [MQTT-3.8.1-1]。</p><p><strong>剩余长度字段</strong></p><p>等于可变报头的长度（2字节）加上有效载荷的长度。</p><h3 id="3-8-2可变报头">3.8.2 3.8.2可变报头</h3><p>可变报头包含报文标识符。2.3.1提供了有关报文标识符的更多信息。</p><h4 id="可变报头非规范示例-2">3.8.2.1 可变报头非规范示例</h4><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0308-SUBSCRIBE.html#_%E5%9B%BE%E4%BE%8B_3.21_%E2%80%93">图例 3.21 – 报文标识符等于10的可变报头，非规范示例</a> 展示了报文标识符设置为10时的可变报头。</p><h5 id="图例-3-21-–-报文标识符等于10的可变报头，非规范示例">3.8.2.1.1 图例 3.21 – 报文标识符等于10的可变报头，非规范示例</h5><table><thead><tr><th></th><th><strong>描述</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>报文标识符</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 1</td><td>报文标识符 MSB (0)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>报文标识符 LSB (10)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><h3 id="3-8-3-有效载荷">3.8.3 3.8.3 有效载荷</h3><p>SUBSCRIBE报文的有效载荷包含了一个主题过滤器列表，它们表示客户端想要订阅的主题。SUBSCRIBE报文有效载荷中的主题过滤器列表<strong>必须</strong>是1.5.3节定义的UTF-8字符串 [MQTT-3.8.3-1]。服务端<strong>应该</strong>支持包含通配符（4.7.1节定义的）的主题过滤器。如果服务端选择不支持包含通配符的主题过滤器，<strong>必须</strong>拒绝任何包含通配符过滤器的订阅请求 [MQTT-3.8.3-2]。每一个过滤器后面跟着一个字节，这个字节被叫做 服务质量要求（Requested QoS）。它给出了服务端向客户端发送应用消息所允许的最大QoS等级。</p><p>SUBSCRIBE报文的有效载荷<strong>必须</strong>包含至少一对主题过滤器 和 QoS等级字段组合。没有有效载荷的SUBSCRIBE报文是违反协议的 [MQTT-3.8.3-3]。有关错误处理的信息请查看4.8节。</p><p>请求的最大服务质量等级字段编码为一个字节，它后面跟着UTF-8编码的主题名，那些主题过滤器 /和QoS等级组合是连续地打包。</p><h5 id="图例-3-22-–-SUBSCRIBE报文有效载荷格式">3.8.3.0.1 图例 3.22 – SUBSCRIBE报文有效载荷格式</h5><table><thead><tr><th><strong>描述</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>主题过滤器</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 1</td><td>长度 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>长度 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>bytes 3..N</td><td>主题过滤器（Topic Filter）</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>服务质量要求（Requested QoS）</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>保留位</td><td>服务质量等级</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte N+1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>X</td><td>X</td></tr></tbody></table><table><thead><tr><th><strong>描述</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>主题过滤器</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 1</td><td>长度 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>长度 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 3..N</td><td>主题过滤器（Topic Filter）</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>服务质量要求（Requested QoS）</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>保留位</td><td>服务质量等级</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte N+1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>X</td><td>X</td></tr></tbody></table><p>当前版本的协议没有用到服务质量要求（Requested QoS）字节的高六位。如果有效载荷中的任何位是非零值，或者QoS不等于0,1或2，服务端<strong>必须</strong>认为SUBSCRIBE报文是不合法的并关闭网络连接 [MQTT-3-8.3-4]。</p><h4 id="有效载荷非规范示例">3.8.3.1 有效载荷非规范示例</h4><blockquote><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0308-SUBSCRIBE.html#_Figure_3.23_-">图例 3.23 – 有效载荷字节格式非规范示例</a> 展示了 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0308-SUBSCRIBE.html#_Table_3.4_-">表格 3.5 – 有效载荷非规范示例</a> 中简略描述的SUBSCRIBE报文的有效载荷。</p></blockquote><h5 id="表格-3-5-–-有效载荷非规范示例">3.8.3.1.1 表格 3.5 – 有效载荷非规范示例</h5><table><thead><tr><th>主题名</th><th>“a/b”</th></tr></thead><tbody><tr><td>服务质量要求</td><td>0x01</td></tr><tr><td>主题名</td><td>“c/d”</td></tr><tr><td>服务质量要求</td><td>0x02</td></tr></tbody></table><h5 id="图例-3-23-–-有效载荷字节格式非规范示例">3.8.3.1.2 图例 3.23 – 有效载荷字节格式非规范示例</h5><table><thead><tr><th></th><th><strong>描述</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>主题过滤器（Topic Filter）</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 1</td><td>Length MSB (0)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>Length LSB (3)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>byte 3</td><td>‘a’ (0x61)</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>byte 4</td><td>‘/’ (0x2F)</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>byte 5</td><td>‘b’ (0x62)</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>服务质量要求（Requested QoS）</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 6</td><td>Requested QoS(1)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>主题过滤器（Topic Filter）</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 7</td><td>Length MSB (0)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 8</td><td>Length LSB (3)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>byte 9</td><td>‘c’ (0x63)</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>byte 10</td><td>‘/’ (0x2F)</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>byte 11</td><td>‘d’ (0x64)</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>服务质量要求（Requested QoS）</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 12</td><td>Requested QoS(2)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><h3 id="3-8-4-响应">3.8.4 3.8.4 响应</h3><p>服务端收到客户端发送的一个SUBSCRIBE报文时，<strong>必须</strong>使用SUBACK报文响应 [MQTT-3.8.4-1]。SUBACK报文<strong>必须</strong>和等待确认的SUBSCRIBE报文有相同的报文标识符 [MQTT-3.8.4-2]。</p><p>允许服务端在发送SUBACK报文之前就开始发送与订阅匹配的PUBLISH报文。</p><p>如果服务端收到一个SUBSCRIBE报文，报文的主题过滤器与一个现存订阅的主题过滤器相同，那么<strong>必须</strong>使用新的订阅彻底替换现存的订阅。新订阅的主题过滤器和之前订阅的相同，但是它的最大QoS值可以不同。与这个主题过滤器匹配的任何现存的保留消息<strong>必须</strong>被重发，但是发布流程<strong>不能</strong>中断 [<a href="https://tools.oasis-open.org/issues/browse/MQTT-3">MQTT-3</a>.8.4-3]。</p><p>如果主题过滤器不同于任何现存订阅的过滤器，服务端会创建一个新的订阅并发送所有匹配的保留消息。</p><p>如果服务端收到包含多个主题过滤器的SUBSCRIBE报文，它<strong>必须</strong>如同收到了一系列的多个SUBSCRIBE报文一样处理那个，除了需要将它们的响应合并到一个单独的SUBACK报文发送 [MQTT-3.8.4-4]。</p><p>服务端发送给客户端的SUBACK报文对每一对主题过滤器 和QoS等级都<strong>必须</strong>包含一个返回码。这个返回码<strong>必须</strong>表示那个订阅被授予的最大QoS等级，或者表示这个订阅失败 [<a href="https://tools.oasis-open.org/issues/browse/MQTT-3">MQTT-3</a>.8.4-5]。服务端可以授予比订阅者要求的低一些的QoS等级。为响应订阅而发出的消息的有效载荷的QoS<strong>必须</strong>是原始发布消息的QoS和服务端授予的QoS两者中的最小值。如果原始消息的QoS是1而被授予的最大QoS是0，允许服务端重复发送一个消息的副本给订阅者 [<a href="https://tools.oasis-open.org/issues/browse/MQTT-3">MQTT-3</a>.8.4-6]。</p><blockquote><p><strong>非规范示例</strong> 对某个特定的主题过滤器，如果正在订阅的客户端被授予的最大QoS等级是1，那么匹配这个过滤器的QoS等级0的应用消息会按QoS等级0分发给这个客户端。这意味着客户端最多收到这个消息的一个副本。从另一方面说，发布给同一主题的QoS等级2的消息会被服务端降级到QoS等级1再分发给客户端，因此客户端可能会收到重复的消息副本。</p><p>如果正在订阅的客户端被授予的最大QoS等级是0，那么原来按QoS等级2发布给客户端的应用消息在繁忙时可能会丢失，但是服务端不应该发送重复的消息副本。发布给同一主题的 QoS等级1的消息在传输给客户端时可能会丢失或重复。</p><p><strong>非规范评注</strong></p><p>使用QoS等级2订阅一个主题过滤器等于是说：<em>我想要按照它们发布时的QoS等级接受匹配这个过滤器的消息</em> 。这意味着，确定消息分发时可能的最大QoS等级是发布者的责任，而订阅者可以要求服务端降低QoS到更适合它的等级。</p></blockquote><h2 id="3-9-SUBACK-–-订阅确认">3.9 3.9 SUBACK – 订阅确认</h2><p>服务端发送SUBACK报文给客户端，用于确认它已收到并且正在处理SUBSCRIBE报文。</p><p>SUBACK报文包含一个返回码清单，它们指定了SUBSCRIBE请求的每个订阅被授予的最大QoS等级。</p><h3 id="3-9-1-固定报头">3.9.1 3.9.1 固定报头</h3><h5 id="图例-3-24-–-SUBACK报文固定报头">3.9.1.0.1 图例 3.24 – SUBACK报文固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (9)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>剩余长度字段</strong></p><p>等于可变报头的长度加上有效载荷的长度。</p><h3 id="3-9-2-可变报头">3.9.2 3.9.2 可变报头</h3><p>可变报头包含等待确认的SUBSCRIBE报文的报文标识符。<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0309-SUBACK.html#_%E5%9B%BE%E4%BE%8B_3.25_%E2%80%93">图例 3.25 – SUBACK报文可变报头</a> 描述了可变报头的格式。</p><h5 id="图例-3-25-–-SUBACK报文可变报头">3.9.2.0.1 图例 3.25 – SUBACK报文可变报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="3-9-3-有效载荷">3.9.3 3.9.3 有效载荷</h3><p>有效载荷包含一个返回码清单。每个返回码对应等待确认的SUBSCRIBE报文中的一个主题过滤器。返回码的顺序<strong>必须</strong>和SUBSCRIBE报文中主题过滤器的顺序相同 [MQTT-3.9.3-1]。</p><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0309-SUBACK.html#_Figure_3.26_-">图例 3.26 – SUBACK报文有效载荷格式</a> 描述了有效载荷中单字节编码的返回码字段。</p><h5 id="图例-3-26-–-SUBACK报文有效载荷格式">3.9.3.0.1 图例 3.26 – SUBACK报文有效载荷格式</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td></td><td>返回码</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 1</td><td>X</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>X</td><td>X</td></tr></tbody></table><p>允许的返回码值：</p><ul><li>0x00 - 最大QoS 0</li><li>0x01 - 成功 – 最大QoS 1</li><li>0x02 - 成功 – 最大 QoS 2</li><li>0x80 - Failure 失败</li></ul><p>0x00, 0x01, 0x02, 0x80之外的SUBACK返回码是保留的，<strong>不能</strong>使用[MQTT-3.9.3-2]。</p><h4 id="有效载荷非规范示例-1">3.9.3.1 有效载荷非规范示例</h4><blockquote><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0309-SUBACK.html#_Figure_3.27_-">图例 3.27 -有效载荷字节格式非规范示例</a> 展示了在 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0309-SUBACK.html#_Table_3.5_-">表格 3.6 -有效载荷非规范示例</a> 简要描述的SUBACK报文的有效载荷。</p></blockquote><h5 id="表格-3-6-有效载荷非规范示例">3.9.3.1.1 表格 3.6 -有效载荷非规范示例</h5><table><thead><tr><th>Success - Maximum QoS 0</th><th>0</th></tr></thead><tbody><tr><td>Success - Maximum QoS 2</td><td>2</td></tr><tr><td>Failure</td><td>128</td></tr></tbody></table><h5 id="图例-3-27-有效载荷字节格式非规范示例">3.9.3.1.2 图例 3.27 -有效载荷字节格式非规范示例</h5><table><thead><tr><th></th><th><strong>描述</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>Success - Maximum QoS 0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>Success - Maximum QoS 2</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>byte 3</td><td>Failure</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h2 id="3-10-UNSUBSCRIBE-–取消订阅">3.10 3.10 UNSUBSCRIBE –取消订阅</h2><p>客户端发送UNSUBSCRIBE报文给服务端，用于取消订阅主题。</p><h3 id="3-10-1-固定报头">3.10.1 3.10.1 固定报头</h3><h5 id="图例-3-28-–-UNSUBSCRIBE报文固定报头">3.10.1.0.1 图例 3.28 – UNSUBSCRIBE报文固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (10)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>UNSUBSCRIBE报文固定报头的第3,2,1,0位是保留位且<strong>必须</strong>分别设置为0,0,1,0。服务端<strong>必须</strong>认为任何其它的值都是不合法的并关闭网络连接 [MQTT-3.10.1-1]。</p><p><strong>剩余长度字段</strong></p><p>等于可变报头的长度加上有效载荷的长度。</p><h3 id="3-10-2-可变报头">3.10.2 3.10.2 可变报头</h3><p>可变报头包含一个报文标识符。2.3.1节提供了有关报文标识符的更多信息。</p><h5 id="图例-3-29-–-UNSUBSCRIBE报文可变报头">3.10.2.0.1 图例 3.29 – UNSUBSCRIBE报文可变报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="3-10-3-有效载荷">3.10.3 3.10.3 有效载荷</h3><p>UNSUBSCRIBE报文的有效载荷包含客户端想要取消订阅的主题过滤器列表。UNSUBSCRIBE报文中的主题过滤器<strong>必须</strong>是连续打包的、按照1.5.3节定义的UTF-8编码字符串 [MQTT-3.10.3-1]。</p><p>UNSUBSCRIBE报文的有效载荷<strong>必须</strong>至少包含一个消息过滤器。没有有效载荷的UNSUBSCRIBE报文是违反协议的 [MQTT-3.10.3-2]。有关错误处理的更多信息请查看4.8节。</p><h4 id="有效载荷非规范示例-2">3.10.3.1 有效载荷非规范示例</h4><blockquote><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0310-UNSUBSCRIBE.html#_Figure_3.30_-">图例 3.30 -有效载荷字节格式非规范示例</a> 展示了 <a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/0310-UNSUBSCRIBE.html#_Table3.6_-_Payload">表格 3.7 -有效载荷非规范示例</a> 简要描述的UNSUBSCRIBE报文的有效载荷。</p></blockquote><h5 id="表格-3-7-有效载荷非规范示例">3.10.3.1.1 表格 3.7 -有效载荷非规范示例</h5><table><thead><tr><th>主题过滤器</th><th>“a/b”</th></tr></thead><tbody><tr><td>主题过滤器</td><td>“c/d”</td></tr></tbody></table><h5 id="图例-3-30-有效载荷字节格式非规范示例">3.10.3.1.2 图例 3.30 -有效载荷字节格式非规范示例</h5><table><thead><tr><th></th><th><strong>描述</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>主题过滤器</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 1</td><td>Length MSB (0)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>Length LSB (3)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>byte 3</td><td>‘a’ (0x61)</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>byte 4</td><td>‘/’ (0x2F)</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>byte 5</td><td>‘b’ (0x62)</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>主题过滤器</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 6</td><td>Length MSB (0)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 7</td><td>Length LSB (3)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>byte 8</td><td>‘c’ (0x63)</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>byte 9</td><td>‘/’ (0x2F)</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>byte 10</td><td>‘d’ (0x64)</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><h3 id="3-10-4-响应">3.10.4 3.10.4 响应</h3><p>UNSUBSCRIBE报文提供的主题过滤器（无论是否包含通配符）<strong>必须</strong>与服务端持有的这个客户端的当前主题过滤器集合逐个字符比较。如果有任何过滤器完全匹配，那么它（服务端）自己的订阅将被删除，否则不会有进一步的处理 [MQTT-3.10.4-1]。</p><p>如果服务端删除了一个订阅：</p><ul><li>它<strong>必须</strong>停止分发任何新消息给这个客户端 [MQTT-3.10.4-2]。</li><li>它<strong>必须</strong>完成分发任何已经开始往客户端发送的QoS 1和QoS 2的消息 [MQTT-3.10.4-3]。</li><li>它<strong>可以</strong>继续发送任何现存的准备分发给客户端的缓存消息。</li></ul><p>服务端<strong>必须</strong>发送UNSUBACK报文响应客户端的UNSUBSCRIBE请求。UNSUBACK报文<strong>必须</strong>包含和UNSUBSCRIBE报文相同的报文标识符 [MQTT-3.10.4-4]。即使没有删除任何主题订阅，服务端也<strong>必须</strong>发送一个UNSUBACK响应 [MQTT-3.10.4-5]。</p><p>如果服务端收到包含多个主题过滤器的UNSUBSCRIBE报文，它<strong>必须</strong>如同收到了一系列的多个UNSUBSCRIBE报文一样处理那个报文，除了将它们的响应合并到一个单独的UNSUBACK报文外。 [MQTT-3.10.4-6]。</p><h2 id="3-11-UNSUBACK-–-取消订阅确认">3.11 3.11 UNSUBACK – 取消订阅确认</h2><p>服务端发送UNSUBACK报文给客户端用于确认收到UNSUBSCRIBE报文。</p><h3 id="3-11-1-固定报头">3.11.1 3.11.1 固定报头</h3><h5 id="图例-3-31-–-UNSUBACK报文固定报头">3.11.1.0.1 图例 3.31 – UNSUBACK报文固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (11)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (2)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (11)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (2)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p><strong>剩余长度字段</strong></p><p>表示可变报头的长度，对UNSUBACK报文这个值等于2。</p><h3 id="3-11-2-可变报头">3.11.2 3.11.2 可变报头</h3><p>可变报头包含等待确认的UNSUBSCRIBE报文的报文标识符。</p><h5 id="图例-3-32-–-UNSUBACK报文可变报头">3.11.2.0.1 图例 3.32 – UNSUBACK报文可变报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>报文标识符 MSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>byte 2</td><td>报文标识符 LSB</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="3-11-3-有效载荷">3.11.3 3.11.3 有效载荷</h3><p>UNSUBACK报文没有有效载荷。</p><h2 id="3-12-PINGREQ-–-心跳请求">3.12 3.12 PINGREQ – 心跳请求</h2><p>客户端发送PINGREQ报文给服务端的。用于：</p><ol><li>在没有任何其它控制报文从客户端发给服务的时，告知服务端客户端还活着。</li><li>请求服务端发送 响应确认它还活着。</li><li>使用网络以确认网络连接没有断开。</li></ol><p>保持连接（Keep Alive）处理中用到这个报文，详细信息请查看 3.1.2.10节。</p><h3 id="3-12-1-固定报头">3.12.1 3.12.1 固定报头</h3><h5 id="图例-3-33-–-PINGREQ报文固定报头">3.12.1.0.1 图例 3.33 – PINGREQ报文固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (12)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (0)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (12)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (0)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h3 id="3-12-2-可变报头">3.12.2 3.12.2 可变报头</h3><p>PINGREQ报文没有可变报头。</p><h3 id="3-12-3-有效载荷">3.12.3 3.12.3 有效载荷</h3><p>PINGREQ报文没有有效载荷。</p><h3 id="3-12-4-响应">3.12.4 3.12.4 响应</h3><p>服务端<strong>必须</strong>发送 PINGRESP报文响应客户端的PINGREQ报文 [MQTT-3.12.4-1]。</p><h2 id="3-13-PINGRESP-–-心跳响应">3.13 3.13 PINGRESP – 心跳响应</h2><p>服务端发送PINGRESP报文响应客户端的PINGREQ报文。表示服务端还活着。</p><p>保持连接（Keep Alive）处理中用到这个报文，详情请查看 3.1.2.10节。</p><h3 id="3-13-1-固定报头">3.13.1 3.13.1 固定报头</h3><h5 id="图例-3-34-–-PINGRESP报文固定报头">3.13.1.0.1 图例 3.34 – PINGRESP报文固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (13)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (0)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h3 id="3-13-2-可变报头">3.13.2 3.13.2 可变报头</h3><p>PINGRESP报文没有可变报头。</p><h3 id="3-13-3-有效载荷">3.13.3 3.13.3 有效载荷</h3><p>PINGRESP报文没有有效载荷。</p><h2 id="3-14-DISCONNECT-–断开连接">3.14 3.14 DISCONNECT –断开连接</h2><p>DISCONNECT报文是客户端发给服务端的最后一个控制报文。表示客户端正常断开连接。</p><h3 id="3-14-1-固定报头">3.14.1 3.14.1 固定报头</h3><h5 id="图例-3-35-–-DISCONNECT报文固定报头">3.14.1.0.1 图例 3.35 – DISCONNECT报文固定报头</h5><table><thead><tr><th><strong>Bit</strong></th><th><strong>7</strong></th><th><strong>6</strong></th><th><strong>5</strong></th><th><strong>4</strong></th><th><strong>3</strong></th><th><strong>2</strong></th><th><strong>1</strong></th><th><strong>0</strong></th></tr></thead><tbody><tr><td>byte 1</td><td>MQTT控制报文类型 (14)</td><td>保留位</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>byte 2</td><td>剩余长度 (0)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>服务端<strong>必须</strong>验证所有的保留位都被设置为0，如果它们不为0<strong>必须</strong>断开连接 [MQTT-3.14.1-1]。</p><h3 id="3-14-2-可变报头">3.14.2 3.14.2 可变报头</h3><p>DISCONNECT报文没有可变报头。</p><h3 id="3-14-3-有效载荷">3.14.3 3.14.3 有效载荷</h3><p>DISCONNECT报文没有有效载荷。</p><h3 id="3-14-4-响应">3.14.4 3.14.4 响应</h3><p>客户端发送DISCONNECT报文之后：</p><ul><li><strong>必须</strong>关闭网络连接 [MQTT-3.14.4-1]。</li><li><strong>不能</strong>通过那个网络连接再发送任何控制报文 [MQTT-3.14.4-2]。</li></ul><p>服务端在收到DISCONNECT报文时：</p><ul><li><strong>必须</strong>丢弃任何与当前连接关联的未发布的遗嘱消息，具体描述见 3.1.2.5节 [MQTT-3.14.4-3]。</li><li><strong>应该</strong>关闭网络连接，如果客户端 还没有这么做。</li></ul><h1 id="第四章-操作行为-Operational-behavior">4 第四章 操作行为 Operational behavior</h1><h2 id="4-1-状态存储-Storing-state">4.1 4.1 状态存储 Storing state</h2><p>为了提供服务质量保证，客户端和服务端有必要存储会话状态。在整个会话期间，客户端和服务端都<strong>必须</strong>存储会话状态 [MQTT-4.1.0-1]。会话<strong>必须</strong>至少持续和它的活跃网络连接同样长的时间 [MQTT-4.1.0-2]。</p><p>服务端的保留消息不是会话状态的组成部分。服务端<strong>应该</strong>保留那种消息直到客户端删除它。</p><blockquote><p><strong>非规范评注</strong></p><p>客户端和服务端实现的存储容量必然是有限的，还可能要受管理策略的限制，比如跨网络连接的会话状态的最大存储时间。已保存的会话状态丢失可能是某个管理操作造成的，例如对某个预定义条件的自动响应。它造成的后果就是会话终止。这些操作可能是资源限制或其他操作原因引发的。需要谨慎的评估客户端和服务端的存储容量，以确保存储空间够用。</p><p><strong>非规范评注</strong></p><p>客户端或服务端的软硬件故障都可能导致会话状态的丢失或损坏。</p><p><strong>非规范评注</strong></p><p>服务器和客户端操作正常可能意味着，已保存的状态丢失或损坏是管理操作或软硬件故障造成的。管理操作可能是对某个预定义条件的自动响应。这些操作可能是资源限制或其他操作原因引发的。例如，服务端可能会基于外部条件，决定不再将某个消息或某些消息分发给任何当前的或以后的客户端。</p><p><strong>非规范评注</strong></p><p>MQTT用户应该评估MQTT客户端和服务端实现的存储容量，确保能满足需求。</p></blockquote><h4 id="非规范示例">4.1.0.1 非规范示例</h4><p>例如，想要收集电表读数的用户可能会决定使用QoS 1等级的消息，因为他们不能接受数据在网络传输途中丢失，但是，他们可能认为客户端和服务端的数据可以存储在内存（易失性存储器）中，因为（他们觉得）电力供应是非常可靠的，不会有太大的数据丢失风险。</p><p>与之相反，停车计费支付应用的提供商可能决定任何情况下都不能让数据支付消息丢失，因此他们要求在通过网络传输之前，所有的数据必须写入到非易失性存储器中（如硬盘）。</p><h2 id="4-2-网络连接-Network-Connections">4.2 4.2 网络连接 Network Connections</h2><p>MQTT协议要求基础传输层能够提供有序的、可靠的、双向传输（从客户端到服务端 和从服务端到客户端）的字节流。</p><blockquote><p><strong>非规范评注</strong></p><p>MQTT 3.1使用的传输层协议是 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/04-OperationalBehavior.html#RFC793">RFC793</a>] 定义的TCP/IP协议。下面的协议也支持：</p></blockquote><ul><li>TLS协议 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/04-OperationalBehavior.html#RFC5246">RFC5246]</a></li><li>WebSocket协议 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/04-OperationalBehavior.html#RFC6455">RFC6455]</a></li></ul><blockquote><p><strong>非规范评注</strong></p><p>TCP端口8883和1883已在IANA注册，分别用于MQTT的TLS和非TLS通信。</p></blockquote><p>无连接的网络传输协议如UDP是不支持的，因为他们可能会丢失数据包或对数据包重排序。</p><h2 id="4-3-服务质量等级和协议流程-QoS">4.3 4.3 服务质量等级和协议流程 QoS</h2><p>MQTT按照这里定义的服务质量 (QoS) 等级分发应用消息。分发协议是对称的，在下面的描述中，客户端和服务端既可以是发送者也可以是接收者。分发协议关注的是从单个发送者到单个接收者的应用消息。服务端分发应用消息给多个客户端时，每个客户端独立处理。分发给客户端的出站应用消息和入站应用消息的QoS等级可能是不同的。</p><p>下面的非规范流程图展示了可能的实现方法。</p><h3 id="4-3-1-QoS-0-最多分发一次">4.3.1 4.3.1 QoS 0:最多分发一次</h3><p>消息的分发依赖于底层网络的能力。接收者不会发送响应，发送者也不会重试。消息可能送达一次也可能根本没送达。</p><p>对于QoS 0的分发协议，发送者</p><ul><li><strong>必须</strong>发送QoS等于0，DUP等于0的PUBLISH报文 [MQTT-4.3.1-1]。</li></ul><p>对于QoS 0的分发协议，接收者</p><ul><li>接受PUBLISH报文时同时接受消息的所有权。</li></ul><h5 id="图例-4-1-–-QoS-0协议流程图，非规范示例">4.3.1.0.1 图例 4.1 – QoS 0协议流程图，非规范示例</h5><table><thead><tr><th><strong>发送者动作</strong></th><th><strong>控制报文</strong></th><th><strong>接收者动作</strong></th></tr></thead><tbody><tr><td>PUBLISH 报文 QoS 0, DUP=0</td><td></td><td></td></tr><tr><td></td><td>———-&gt;</td><td></td></tr><tr><td></td><td></td><td>分发应用消息给适当的后续接收者（们）</td></tr></tbody></table><h3 id="4-3-2-QoS-1-至少分发一次">4.3.2 4.3.2 QoS 1: 至少分发一次</h3><p>服务质量确保消息至少送达一次。QoS 1的PUBLISH报文的可变报头中包含一个报文标识符，需要PUBACK报文确认。2.3.1节提供了有关报文标识符的更多信息。</p><p>对于QoS 1的分发协议，发送者</p><ul><li>每次发送新的应用消息都<strong>必须</strong>分配一个未使用的报文标识符。</li><li>发送的PUBLISH报文<strong>必须</strong>包含报文标识符且QoS等于1，DUP等于0。</li><li><strong>必须</strong>将这个PUBLISH报文看作是 <em>未确认的</em> ，直到从接收者那收到对应的PUBACK报文。4.4节有一个关于未确认消息的讨论。</li></ul><blockquote><p>[MQTT-4.3.2-1].</p><p>一旦发送者收到PUBACK报文，这个报文标识符就可以重用。</p></blockquote><p>注意：允许发送者在等待确认时使用不同的报文标识符发送后续的PUBLISH报文。</p><p>对于QoS 1的分发协议，接收者</p><ul><li>响应的PUBACK报文<strong>必须</strong>包含一个报文标识符，这个标识符来自接收到的、已经接受所有权的PUBLISH报文。</li><li>发送了PUBACK报文之后，接收者必须将任何包含相同报文标识符的入站PUBLISH报文当作一个新的消息，并忽略它的DUP标志的值。</li></ul><blockquote><p>[MQTT-4.3.2-2].</p></blockquote><h5 id="图例-4-2-–-QoS-1协议流程图，非规范示例">4.3.2.0.1 图例 4.2 – QoS 1协议流程图，非规范示例</h5><table><thead><tr><th><strong>发送者动作</strong></th><th><strong>控制报文</strong></th><th><strong>接收者动作</strong></th></tr></thead><tbody><tr><td>存储消息</td><td></td><td></td></tr><tr><td>发送PUBLISH报文 QoS=1, DUP=0，带报文标识符</td><td>———-&gt;</td><td></td></tr><tr><td></td><td></td><td>开始应用消息的后续分发1</td></tr><tr><td></td><td>&lt;———-</td><td>发送PUBACK报文，带报文标识符</td></tr><tr><td>丢弃消息</td><td></td><td></td></tr></tbody></table><blockquote><p>1不要求接收者在发送PUBACK之前完整分发应用消息。原来的发送者收到PUBACK报文之后，应用消息的所有权就会转移给这个接收者。</p></blockquote><h3 id="4-3-3-QoS-2-仅分发一次">4.3.3 4.3.3 QoS 2: 仅分发一次</h3><p>这是最高等级的服务质量，消息丢失和重复都是不可接受的。使用这个服务质量等级会有额外的开销。</p><p>QoS 2的消息可变报头中有报文标识符。2.3.1节提供了有关报文标识符的更多信息。QoS 2的PUBLISH报文的接收者使用一个两步确认过程来确认收到。</p><p>对于QoS 2的分发协议，发送者</p><ul><li>必须给要发送的新应用消息分配一个未使用的报文标识符。</li><li>发送的PUBLISH报文<strong>必须</strong>包含报文标识符且报文的QoS等于2,，DUP等于0。</li><li><strong>必须</strong>将这个PUBLISH报文看作是 <em>未确认的</em> ，直到从接收者那收到对应的PUBREC报文。4.4节有一个关于未确认消息的讨论。</li><li>收到PUBREC报文后<strong>必须</strong>发送一个PUBREL报文。PUBREL报文必须包含与原始PUBLISH报文相同的报文标识符。</li><li><strong>必须</strong>将这个PUBREL报文看作是 <em>未确认的</em> ，直到从接收者那收到对应的PUBCOMP报文。</li><li>一旦发送了对应的PUBREL报文就<strong>不能</strong>重发这个PUBLISH报文。</li></ul><p>[MQTT-4.3.3-1].</p><blockquote><p>一旦发送者收到PUBCOMP报文，这个报文标识符就可以重用。</p></blockquote><p>注意：允许发送者在等待确认时使用不同的报文标识符发送后续的PUBLISH报文。</p><p>对于QoS 2的分发协议，接收者</p><ul><li>响应的PUBREC报文<strong>必须</strong>包含报文标识符，这个标识符来自接收到的、已经接受所有权的PUBLISH报文。</li><li>在收到对应的PUBREL报文之前，接收者<strong>必须</strong>发送PUBREC报文确认任何后续的具有相同标识符的PUBLISH报文。 在这种情况下，它<strong>不能</strong>重复分发消息给任何后续的接收者。</li><li>响应PUBREL报文的PUBCOMP报文<strong>必须</strong>包含与PUBREL报文相同的标识符。</li><li>发送PUBCOMP报文之后，接收者必须将包含相同报文标识符的任何后续PUBLISH报文当作一个新的发布。</li></ul><p>[MQTT-4.3.3-2].</p><h5 id="图例-4-3-–-QoS-2协议流程图，非规范示例">4.3.3.0.1 图例 4.3 – QoS 2协议流程图，非规范示例</h5><table><thead><tr><th><strong>发送者动作</strong></th><th><strong>控制报文</strong></th><th><strong>接收者动作</strong></th></tr></thead><tbody><tr><td>存储消息</td><td></td><td></td></tr><tr><td>发送PUBLISH报文，QoS=2, DUP=0，带报文标识符</td><td></td><td></td></tr><tr><td></td><td>———-&gt;</td><td></td></tr><tr><td></td><td></td><td>方法A：存储消息，或方法B：存储报文标识符，然后开始向前分发这个应用消息1。</td></tr><tr><td></td><td></td><td>发送PUBREC报文，带报文标识符。</td></tr><tr><td></td><td>&lt;———-</td><td></td></tr><tr><td>丢弃消息，存储PUBREC中的报文标识符</td><td></td><td></td></tr><tr><td>发送PUBREL报文，带报文标识符</td><td></td><td></td></tr><tr><td></td><td>———-&gt;</td><td></td></tr><tr><td></td><td></td><td>方法A：开始向前分发应用消息1然后丢弃消息 或方法B：丢弃报文标识符</td></tr><tr><td></td><td></td><td>发送PUBCOMP报文，带报文标识符</td></tr><tr><td></td><td>&lt;———-</td><td></td></tr><tr><td>丢弃已保存的状态</td><td></td><td></td></tr></tbody></table><blockquote><p>1 不要求接收者在发送PUBREC或PUBCOMP之前完整分发应用消息。原来的发送者收到PUBREC报文之后，应用消息的所有权就会转移给这个接收者。</p><p><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/04-OperationalBehavior.html#_Figure_4.3_%E2%80%93">图例 4.3 – QoS 2协议流程图，非规范示例</a> 展示了接收者对QoS 2等级消息的两种处理方法。他们的区别是消息什么时候可以开始分发。实现者可以决定使用哪种方法。只要实现者只选择了一种方法，就不会影响QoS流程的可靠性。</p></blockquote><h2 id="4-4-消息分发重试-Message-delivery-retry">4.4 4.4 消息分发重试 Message delivery retry</h2><p>客户端设置清理会话（CleanSession）标志为0重连时，客户端和服务端<strong>必须</strong>使用原始的报文标识符重发任何未确认的PUBLISH报文（如果QoS&gt;0）和PUBREL报文 [MQTT-4.4.0-1]。这是唯一<strong>要求</strong>客户端或服务端重发消息的情况。</p><blockquote><p><strong>非规范评注</strong></p><p>控制报文的重发曾经需要克服某些陈旧TCP网络上的数据丢失问题。部署在那些环境中的MQTT 3.1.1实现可能仍然需要关注这个问题。</p></blockquote><h2 id="4-5-消息收到-Message-receipt">4.5 4.5 消息收到 Message receipt</h2><p>服务端接管入站应用消息的所有权时，它<strong>必须</strong>将消息添加到订阅匹配的客户端的会话状态中。匹配规则定义见 4.7节 [MQTT-4.5.0-1]。</p><p>正常情况下，客户端收到发送给它的订阅的消息。客户端也可能收到不是与它的订阅精确匹配的消息。如果服务端自动给客户端分配了一个订阅，可能发生这种情况。正在处理UBSUBSCRIBE请求时也可能收到消息。客户端<strong>必须</strong>按照可用的服务质量（QoS）规则确认它收到的任何PUBLISH报文，不管它选择是否处理报文包含的应用消息 [MQTT-4.5.0-2]。</p><h2 id="4-6-消息排序-Message-ordering">4.6 4.6 消息排序 Message ordering</h2><p>实现本章定义的协议流程时，客户端<strong>必须</strong>遵循下列规则：</p><ul><li>重发任何之前的PUBLISH报文时，<strong>必须</strong>按原始PUBLISH报文的发送顺序重发（适用于QoS 1和QoS 2消息）[MQTT-4.6.0-1]。</li><li><strong>必须</strong>按照对应的PUBLISH报文的顺序发送PUBACK报文（QoS 1消息）[MQTT-4.6.0-2]。</li><li><strong>必须</strong>按照对应的PUBLISH报文的顺序发送PUBREC报文（QoS 2消息）[MQTT-4.6.0-3]。</li><li><strong>必须</strong>按照对应的PUBREC报文的顺序发送PUBREL报文（QoS 2消息）[MQTT-4.6.0-4]。</li></ul><p>服务端<strong>必须</strong>默认认为每个主题都是有序的。它<strong>可以</strong>提供一个管理功能或其它机制，以允许将一个或多个主题当作是无序的 [MQTT-4.6.0-5]。</p><p>服务端处理发送给有序主题的消息时，<strong>必须</strong>按照上面的规则将消息分发给每个订阅者。此外，它<strong>必须</strong>按照从客户端收到的顺序发送PUBLISH报文给消费者（对相同的主题和QoS）[MQTT-4.6.0-6]。</p><blockquote><p><strong>非规范评注</strong></p><p>上面列出的规则确保，使用QoS 1发布和订阅的消息流，订阅者按照消息发布时的顺序收到每条消息的最终副本，但是消息可能会重复，这可能导致在它的后继消息之后收到某个已经收到消息的重发版本。例如，发布者按顺序1,2,3,4发送消息，订阅者收到的顺序可能是1,2,3,2,3,4。</p><p>如果客户端和服务端能保证任何时刻最多有一条消息在 <em>传输中（in-flight）</em>（在某条消息被确认前不发送后面的那条消息），那么，不会有QoS 1的消息会在它的任何后续消息之后收到。 例如，订阅者收到的顺序可能是1,2,3,3,4，而不是1,2,3,2,3,4。将传输窗口 （in-flight window）设为1意味着，在同一个主题上，即使发布者发送了一系列不同QoS等级的消息，它们的顺序也被保留。</p></blockquote><h2 id="4-7-主题名和主题过滤器-Topic-Names-and-Topic-Filters">4.7 4.7 主题名和主题过滤器 Topic Names and Topic Filters</h2><h3 id="4-7-1-主题通配符-Topic-wildcards">4.7.1 4.7.1 主题通配符 Topic wildcards</h3><p>主题层级（topic level）分隔符用于将结构化引入主题名。如果存在分隔符，它将主题名分割为多个<em>主题层级 topic level</em> 。</p><p>订阅的主题过滤器可以包含特殊的通配符，允许你一次订阅多个主题。</p><p>主题过滤器中可以使用通配符，但是主题名<strong>不能</strong>使用通配符 [MQTT-4.7.1-1]。</p><h4 id="主题层级分隔符-Topic-level-separator">4.7.1.1 主题层级分隔符 Topic level separator</h4><p>斜杠（‘/’ U+002F）用于分割主题的每个层级，为主题名提供一个分层结构。当客户端订阅指定的主题过滤器包含两种通配符时，主题层级分隔符就很有用了。主题层级分隔符可以出现在主题过滤器或主题名字的任何位置。相邻的主题层次分隔符表示一个零长度的主题层级。</p><h4 id="多层通配符-Multi-level-wildcard">4.7.1.2 多层通配符 Multi-level wildcard</h4><p>数字标志（‘#’ U+0023）是用于匹配主题中任意层级的通配符。多层通配符表示它的父级和任意数量的子层级。多层通配符必须位于它自己的层级或者跟在主题层级分隔符后面。不管哪种情况，它都<strong>必须</strong>是主题过滤器的最后一个字符 [MQTT-4.7.1-2]。</p><blockquote><p><strong>非规范评注</strong></p><p>例如，如果客户端订阅主题 “sport/tennis/player1/#”，它会收到使用下列主题名发布的消息：</p></blockquote><ul><li>“sport/tennis/player1”</li><li>“sport/tennis/player1/ranking”</li><li>“sport/tennis/player1/score/wimbledon”</li></ul><blockquote><p><strong>非规范评注</strong></p></blockquote><ul><li>“sport/#”也匹配单独的 “sport” ，因为 # 包括它的父级。</li><li>“#”是有效的，会收到所有的应用消息。</li><li>“sport/tennis/#”也是有效的。</li><li>“sport/tennis#”是无效的。</li><li>“sport/tennis/#/ranking”是无效的。</li></ul><h4 id="单层通配符">4.7.1.3 单层通配符</h4><p>加号 (‘+’ U+002B) 是只能用于单个主题层级匹配的通配符。</p><p>在主题过滤器的任意层级都可以使用单层通配符，包括第一个和最后一个层级。然而它<strong>必须</strong>占据过滤器的整个层级 [MQTT-4.7.1-3]。可以在主题过滤器中的多个层级中使用它，也可以和多层通配符一起使用。</p><blockquote><p><strong>非规范评注</strong></p><p>例如， “sport/tennis/+” 匹配 “sport/tennis/player1” 和 “sport/tennis/player2” ，但是不匹配 “sport/tennis/player1/ranking” 。同时，由于单层通配符只能匹配一个层级， “sport/+” 不匹配 “sport” 但是却匹配 “sport/”。</p><p><strong>非规范评注</strong></p></blockquote><ul><li>“+” 是有效的。</li><li>“+/tennis/#” 是有效的。</li><li>“sport+” 是无效的。</li><li>“sport/+/player1” 也是有效的。</li><li>“/finance” 匹配 “+/+” 和 “/+” ，但是不匹配 “+”。</li></ul><h3 id="4-7-2-以-开头的主题-Topics-beginning-with">4.7.2 4.7.2 以$开头的主题 Topics beginning with $</h3><p>服务端<strong>不能</strong>将 $ 字符开头的主题名匹配通配符 (#或+) 开头的主题过滤器 [MQTT-4.7.2-1]。服务端应该阻止客户端使用这种主题名与其它客户端交换消息。服务端实现可以将 $ 开头的主题名用作其他目的。</p><blockquote><p><strong>非规范评注</strong></p></blockquote><ul><li>$SYS/ 被广泛用作包含服务器特定信息或控制接口的主题的前缀。</li><li>应用不能使用 $ 字符开头的主题。</li></ul><blockquote><p><strong>非规范评注</strong></p></blockquote><ul><li>订阅 “#” 的客户端不会收到任何发布到以 “$” 开头主题的消息。</li><li>订阅 “+/monitor/Clients” 的客户端不会收到任何发布到 “$SYS/monitor/Clients” 的消息。</li><li>订阅 “$SYS/#” 的客户端会收到发布到以 “$SYS/” 开头主题的消息。</li><li>订阅 “$SYS/monitor/+” 的客户端会收到发布到 “$SYS/monitor/Clients” 主题的消息。</li><li>如果客户端想同时接受以 “$SYS/” 开头主题的消息和不以 $ 开头主题的消息，它需要同时订阅 “#” 和 ““$SYS/#”。</li></ul><h3 id="4-7-3-主题语义和用法-Topic-semantic-and-usage">4.7.3 4.7.3 主题语义和用法 Topic semantic and usage</h3><p>主题名和主题过滤器必须符合下列规则：</p><ul><li>所有的主题名和主题过滤器<strong>必须</strong>至少包含一个字符 [MQTT-4.7.3-1]。</li><li>主题名和主题过滤器是区分大小写的。</li><li>主题名和主题过滤器可以包含空格。</li><li>主题名或主题过滤器以前置或后置斜杠 “/” 区分。</li><li>只包含斜杠 “/” 的主题名或主题过滤器是合法的。</li><li>主题名和主题过滤器<strong>不能</strong>包含空字符 (Unicode U+0000) [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/04-OperationalBehavior.html#Unicode">Unicode</a>] [MQTT-4.7.3-2]。</li><li>主题名和主题过滤器是UTF-8编码字符串，它们<strong>不能</strong>超过65535字节 [MQTT-4.7.3-3]。见 1.5.3节。</li></ul><p>除了不能超过UTF-编码字符串的长度限制之外，主题名或主题过滤器的层级数量没有其它限制。</p><p>匹配订阅时，服务端<strong>不能</strong>对主题名或主题过滤器执行任何规范化（normalization）处理，不能修改或替换任何未识别的字符 [MQTT-4.7.3-4]。主题过滤器中的每个非通配符层级需要逐字符匹配主题名中对应的层级才算匹配成功。</p><blockquote><p><strong>非规范评注</strong></p><p>使用UTF-8编码规则意味着，主题过滤器和主题名的比较可以通过比较编码后的UTF-8字节或解码后的Unicode字符。</p><p><strong>非规范评注</strong></p></blockquote><ul><li>“ACCOUNTS” 和 “Accounts” 是不同的主题名。</li><li>“Accounts payable” 是合法的主题名</li><li>“/finance” 和 “finance” 是不同的。</li></ul><p>如果订阅的主题过滤器与消息的主题名匹配，应用消息会被发送给每一个匹配的客户端订阅。主题可能是管理员在服务端预先定义好的，也可能是服务端收到第一个订阅或使用那个主题名的应用消息时动态添加的。服务端也可以使用一个安全组件有选择地授权客户端使用某个主题资源。</p><h2 id="4-8-错误处理-Handling-errors">4.8 4.8 错误处理 Handling errors</h2><p>除非另有说明，如果服务端或客户端遇到了协议违规的行为，它<strong>必须</strong>关闭传输这个协议违规控制报文的网络连接 [MQTT-4.8.0-1]。</p><p>客户端或服务端实现可能会遇到瞬时错误（Transient Error）（例如内部缓冲区满了的情况）导致无法成功处理MQTT报文。</p><p>如果客户端或服务端处理入站控制报文时遇到了瞬时错误，它<strong>必须</strong>关闭传输那个控制报文的网络连接 [MQTT-4.8.0-2]。如果服务端发现了瞬时错误，它<strong>不应该</strong>断开连接或者执行任何对其它客户端有影响的操作。</p><h1 id="第五章-安全">5 第五章 安全</h1><h2 id="目录">5.1 目录</h2><ul><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html">第一章 - 介绍</a></li><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/02-ControlPacketFormat.html">第二章 – MQTT控制报文格式</a></li><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/03-ControlPackets.html">第三章 – MQTT控制报文</a></li><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/04-OperationalBehavior.html">第四章 – 操作行为</a></li><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html">第五章 – 安全</a></li><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/06-WebSocket.html">第六章 – 使用WebSocket</a></li><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/07-Conformance.html">第七章 – 一致性目标</a></li><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/08-AppendixB.html">附录B - 强制性规范声明</a></li></ul><h2 id="5-1-概述">5.2 5.1 概述</h2><p>本章的内容仅供参考，是非规范化的。然而，强烈推荐提供TLS的服务端实现<strong>应该</strong>使用TCP端口8883（IANA服务名：secure-mqtt）。</p><p>解决方案提供者需要考虑很多风险。例如：</p><ul><li>设备可能会被盗用</li><li>客户端和服务端的静态数据可能是可访问的（可能会被修改）</li><li>协议行为可能有副作用（如计时器攻击）</li><li>拒绝服务攻击</li><li>通信可能会被拦截、修改、重定向或者泄露</li><li>虚假控制报文注入</li></ul><p>MQTT方案通常部署在不安全的通信环境中。在这种情况下，协议实现通常需要提供这些机制：</p><ul><li>用户和设备身份认证</li><li>服务端资源访问授权</li><li>MQTT控制报文和内嵌应用数据的完整性校验</li><li>MQTT控制报文和内嵌应用数据的隐私控制</li></ul><p>作为传输层协议，MQTT仅关注消息传输，提供合适的安全功能是实现者的责任。使用TLS [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC5246">RFC5246]</a> 是比较普遍的选择。除了技术上的安全问题外，还有地理因素（例如美国欧盟安全港原则 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#USEUSAFEHARB">USEUSAFEHARB]</a>），行业标准（例如第三方支付行业数据安全标准 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#PCIDSS">PCIDSS]</a>），监管方面的考虑（例如萨班斯-奥克斯利法案 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#SARBANES">SARBANES]</a>）等问题。</p><h2 id="5-2-MQTT解决方案：安全和认证">5.3 5.2 MQTT解决方案：安全和认证</h2><p>MQTT solutions: security and certification</p><p>协议实现可能想要符合特定的工业安全标准，如NIST网络安全框架 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#NISTCSF">NISTCSF]</a> ，第三方支付行业数据安全标准 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#PCIDSS">PCIDSS]</a> ，美国联邦信息处理标准 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#FIPS1402">FIPS1402]</a> 和 NSA 加密组合B [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#NSAB">NSAB</a>] 。</p><p>在MQTT的补充出版物 （MQTT and the NIST Framework for Improving Critical Infrastructure Cybersecurity [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#NISTCSF">MQTT NIST]</a>） 中可以找到在NIST网络安全框架 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#NISTCSF">NISTCSF]</a> 中使用MQTT的指导。使用行业证明、独立审计和认证技术有助于满足合规要求。</p><h2 id="5-3-轻量级的加密与受限设备">5.4 5.3 轻量级的加密与受限设备</h2><p>Lightweight cryptography and constrained devices</p><p>广泛采用高级加密标准 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#AES">AES]</a> 数据加密标准 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#DES">DES]</a> 。</p><p>推荐使用为受限的低端设备特别优化过的轻量级加密国际标准 ISO 29192 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#ISO29192">ISO29192]</a> 。</p><h2 id="5-4-实现注意事项-Implementation-notes">5.5 5.4 实现注意事项 Implementation notes</h2><p>实现和使用MQTT时需要考虑许多安全问题。下面的部分不应该被当作是一个 核对清单 。</p><p>协议实现可以实现下面的一部分或全部：</p><h3 id="5-4-1-客户端身份验证-Authentication-of-Clients-by-the-Server">5.5.1 5.4.1 客户端身份验证 Authentication of Clients by the Server</h3><p>CONNECT报文包含用户名和密码字段。实现可以决定如何使用这些字段的内容。实现者可以提供自己的身份验证机制，或者使用外部的认证系统如LDAP [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC4511">RFC4511]</a> 或OAuth [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC6749">RFC6749]</a> ，还可以利用操作系统的认证机制。</p><p>实现可以明文传递认证数据，混淆那些数据，或者不要求任何认证数据，但应该意识到这会增加中间人攻击和重放攻击的风险。5.4.5节介绍了确保数据私密的方法。</p><p>在客户端和服务端之间使用虚拟专用网（VPN）可以确保数据只被授权的客户端收到。</p><p>使用TLS [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC5246">RFC5246]</a> 时，服务端可以使用客户端发送的SSL证书验证客户端的身份。</p><p>实现可以允许客户端通过应用消息给服务端发送凭证用于身份验证。</p><h3 id="5-4-2-客户端授权-Authorization-of-Clients-by-the-Server">5.5.2 5.4.2 客户端授权 Authorization of Clients by the Server</h3><p>基于客户端提供的信息如用户名、客户端标识符（ClientId）、客户端的主机名或IP地址，或者身份认证的结果，服务端可以限制对某些服务端资源的访问。</p><h3 id="5-4-3-服务端身份验证-Authentication-of-the-Server-by-the-Client">5.5.3 5.4.3 服务端身份验证 Authentication of the Server by the Client</h3><p>MQTT协议不是双向信任的，它没有提供客户端验证服务端身份的机制。</p><p>但是使用TLS [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC5246">RFC5246]</a> 时，客户端可以使用服务端发送的SSL证书验证服务端的身份。从单IP多域名提供MQTT服务的实现应该考虑RFC6066 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC6066">RFC6066]</a> 第3节定义的TLS的SNI扩展。SNI允许客户端告诉服务端它要连接的服务端主机名。</p><p>实现可以允许服务端通过应用消息给客户端发送凭证用于身份验证。</p><p>在客户端和服务端之间使用虚拟专用网（VPN）可以确保客户端连接的是预期的服务器。</p><h3 id="5-4-4-控制报文和应用消息的完整性-Integrity-of-Application-Messages-and-Control-Packets">5.5.4 5.4.4 控制报文和应用消息的完整性 Integrity of Application Messages and Control Packets</h3><p>应用可以在应用消息中单独包含哈希值。这样做可以为PUBLISH控制报文的网络传输和静态数据提供内容的完整性检查。</p><p>TLS [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC5246">RFC5246]</a> 提供了对网络传输的数据做完整性校验的哈希算法。</p><p>在客户端和服务端之间使用虚拟专用网（VPN）连接可以在VPN覆盖的网络段提供数据完整性检查。</p><h3 id="5-4-5-控制报文和应用消息的保密性-Privacy-of-Application-Messages-and-Control-Packets">5.5.5 5.4.5 控制报文和应用消息的保密性 Privacy of Application Messages and Control Packets</h3><p>TLS [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC5246">RFC5246]</a> 可以对网络传输的数据加密。如果有效的TLS密码组合包含的加密算法为NULL，那么它不会加密数据。要确保客户端和服务端的保密，应避免使用这些密码组合。</p><p>应用可以单独加密应用消息的内容。这可以提供应用消息传输途中和静态数据的私密性。但不能给应用消息的其它属性如主题名加密。</p><p>客户端和服务端实现可以加密存储静态数据，例如可以将应用消息作为会话的一部分存储。</p><p>在客户端和服务端之间使用虚拟专用网（VPN）连接可以在VPN覆盖的网络段保证数据的私密性。</p><h3 id="5-4-6-消息传输的不可抵赖性-Non-repudiation-of-message-transmission">5.5.6 .5.4.6 消息传输的不可抵赖性 Non-repudiation of message transmission</h3><p>应用设计者可能需要考虑适当的策略，以实现端到端的不可抵赖性（non-repudiation）。</p><h3 id="5-4-7-检测客户端和服务端的盗用-Detecting-compromise-of-Clients-and-Servers">5.5.7 5.4.7 检测客户端和服务端的盗用 Detecting compromise of Clients and Servers</h3><p>使用TLS [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC5246">RFC5246]</a> 的客户端和服务端实现应该能够确保，初始化TLS [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC5246">RFC5246]</a> 连接时提供的SSL证书是与主机名（客户端要连接的或服务端将被连接的）关联的。</p><p>使用TLS [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC5246">RFC5246]</a> 的客户端和服务端实现，可以选择提供检查证书吊销列表 (CRLs [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC5280">RFC5280]</a>) 和在线证书状态协议 (OSCP) [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC6960">RFC6960]</a> 的功能，拒绝使用被吊销的证书。</p><p>物理部署可以将防篡改硬件与应用消息的特殊数据传输结合。例如，一个仪表可能会内置一个GPS以确保没有在未授权的地区使用。IEEE安全设备认证 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#IEEE8021AR">IEEE 802.1AR]</a> 就是用于实现这个机制的一个标准，它使用加密绑定标识符验证设备身份。</p><h3 id="5-4-8-检测异常行为-Detecting-abnormal-behaviors">5.5.8 5.4.8 检测异常行为 Detecting abnormal behaviors</h3><p>服务端实现可以监视客户端的行为，检测潜在的安全风险。例如：</p><ul><li>重复的连接请求</li><li>重复的身份验证请求</li><li>连接的异常终止</li><li>主题扫描（请求发送或订阅大量主题）</li><li>发送无法送达的消息（没有订阅者的主题）</li><li>客户端连接但是不发送数据</li></ul><p>发现违反安全规则的行为，服务端实现可以断开客户端连接。</p><p>服务端实现检测不受欢迎的行为，可以基于IP地址或客户端标识符实现一个动态黑名单列表。</p><p>服务部署可以使用网络层次控制（如果可用）实现基于IP地址或其它信息的速率限制或黑名单。</p><h3 id="5-4-9-其它的安全注意事项-Other-security-considerations">5.5.9 5.4.9 其它的安全注意事项 Other security considerations</h3><p>如果客户端或服务端的SSL证书丢失，或者我们考虑证书被盗用或者被吊销(利用 CRLs [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC5280">RFC5280]</a> 和 OSCP [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC6960">RFC6960]</a>)的情况。</p><p>客户端或服务端验证凭证时，如果发现用户名和密码丢失或被盗用，应该吊销或者重新发放。</p><p>在使用长连接时：</p><ul><li>客户端和服务端使用TLS [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC5246">RFC5246]</a> 时应该允许重新协商会话以确认新的加密参数（替换会话密钥，更换密码组合，更换认证凭证）。</li><li>服务端可以断开客户端连接，并要求他们使用新的凭证重新验证身份。</li></ul><p>受限网络上的受限设备和客户端可以使用TLS会话恢复 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC5077">RFC5077]</a> 降低TLS会话重连 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC5246">RFC5246]</a> 的成本。</p><p>连接到服务端的客户端与其它连接到服务端的客户端 之间有一个信任传递关系，它们都有权在同一个主题上发布消息。</p><h3 id="5-4-10-使用SOCKS代理-Use-of-SOCKS">5.5.10 5.4.10 使用SOCKS代理 Use of SOCKS</h3><p>客户端实现应该意识到某些环境要求使用SOCKSv5 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC1928">RFC1928]</a> 代理创建出站的网络连接。某些MQTT实现可以利用安全隧道（如SSH）通过SOCKS代理。一个实现决定支持SOCKS时，它们应该同时支持匿名的和用户名密码验证的SOCKS代理。对于后一种情况，实现应该意识到SOCKS可能使用明文认证，因此应该避免使用相同的凭证连接MQTT服务器。</p><h3 id="5-4-11-安全配置文件-Security-profiles">5.5.11 5.4.11 安全配置文件 Security profiles</h3><p>实现者和方案设计者可能希望将安全当作配置文件集合应用到MQTT协议中。下面描述的是一个分层的安全等级结构。</p><h4 id="开放通信配置">5.5.11.1 开放通信配置</h4><p>使用开放通信配置时，MQTT协议运行在一个没有内置额外安全通信机制的开放网络上。</p><h4 id="安全网络通信配置">5.5.11.2 安全网络通信配置</h4><p>使用安全网络通信配置时，MQTT协议运行在有安全控制的物理或虚拟网络上，如VPN或物理安全网络。</p><h4 id="安全传输配置">5.5.11.3 安全传输配置</h4><p>使用安全传输配置时，MQTT协议运行在使用TLS [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC5246">RFC5246]</a> 的物理或虚拟网络上，它提供了身份认证，完整性和保密性。</p><p>使用内置的用户名和密码字段，TLS [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#RFC5246">RFC5246]</a> 客户端身份认证可被用于（或者代替）MQTT客户端认证。</p><h4 id="工业标准的安全配置">5.5.11.4 工业标准的安全配置</h4><p>可以预料的是，MQTT被设计为支持很多工业标准的应用配置，每一种定义一个威胁模型和用于定位威胁的特殊安全机制。特殊的安全机制推荐从下面的方案中选择：</p><p>[<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#NISTCSF">NISTCSF]</a> NIST网络安全框架 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#NIST7628">NIST7628]</a> NISTIR 7628智能电网网络安全指南 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#FIPS1402">FIPS1402]</a> (FIPS PUB 140-2) 加密模块的安全要求 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#PCIDSS">PCIDSS]</a> PCI-DSS第三方支付行业数据安全标准 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html#NSAB">NSAB]</a> NSA加密组合B</p><h1 id="第六章-使用WebSocket作为网络层">6 第六章 使用WebSocket作为网络层</h1><p>如果MQTT在WebSocket [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/06-WebSocket.html#RFC6455">RFC6455]</a> 连接上传输，<strong>必须</strong>满足下面的条件：</p><ul><li>MQTT控制报文<strong>必须</strong>使用WebSocket二进制数据帧发送。如果收到任何其它类型的数据帧，接收者<strong>必须</strong>关闭网络连接 [MQTT-6.0.0-1]。</li><li>单个WebSocket数据帧可以包含多个或者部分MQTT报文。接收者<strong>不能</strong>假设MQTT控制报文按WebSocket帧边界对齐 [MQTT-6.0.0-2]。</li><li>客户端<strong>必须</strong>将字符串 <strong>mqtt</strong> 包含在它提供的WebSocket子协议列表里 [MQTT-6.0.0-3]。</li><li>服务端选择和返回的WebSocket子协议名<strong>必须</strong>是 <strong>mqtt</strong> [MQTT-6.0.0-4] 。</li><li>用于连接客户端和服务器的WebSocket URI对MQTT协议没有任何影响。</li></ul><h2 id="6-1-IANA注意事项-IANA-Considerations">6.1 6.1 IANA注意事项 IANA Considerations</h2><blockquote><p>本规范请求IANA在WebSocket子协议名条目下注册WebSocket MQTT子协议，使用下列数据：</p></blockquote><h5 id="图例-6-1-IANA-WebSocket标识符">6.1.0.0.1 图例 6.1 - IANA WebSocket标识符</h5><table><thead><tr><th>子协议标识符</th><th>mqtt</th></tr></thead><tbody><tr><td>子协议通用名</td><td>mqtt</td></tr><tr><td>子协议定义</td><td><a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/mqtt-v3.1.1.html</a></td></tr></tbody></table><h1 id="第七章-一致性-Conformance">7 第七章 一致性 Conformance</h1><h2 id="目录-1">7.1 目录</h2><ul><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/01-Introduction.html">第一章 - 介绍</a></li><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/02-ControlPacketFormat.html">第二章 – MQTT控制报文格式</a></li><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/03-ControlPackets.html">第三章 – MQTT控制报文</a></li><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/04-OperationalBehavior.html">第四章 – 操作行为</a></li><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/05-Security.html">第五章 – 安全</a></li><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/06-WebSocket.html">第六章 – 使用WebSocket</a></li><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/07-Conformance.html">第七章 – 一致性目标</a></li><li><a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/08-AppendixB.html">附录B - 强制性规范声明</a></li></ul><p>MQTT规范定义了MQTT客户端实现和MQTT服务端实现的一致性要求</p><p>MQTT实现可以同时是MQTT客户端和MQTT服务端。接受入站连接和建立到其它服务端的出站连接的服务端必须同时符合MQTT客户端和MQTT服务端的要求 [MQTT-7.0.0-1]。</p><p>为了与任何其它的一致性实现交互操作，一致性实现不能要求使用在本规范之外定义的任何扩展 [MQTT-7.0.0-2]。</p><h2 id="7-1-一致性目标-Conformance-Targets">7.2 7.1 一致性目标 Conformance Targets</h2><h3 id="7-1-1-MQTT服务端-MQTT-Server">7.2.1 7.1.1 MQTT服务端 MQTT Server</h3><p>一个MQTT服务端只有满足下面所有的要求才算是符合本规范：</p><ol><li><p>服务端发送的所有控制报文的格式必须符合第二章和第三章描述的格式</p></li><li><p>遵守第4.7节描述的主题匹配规则。</p></li><li><p>满足下列章节中所有</p><p> 必须</p><p> 级别的要求，明确仅适用于对客户端的除外：</p><ul><li>第一章 – 介绍</li><li>第二章 – MQTT控制报文格式</li><li>第三章 – MQTT控制报文</li><li>第四章 – 操作行为</li><li>第六章 –（如果MQTT的网络层是WebSocket）</li><li>第七章 – 一致性目标</li></ul></li></ol><p>满足一致性要求的服务端<strong>必须</strong>支持使用一个或多个底层传输协议，只要它提供有序的、可靠的、双向字节流（从客户端到服务端和从服务端到客户端）[MQTT-7.1.1-1]。但是一致性并不依赖于它支持任何特定的传输协议。服务端<strong>可以</strong>支持第4.2节列出的任何传输协议，或者任何其它满足 [MQTT-7.1.1-1] 要求的传输协议。</p><h3 id="7-1-2-MQTT客户端-MQTT-Client">7.2.2 7.1.2 MQTT客户端 MQTT Client</h3><p>一个MQTT客户端只有满足下面所有的要求才算是符合本规范：</p><ol><li><p>客户端发送的所有控制报文的格式必须符合第二章和第三章描述的格式</p></li><li><p>满足下列章节中所有</p><p> 必须</p><p> 级别的要求，明确仅适用于对服务端的除外：</p><ul><li>第一章 – 介绍</li><li>第二章 – MQTT控制报文格式</li><li>第三章 – MQTT控制报文</li><li>第四章 – 操作行为</li><li>第六章 – （如果MQTT的网络层是WebSocket）</li><li>第七章 – 一致性目标</li></ul></li></ol><p>满足一致性要求的客户端<strong>必须</strong>支持使用一个或多个底层传输协议，只要它提供有序的、可靠的、双向字节流（从客户端到服务端和从服务端到客户端）[MQTT-7.1.2-1]。但是一致性并不依赖于它支持任何特定的传输协议。客户端<strong>可以</strong>支持第4.2节列出的任何传输协议，或者任何其它满足 [MQTT-7.1.2-1] 要求的传输协议。</p><h1 id="附录B-强制性规范声明（非规范）">8 附录B 强制性规范声明（非规范）</h1><h3 id="表格：强制性规范声明">8.0.1 表格：强制性规范声明</h3><table><thead><tr><th><strong>声明序号</strong></th><th><strong>规范声明</strong></th></tr></thead><tbody><tr><td>[MQTT-1.5.3-1]</td><td>UTF-8编码字符串中的字符数据<strong>必须</strong>是按照Unicode规范 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/08-AppendixB.html#Unicode">Unicode</a>] 定义的和在RFC3629 [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/08-AppendixB.html#RFC3629">RFC3629</a>] 中重申的有效的UTF-8格式。特别需要指出的是，这些数据<strong>不能</strong>包含字符码在U+D800和U+DFFF之间的数据。如果服务端或客户端收到了一个包含无效UTF-8字符的控制报文，它<strong>必须</strong>关闭网络连接。</td></tr><tr><td>[MQTT-1.5.3-2]</td><td>UTF-8编码的字符串<strong>不能</strong>包含空字符U+0000。如果客户端或服务端收到了一个包含U+0000的控制报文，它<strong>必须</strong>关闭网络连接。</td></tr><tr><td>[MQTT-1.5.3-3]</td><td>UTF-8编码序列0XEF 0xBB 0xBF总是被解释为U+FEFF（零宽度非换行空白字符），无论它出现在字符串的什么位置，报文接收者都不能跳过或者剥离它。</td></tr><tr><td>[MQTT-2.2.2-1]</td><td>表格 2.2中任何标记为“保留”的标志位，都是保留给以后使用的，<strong>必须</strong>设置为表格中列出的值。</td></tr><tr><td>[MQTT-2.2.2-2]</td><td>如果收到非法的标志，接收者<strong>必须</strong>关闭网络连接。</td></tr><tr><td>[MQTT-2.3.1-1]</td><td>SUBSCRIBE，UNSUBSCRIBE和PUBLISH（QoS大于0）控制报文<strong>必须</strong>包含一个非零的16位报文标识符（Packet Identifier。</td></tr><tr><td>[MQTT-2.3.1-2]</td><td>客户端每次发送一个新的这些类型的报文时都<strong>必须</strong>分配一个当前未使用的报文标识符。</td></tr><tr><td>[MQTT-2.3.1-3]</td><td>如果一个客户端要重发这个特殊的控制报文，在随后重发那个报文时，它<strong>必须</strong>使用相同的标识符。当客户端处理完这个报文对应的确认后，这个报文标识符就释放可重用。QoS 1的PUBLISH对应的是PUBACK，QoS 2的PUBLISH对应的是PUBCOMP，与SUBSCRIBE或UNSUBSCRIBE对应的分别是SUBACK或UNSUBACK</td></tr><tr><td>[MQTT-2.3.1-4]</td><td>发送一个QoS 0的PUBLISH报文时，相同的条件也适用于服务端。</td></tr><tr><td>[MQTT-2.3.1-5]</td><td>QoS设置为0的PUBLISH报文<strong>不能</strong>包含报文标识符。</td></tr><tr><td>[MQTT-2.3.1-6]</td><td>PUBACK, PUBREC, PUBREL报文<strong>必须</strong>包含与最初发送的PUBLISH报文相同的报文标识符。</td></tr><tr><td>[MQTT-2.3.1-7]</td><td>与 [MQTT-2.3.1-6] 类似，SUBACK和UNSUBACK<strong>必须</strong>包含在对应的SUBSCRIBE和UNSUBSCRIBE报文中使用的报文标识符。</td></tr><tr><td>[MQTT-3.1.0-1]</td><td>客户端到服务端的网络连接建立后，客户端发送给服务端的第一个报文<strong>必须</strong>是CONNECT报文。</td></tr><tr><td>[MQTT-3.1.0-2]</td><td>在一个网络连接上，客户端只能发送一次CONNECT报文。服务端<strong>必须</strong>将客户端发送的第二个CONNECT报文当作协议违规处理并断开客户端的连接。</td></tr><tr><td>[MQTT-3.1.2-1]</td><td>如果协议名不正确服务端<strong>可以</strong>断开客户端的连接，也<strong>可以</strong>按照某些其它规范继续处理CONNECT报文。对于后一种情况，按照本规范，服务端<strong>不能</strong>继续处理CONNECT报文。</td></tr><tr><td>[MQTT-3.1.2-2]</td><td>如果发现不支持的协议级别，服务端<strong>必须</strong>给发送一个返回码为0x01（不支持的协议级别）的CONNACK报文响应CONNECT报文，然后断开客户端的连接。</td></tr><tr><td>[MQTT-3.1.2-3]</td><td>服务端<strong>必须</strong>验证CONNECT控制报文的保留标志位（第0位）是否为0，如果不为0必须断开客户端连接。</td></tr><tr><td>[MQTT-3.1.2-4]</td><td>如果清理会话（CleanSession）标志被设置为0，服务端<strong>必须</strong>基于当前会话（使用客户端标识符识别）的状态恢复与客户端的通信。如果没有与这个客户端标识符关联的会话，服务端<strong>必须</strong>创建一个新的会话。在连接断开之后，当连接断开后，客户端和服务端<strong>必须</strong>保存会话信息。</td></tr><tr><td>[MQTT-3.1.2-5]</td><td>当清理会话标志为0的会话连接断开之后，服务端<strong>必须</strong>将之后的QoS 1和QoS 2级别的消息保存为会话状态的一部分，如果这些消息匹配断开连接时客户端的任何订阅。</td></tr><tr><td>[MQTT-3.1.2-6]</td><td>如果清理会话（CleanSession）标志被设置为1，客户端和服务端<strong>必须</strong>丢弃之前的任何会话并开始一个新的会话。会话仅持续和网络连接同样长的时间。与这个会话关联的状态数据<strong>不能</strong>被任何之后的会话重用。</td></tr><tr><td>[MQTT-3.1.2.7]</td><td>保留消息不是服务端会话状态的一部分，会话终止时<strong>不能</strong>删除保留消息。</td></tr><tr><td>[MQTT-3.1.2-8]</td><td>遗嘱标志（Will Flag）被设置为1，表示如果连接请求被接受了，遗嘱（Will Message）消息<strong>必须</strong>被存储在服务端并且与这个网络连接关联。之后网络连接关闭时，服务端<strong>必须</strong>发布这个遗嘱消息，除非服务端收到DISCONNECT报文时删除了这个遗嘱消息。</td></tr><tr><td>[MQTT-3.1.2-9]</td><td>如果遗嘱标志被设置为1，连接标志中的Will QoS和Will Retain字段会被服务端用到，同时有效载荷中<strong>必须</strong>包含Will Topic和Will Message字段。</td></tr><tr><td>[MQTT-3.1.2-10]</td><td>一旦被发布或者服务端收到了客户端发送的DISCONNECT报文，遗嘱消息就<strong>必须</strong>从存储的会话状态中移除。</td></tr><tr><td>[MQTT-3.1.2-11]</td><td>如果遗嘱标志被设置为0，连接标志中的Will QoS和Will Retain字段<strong>必须</strong>设置为0，并且有效载荷中<strong>不能</strong>包含Will Topic和Will Message字段。</td></tr><tr><td>[MQTT-3.1.2-12]</td><td>如果遗嘱标志被设置为0，网络连接断开时，<strong>不能</strong>发送遗嘱消息。.</td></tr><tr><td>[MQTT-3.1.2-13]</td><td>如果遗嘱标志被设置为0，遗嘱QoS也<strong>必须</strong>设置为0(0x00)。</td></tr><tr><td>[MQTT-3.1.2-14]</td><td>如果遗嘱标志被设置为1，遗嘱QoS的值可以等于0(0x00)，1(0x01)，2(0x02)。它的值<strong>不能</strong>等于3。</td></tr><tr><td>[MQTT-3.1.2-15]</td><td>如果遗嘱标志被设置为0，遗嘱保留（Will Retain）标志也<strong>必须</strong>设置为0。</td></tr><tr><td>[MQTT-3.1.2-16]</td><td>如果遗嘱保留被设置为0，服务端<strong>必须</strong>将遗嘱消息当作非保留消息发布。</td></tr><tr><td>[MQTT-3.1.2-17]</td><td>如果遗嘱保留被设置为1，服务端<strong>必须</strong>将遗嘱消息当作保留消息发布。</td></tr><tr><td>[MQTT-3.1.2-18]</td><td>如果用户名（User Name）标志被设置为0，有效载荷中<strong>不能</strong>包含用户名字段。</td></tr><tr><td>[MQTT-3.1.2-19]</td><td>如果用户名（User Name）标志被设置为1，有效载荷中<strong>必须</strong>包含用户名字段。</td></tr><tr><td>[MQTT-3.1.2-20]</td><td>如果密码（Password）标志被设置为0，有效载荷中<strong>不能</strong>包含密码字段。</td></tr><tr><td>[MQTT-3.1.2-21]</td><td>如果密码（Password）标志被设置为1，有效载荷中<strong>必须</strong>包含密码字段</td></tr><tr><td>[MQTT-3.1.2-22]</td><td>如果用户名标志被设置为0，密码标志也<strong>必须</strong>设置为0。</td></tr><tr><td>[MQTT-3.1.2-23]</td><td>客户端负责保证控制报文发送的时间间隔不超过保持连接的值。如果没有任何其它的控制报文可以发送，客户端<strong>必须</strong>发送一个PINGREQ报文。</td></tr><tr><td>[MQTT-3.1.2-24]</td><td>如果保持连接的值非零，并且服务端在一点五倍的保持连接时间内没有收到客户端的控制报文，它<strong>必须</strong>断开客户端的网络连接，认为网络连接已断开。</td></tr><tr><td>[MQTT-3.1.3-1]</td><td>如果包含的话，<strong>必须</strong>按这个顺序出现：客户端标识符，遗嘱主题，遗嘱消息，用户名，密码。</td></tr><tr><td>[MQTT-3.1.3-2]</td><td>服务端使用客户端标识符 (ClientId) 识别客户端。连接服务端的每个客户端都有唯一的客户端标识符（ClientId）。客户端和服务端都必须使用ClientId识别两者之间的MQTT会话相关的状态。</td></tr><tr><td>[MQTT-3.1.3-3]</td><td>客户端标识符 (ClientId) <strong>必须</strong>存在而且<strong>必须</strong>是CONNECT报文有效载荷的第一个字段。</td></tr><tr><td>[MQTT-3.1.3-4]</td><td>客户端标识符<strong>必须</strong>是1.5.3节定义的UTF-8编码字符串。</td></tr><tr><td>[MQTT-3.1.3-5]</td><td>服务端<strong>必须</strong>允许1到23个字节长的UTF-8编码的客户端标识符，客户端标识符只能包含这些字符：“0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”（大写字母，小写字母和数字）。</td></tr><tr><td>[MQTT-3.1.3-6]</td><td>服务端<strong>可以</strong>允许客户端提供一个零字节的客户端标识符 (ClientId) ，如果这样做了，服务端<strong>必须</strong>将这看作特殊情况并分配唯一的客户端标识符给那个客户端。然后它<strong>必须</strong>假设客户端提供了那个唯一的客户端标识符，正常处理这个CONNECT报文。</td></tr><tr><td>[MQTT-3.1.3-7]</td><td>如果客户端提供了一个零字节的客户端标识符，它<strong>必须</strong>同时将清理会话标志设置为1。</td></tr><tr><td>[MQTT-3.1.3-8]</td><td>如果客户端提供的ClientId为零字节且清理会话标志为0，服务端<strong>必须</strong>发送返回码为0x02（表示标识符不合格）的CONNACK报文响应客户端的CONNECT报文，然后关闭网络连接。</td></tr><tr><td>[MQTT-3.1.3-9]</td><td>如果服务端拒绝了这个ClientId，它<strong>必须</strong>发送返回码为0x02（表示标识符不合格）的CONNACK报文响应客户端的CONNECT报文，然后关闭网络连接。</td></tr><tr><td>[MQTT-3.1.3-10]</td><td>遗嘱主题<strong>必须</strong>是 1.5.3节定义的UTF-8编码字符串。</td></tr><tr><td>[MQTT-3.1.3-11]</td><td>用户名<strong>必须</strong>是 1.5.3节定义的UTF-8编码字符串。</td></tr><tr><td>[MQTT-3.1.4-1]</td><td>服务端<strong>必须</strong>按照3.1节的要求验证CONNECT报文，如果报文不符合规范，服务端不发送CONNACK报文直接关闭网络连接。</td></tr><tr><td>[MQTT-3.1.4-2]</td><td>如果ClientId表明客户端已经连接到这个服务端，那么服务端<strong>必须</strong>断开原有的客户端连接。</td></tr><tr><td>[MQTT-3.1.4-3]</td><td>服务端<strong>必须</strong>按照 3.1.2.4节的描述执行清理会话的过程。</td></tr><tr><td>[MQTT-3.1.4-4]</td><td>服务端<strong>必须</strong>发送返回码为零的CONNACK报文作为CONNECT报文的确认响应。</td></tr><tr><td>[MQTT-3.1.4-5]</td><td>如果服务端拒绝了CONNECT，它<strong>不能</strong>处理客户端在CONNECT报文之后发送的任何数据。</td></tr><tr><td>[MQTT-3.2.0-1]</td><td>服务端发送CONNACK报文响应从客户端收到的CONNECT报文。服务端发送给客户端的第一个报文<strong>必须</strong>是CONNACK。</td></tr><tr><td>[MQTT-3.2.2-1]</td><td>如果服务端收到清理会话（CleanSession）标志为1的连接，除了将CONNACK报文中的返回码设置为0之外，还<strong>必须</strong>将CONNACK报文中的当前会话设置（Session Present）标志为0。</td></tr><tr><td>[MQTT-3.2.2-2]</td><td>如果服务端收到一个CleanSession为0的连接，当前会话标志的值取决于服务端是否已经保存了ClientId对应客户端的会话状态。如果服务端已经保存了会话状态，它<strong>必须</strong>将CONNACK报文中的当前会话标志设置为1。</td></tr><tr><td>[MQTT-3.2.2-3]</td><td>如果服务端没有已保存的会话状态，它<strong>必须</strong>将CONNACK报文中的当前会话设置为0。还需要将CONNACK报文中的返回码设置为0。</td></tr><tr><td>[MQTT-3.2.2-4]</td><td>如果服务端发送了一个包含非零返回码的CONNACK报文，它<strong>必须</strong>将当前会话标志设置为0。</td></tr><tr><td>[MQTT-3.2.2-5]</td><td>如果服务端发送了一个包含非零返回码的CONNACK报文，那么它<strong>必须</strong>关闭网络连接。.</td></tr><tr><td>[MQTT-3.2.2-6]</td><td>如果认为上表格3.1中的所有连接返回码都不太合适，那么服务端<strong>必须</strong>关闭网络连接，不需要发送CONNACK报文。</td></tr><tr><td>[MQTT-3.3.1-1]</td><td>客户端或服务端请求重发一个PUBLISH报文时，<strong>必须</strong>将DUP标志设置为1。</td></tr><tr><td>[MQTT-3.3.1-2]</td><td>对于QoS 0的消息，DUP标志<strong>必须</strong>设置为0</td></tr><tr><td>[MQTT-3.3.1-3]</td><td>服务端发送PUBLISH报文给订阅者时，收到（入站）的PUBLISH报文的DUP标志的值不会被传播。发送（出站）的PUBLISH报文与收到（入站）的PUBLISH报文中的DUP标志是独立设置的，它的值<strong>必须</strong>单独的根据发送（出站）的PUBLISH报文是否是一个重发来确定。</td></tr><tr><td>[MQTT-3.3.1-4]</td><td>PUBLISH报文<strong>不能</strong>将QoS所有的位设置为1。如果服务端或客户端收到QoS所有位都为1的PUBLISH报文，它<strong>必须</strong>关闭网络连接。</td></tr><tr><td>[MQTT-3.3.1-5]</td><td>如果客户端发给服务端的PUBLISH报文的保留（RETAIN）标志被设置为1，服务端<strong>必须</strong>存储这个应用消息和它的服务质量等级（QoS），以便它可以被分发给未来的主题名匹配的订阅者。</td></tr><tr><td>[MQTT-3.3.1-6]</td><td>一个新的订阅建立时，对每个匹配的主题名，如果存在最近保留的消息，它<strong>必须</strong>被发送给这个订阅者。</td></tr><tr><td>[MQTT-3.3.1-7]</td><td>如果服务端收到一条保留（RETAIN）标志为1的QoS 0消息，它<strong>必须</strong>丢弃之前为那个主题保留的任何消息。它<strong>应该</strong>将这个新的QoS 0消息当作那个主题的新保留消息，但是任何时候都<strong>可以</strong>选择丢弃它 — 如果这种情况发生了，那个主题将没有保留消息。</td></tr><tr><td>[MQTT-3.3.1-8]</td><td>服务端发送PUBLISH报文给客户端时，如果消息是作为客户端一个新订阅的结果发送，它<strong>必须</strong>将报文的保留标志设为1。</td></tr><tr><td>[MQTT-3.3.1-9]</td><td>当一个PUBLISH报文发送给客户端是因为匹配一个已建立的订阅时，服务端<strong>必须</strong>将保留标志设为0，不管它收到的这个消息中保留标志的值是多少。</td></tr><tr><td>[MQTT-3.3.1-10]</td><td>保留标志为1且有效载荷为零字节的PUBLISH报文会被服务端当作正常消息处理，它会被发送给订阅主题匹配的客户端。此外，同一个主题下任何现存的保留消息必须被移除，因此这个主题之后的任何订阅者都不会收到一个保留消息。</td></tr><tr><td>[MQTT-3.3.1-11]</td><td>服务端<strong>不能</strong>存储零字节的保留消息。</td></tr><tr><td>[MQTT-3.3.1-12]</td><td>如果客户端发给服务端的PUBLISH报文的保留标志位0，服务端<strong>不能</strong>存储这个消息也<strong>不能</strong>移除或替换任何现存的保留消息。</td></tr><tr><td>[MQTT-3.3.2-1]</td><td>主题名<strong>必须</strong>是PUBLISH报文可变报头的第一个字段。它<strong>必须</strong>是 1.5.3节定义的UTF-8编码的字符串。</td></tr><tr><td>[MQTT-3.3.2-2]</td><td>PUBLISH报文中的主题名<strong>不能</strong>包含通配符。</td></tr><tr><td>[MQTT-3.3.2-3]</td><td>服务端发送给订阅客户端的PUBLISH报文的主题名<strong>必须</strong>匹配该订阅的主题过滤器（根据 4.7节定义的匹配过程）。</td></tr><tr><td>[MQTT-3.3.4-1]</td><td>PUBLISH报文的接收者<strong>必须</strong>按照根据PUBLISH报文中的QoS等级发送响应，见表格3.4的描述。</td></tr><tr><td>[MQTT-3.3.5-1]</td><td>服务端<strong>必须</strong>将消息分发给所有订阅匹配的QoS等级最高的客户端。</td></tr><tr><td>[MQTT-3.3.5-2]</td><td>如果服务端实现不授权某个客户端发布PUBLISH报文，它没有办法通知那个客户端。它<strong>必须</strong>按照正常的QoS规则发送一个正面的确认，或者关闭网络连接。</td></tr><tr><td>[MQTT-3.6.1-1]</td><td>PUBREL控制报文固定报头的第3,2,1,0位是保留位，<strong>必须</strong>被设置为0,0,1,0。服务端<strong>必须</strong>将其它的任何值都当做是不合法的并关闭网络连接。</td></tr><tr><td>[MQTT-3.8.1-1]</td><td>SUBSCRIBE控制报固定报头的第3,2,1,0位是保留位，<strong>必须</strong>分别设置为0,0,1,0。服务端<strong>必须</strong>将其它的任何值都当做是不合法的并关闭网络连接。</td></tr><tr><td>[MQTT-3.8.3-1]</td><td>SUBSCRIBE报文有效载荷中的主题过滤器列表<strong>必须</strong>是1.5.3节定义的UTF-8字符串。</td></tr><tr><td>[MQTT-3.8.3-2]</td><td>如果服务端选择不支持包含通配符的主题过滤器，<strong>必须</strong>拒绝任何包含通配符过滤器的订阅请求。</td></tr><tr><td>[MQTT-3.8.3-3]</td><td>SUBSCRIBE报文的有效载荷<strong>必须</strong>包含至少一对主题过滤器 和 QoS等级字段组合。没有有效载荷的SUBSCRIBE报文是违反协议的。</td></tr><tr><td>[MQTT-3-8.3-4]</td><td>如果有效载荷中的任何位是非零值，或者QoS不等于0,1或2，服务端<strong>必须</strong>认为SUBSCRIBE报文是不合法的并关闭网络连接。</td></tr><tr><td>[MQTT-3.8.4-1]</td><td>服务端收到客户端发送的一个SUBSCRIBE报文时，<strong>必须</strong>使用SUBACK报文响应。</td></tr><tr><td>[MQTT-3.8.4-2]</td><td>SUBACK报文<strong>必须</strong>和等待确认的SUBSCRIBE报文有相同的报文标识符。</td></tr><tr><td>[MQTT-3.8.4-3]</td><td>如果服务端收到一个SUBSCRIBE报文，报文的主题过滤器与一个现存订阅的主题过滤器相同，那么<strong>必须</strong>使用新的订阅彻底替换现存的订阅。新订阅的主题过滤器和之前订阅的相同，但是它的最大QoS值可以不同。与这个主题过滤器匹配的任何现存的保留消息<strong>必须</strong>被重发，但是发布流程<strong>不能</strong>中断。</td></tr><tr><td>[MQTT-3.8.4-4]</td><td>如果服务端收到包含多个主题过滤器的SUBSCRIBE报文，它<strong>必须</strong>如同收到了一系列的多个SUBSCRIBE报文一样处理那个，除了需要将它们的响应合并到一个单独的SUBACK报文发送。</td></tr><tr><td>[MQTT-3.8.4-5]</td><td>服务端发送给客户端的SUBACK报文对每一对主题过滤器 和QoS等级都<strong>必须</strong>包含一个返回码。这个返回码<strong>必须</strong>表示那个订阅被授予的最大QoS等级，或者表示这个订阅失败。</td></tr><tr><td>[MQTT-3.8.4-6]</td><td>服务端可以授予比订阅者要求的低一些的QoS等级。为响应订阅而发出的消息的有效载荷的QoS<strong>必须</strong>是原始发布消息的QoS和服务端授予的QoS两者中的最小值。如果原始消息的QoS是1而被授予的最大QoS是0，允许服务端重复发送一个消息的副本给订阅者。</td></tr><tr><td>[MQTT-3.9.3-1]</td><td>返回码的顺序<strong>必须</strong>和SUBSCRIBE报文中主题过滤器的顺序相同。</td></tr><tr><td>[MQTT-3.9.3-2]</td><td>0x00, 0x01, 0x02, 0x80之外的SUBACK返回码是保留的，<strong>不能</strong>使用。</td></tr><tr><td>[MQTT-3.10.1-1]</td><td>UNSUBSCRIBE报文固定报头的第3,2,1,0位是保留位且<strong>必须</strong>分别设置为0,0,1,0。服务端<strong>必须</strong>认为任何其它的值都是不合法的并关闭网络连接。</td></tr><tr><td>[MQTT-3.10.3-1]</td><td>UNSUBSCRIBE报文中的主题过滤器<strong>必须</strong>是连续打包的、按照1.5.3节定义的UTF-8编码字符串。</td></tr><tr><td>[MQTT-3.10.3-2]</td><td>UNSUBSCRIBE报文的有效载荷<strong>必须</strong>至少包含一个消息过滤器。没有有效载荷的UNSUBSCRIBE报文是违反协议的。</td></tr><tr><td>[MQTT-3.10.4-1]</td><td>UNSUBSCRIBE报文提供的主题过滤器（无论是否包含通配符）<strong>必须</strong>与服务端持有的这个客户端的当前主题过滤器集合逐个字符比较。如果有任何过滤器完全匹配，那么它（服务端）自己的订阅将被删除，否则不会有进一步的处理。</td></tr><tr><td>[MQTT-3.10.4-2]</td><td>如果服务端删除了一个订阅，它<strong>必须</strong>停止分发任何新消息给这个客户端。</td></tr><tr><td>[MQTT-3.10.4-3]</td><td>如果服务端删除了一个订阅，它<strong>必须</strong>完成分发任何已经开始往客户端发送的QoS 1和QoS 2的消息。</td></tr><tr><td>[MQTT-3.10.4-4]</td><td>服务端<strong>必须</strong>发送UNSUBACK报文响应客户端的UNSUBSCRIBE请求。UNSUBACK报文<strong>必须</strong>包含和UNSUBSCRIBE报文相同的报文标识符。</td></tr><tr><td>[MQTT-3.10.4-5]</td><td>即使没有删除任何主题订阅，服务端也<strong>必须</strong>发送一个SUBACK响应。</td></tr><tr><td>[MQTT-3.10.4-6]</td><td>如果服务端收到包含多个主题过滤器的UNSUBSCRIBE报文，它<strong>必须</strong>如同收到了一系列的多个UNSUBSCRIBE报文一样处理那个报文，除了将它们的响应合并到一个单独的UNSUBACK报文外。</td></tr><tr><td>[MQTT-3.12.4-1]</td><td>服务端<strong>必须</strong>发送 PINGRESP报文响应客户端的PINGREQ报文。</td></tr><tr><td>[MQTT-3.14.1-1]</td><td>服务端<strong>必须</strong>验证所有的保留位都被设置为0，如果它们不为0<strong>必须</strong>断开连接。</td></tr><tr><td>[MQTT-3.14.4-1]</td><td>客户端发送DISCONNECT报文之后，<strong>必须</strong>关闭网络连接。</td></tr><tr><td>[MQTT-3.14.4-2]</td><td>客户端发送DISCONNECT报文之后，<strong>不能</strong>通过那个网络连接再发送任何控制报文。</td></tr><tr><td>[MQTT-3.14.4-3]</td><td>服务端收到DISCONNECT报文时，<strong>必须</strong>丢弃任何与当前连接关联的未发布的遗嘱消息，具体描述见 3.1.2.5节。</td></tr><tr><td>[MQTT-4.1.0-1]</td><td>在整个会话期间，客户端和服务端都<strong>必须</strong>存储会话状态。</td></tr><tr><td>[MQTT-4.1.0-2]</td><td>会话<strong>必须</strong>至少持续和它的活跃网络连接同样长的时间。</td></tr><tr><td>[MQTT-4.3.1-1]</td><td>对于QoS 0的分发协议，发送者<strong>必须</strong>发送QoS等于0，DUP等于0的PUBLISH报文。</td></tr><tr><td>[MQTT-4.4.0-1]</td><td>客户端设置清理会话（CleanSession）标志为0重连时，客户端和服务端<strong>必须</strong>使用原始的报文标识符重发任何未确认的PUBLISH报文（如果QoS&gt;0）和PUBREL报文。</td></tr><tr><td>[MQTT-4.5.0-1]</td><td>服务端接管入站应用消息的所有权时，它<strong>必须</strong>将消息添加到订阅匹配的客户端的会话状态中。匹配规则定义见 4.7节。</td></tr><tr><td>[MQTT-4.5.0-2]</td><td>客户端<strong>必须</strong>按照可用的服务质量（QoS）规则确认它收到的任何PUBLISH报文，不管它选择是否处理报文包含的应用消息。</td></tr><tr><td>[MQTT-4.6.0-1]</td><td>重发任何之前的PUBLISH报文时，<strong>必须</strong>按原始PUBLISH报文的发送顺序重发（适用于QoS 1和QoS 2消息）。</td></tr><tr><td>[MQTT-4.6.0-2]</td><td><strong>必须</strong>按照对应的PUBLISH报文的顺序发送PUBACK报文（QoS 1消息）。</td></tr><tr><td>[MQTT-4.6.0-3]</td><td><strong>必须</strong>按照对应的PUBLISH报文的顺序发送PUBREC报文（QoS 2消息）。</td></tr><tr><td>[MQTT-4.6.0-4]</td><td><strong>必须</strong>按照对应的PUBREC报文的顺序发送PUBREL报文（QoS 2消息）。</td></tr><tr><td>[MQTT-4.6.0-5]</td><td>服务端<strong>必须</strong>默认认为每个主题都是有序的。它<strong>可以</strong>提供一个管理功能或其它机制，以允许将一个或多个主题当作是<strong>无序的</strong>。</td></tr><tr><td>[MQTT-4.6.0-6]</td><td>服务端处理发送给有序主题的消息时，<strong>必须</strong>按照上面的规则将消息分发给每个订阅者。此外，它<strong>必须</strong>按照从客户端收到的顺序发送PUBLISH报文给消费者（对相同的主题和QoS）。</td></tr><tr><td>[MQTT-4.7.1-1]</td><td>主题过滤器中可以使用通配符，但是主题名<strong>不能</strong>使用通配符。</td></tr><tr><td>[MQTT-4.7.1-2]</td><td>多层通配符必须位于它自己的层级或者跟在主题层级分隔符后面。不管哪种情况，它都<strong>必须</strong>是主题过滤器的最后一个字符。</td></tr><tr><td>[MQTT-4.7.1-3]</td><td>在主题过滤器的任意层级都可以使用单层通配符，包括第一个和最后一个层级。然而它<strong>必须</strong>占据过滤器的整个层级。</td></tr><tr><td>[MQTT-4.7.2-1]</td><td>服务端<strong>不能</strong>将 $ 字符开头的主题名匹配通配符 (#或+) 开头的主题过滤器。</td></tr><tr><td>[MQTT-4.7.3-1]</td><td>所有的主题名和主题过滤器<strong>必须</strong>至少包含一个字符。</td></tr><tr><td>[MQTT-4.7.3-2]</td><td>主题名和主题过滤器<strong>不能</strong>包含空字符 (Unicode U+0000) [<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/mqtt/08-AppendixB.html#Unicode">Unicode</a>] 。</td></tr><tr><td>[MQTT-4.7.3-3]</td><td>主题名和主题过滤器是UTF-8编码字符串，它们<strong>不能</strong>超过65535字节。</td></tr><tr><td>[MQTT-4.7.3-4]</td><td>匹配订阅时，服务端<strong>不能</strong>对主题名或主题过滤器执行任何规范化（normalization）处理，不能修改或替换任何未识别的字符。</td></tr><tr><td>[MQTT-4.8.0-1]</td><td>除非另有说明，如果服务端或客户端遇到了协议违规的行为，它<strong>必须</strong>关闭传输这个协议违规控制报文的网络连接。</td></tr><tr><td>[MQTT-4.8.0-2]</td><td>如果客户端或服务端处理入站控制报文时遇到了瞬时错误，它<strong>必须</strong>关闭传输那个控制报文的网络连接。</td></tr><tr><td>[MQTT-6.0.0-1]</td><td>MQTT控制报文<strong>必须</strong>使用WebSocket二进制数据帧发送。如果收到任何其它类型的数据帧，接收者<strong>必须</strong>关闭网络连接。</td></tr><tr><td>[MQTT-6.0.0-2]</td><td>单个WebSocket数据帧可以包含多个或者部分MQTT报文。接收者<strong>不能</strong>假设MQTT控制报文按WebSocket帧边界对齐。</td></tr><tr><td>[MQTT-6.0.0-3]</td><td>客户端<strong>必须</strong>将字符串 <strong>mqtt</strong> 包含在它提供的WebSocket子协议列表里。</td></tr><tr><td>[MQTT-6.0.0-4]</td><td>服务端选择和返回的WebSocket子协议名<strong>必须</strong>是 <strong>mqtt</strong></td></tr><tr><td>[MQTT-7.0.0-1]</td><td>MQTT实现可以同时是MQTT客户端和MQTT服务端。接受入站连接和建立到其它服务端的出站连接的服务端必须同时符合MQTT客户端和MQTT服务端的要求。</td></tr><tr><td>[MQTT-7.0.0-2]</td><td>为了与任何其它的一致性实现交互操作，一致性实现不能要求使用在本规范之外定义的任何扩展。</td></tr><tr><td>[MQTT-7.1.1-1]</td><td>满足一致性要求的服务端<strong>必须</strong>支持使用一个或多个底层传输协议，只要它提供有序的、可靠的、双向字节流（从客户端到服务端和从服务端到客户端）</td></tr><tr><td>[MQTT-7.1.2-1]</td><td>满足一致性要求的客户端<strong>必须</strong>支持使用一个或多个底层传输协议，只要它提供有序的、可靠的、双向字节流（从客户端到服务端和从服务端到客户端）</td></tr></tbody></table><h3 id="关于QoS的补充说明">8.0.2 关于QoS的补充说明</h3><h4 id="MQTT-4-3-2-1-对于QoS-1的分发协议，发送者">8.0.2.1 [MQTT-4.3.2-1] 对于QoS 1的分发协议，发送者</h4><ul><li>每次发送新的应用消息都<strong>必须</strong>分配一个未使用的报文标识符。</li><li>MUST send a PUBLISH Packet containing this Packet Identifier with QoS=1, DUP=0.</li><li>发送的PUBLISH报文<strong>必须</strong>包含报文标识符且QoS等于1，DUP等于0。</li><li><strong>必须</strong>将这个PUBLISH报文看作是 <em>未确认的</em> ，直到从接收者那收到对应的PUBACK报文。4.4节有一个关于未确认消息的讨论。</li></ul><h4 id="MQTT-4-3-2-2-对于QoS-1的分发协议，接收者">8.0.2.2 [MQTT-4.3.2-2] 对于QoS 1的分发协议，接收者</h4><ul><li>响应的PUBACK报文<strong>必须</strong>包含一个报文标识符，这个标识符来自接收到的、已经接受所有权的PUBLISH报文。</li><li>发送了PUBACK报文之后，接收者必须将任何包含相同报文标识符的入站PUBLISH报文当作一个新的消息，并忽略它的DUP标志的值。</li></ul><h4 id="MQTT-4-3-3-1-对于QoS-2的分发协议，发送者">8.0.2.3 [MQTT-4.3.3-1] 对于QoS 2的分发协议，发送者</h4><ul><li><p>必须给要发送的新应用消息分配一个未使用的报文标识符。</p><ul><li>MUST send a PUBLISH packet containing this Packet Identifier with QoS=2, DUP=0.</li></ul></li><li><p>发送的PUBLISH报文</p><p>  必须</p><p>  包含报文标识符且报文的QoS等于2,，DUP等于0。</p><ul><li><strong>必须</strong>将这个PUBLISH报文看作是 <em>未确认的</em> ，直到从接收者那收到对应的PUBREC报文。4.4节有一个关于未确认消息的讨论。</li><li>收到PUBREC报文后<strong>必须</strong>发送一个PUBREL报文。PUBREL报文必须包含与原始PUBLISH报文相同的报文标识符。</li><li><strong>必须</strong>将这个PUBREL报文看作是 <em>未确认的</em> ，直到从接收者那收到对应的PUBCOMP报文。</li><li>一旦发送了对应的PUBREL报文就<strong>不能</strong>重发这个PUBLISH报文。</li></ul></li></ul><h4 id="MQTT-4-3-3-2-对于QoS-2的分发协议，接收者">8.0.2.4 [MQTT-4.3.3-2] 对于QoS 2的分发协议，接收者</h4><ul><li><p>响应的PUBREC报文<strong>必须</strong>包含报文标识符，这个标识符来自接收到的、已经接受所有权的PUBLISH报文。</p></li><li><p>在收到对应的PUBREL报文之前，接收者<strong>必须</strong>发送PUBREC报文确认任何后续的具有相同标识符的PUBLISH报文。 在这种情况下，它<strong>不能</strong>重复分发消息给任何后续的接收者。</p></li><li><p>响应PUBREL报文的PUBCOMP报文</p><p>  必须</p><p>  包含与PUBREL报文相同的标识符。</p><ul><li>发送PUBCOMP报文之后，接收者必须将包含相同报文标识符的任何后续PUBLISH报文当作一个新的发布。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> ESP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb组件分析</title>
      <link href="posts/10f4aa60.html"/>
      <url>posts/10f4aa60.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、GDB-RSP-GDB-Remote-Serial-Protocol">1 1、GDB RSP(GDB Remote Serial Protocol)</h1><ul><li><p>信息格式：$数据#校验码</p></li><li><p>多数信息使用ASCII码，数据由一系列的ASCII码组成，校验码是由两个16进制数组成的单字节校验码</p></li><li><p>接收方接收数据并校验，若正确则回应“＋”，否则回应“－”</p></li></ul><h2 id="1-1、请求">1.1 1.1、请求</h2><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">？</td><td align="left">读当前系统状态</td></tr><tr><td align="center">g</td><td align="left">读所有寄存器</td></tr><tr><td align="center">G</td><td align="left">写所有寄存器</td></tr><tr><td align="center">m</td><td align="left">读内存</td></tr><tr><td align="center">M</td><td align="left">写内存</td></tr><tr><td align="center">c</td><td align="left">继续执行</td></tr><tr><td align="center">s</td><td align="left">单步执行</td></tr><tr><td align="center">k</td><td align="left">终止进程</td></tr></tbody></table><h2 id="1-2、答复">1.2 1.2、答复</h2><table><thead><tr><th align="center">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">“”</td><td align="left">告诉GDB上次请求命令不支持</td></tr><tr><td align="center">E</td><td align="left">告诉GDB出错</td></tr><tr><td align="center">OK</td><td align="left">上次请求正确</td></tr><tr><td align="center">W</td><td align="left">系统在exit_status状态下退出</td></tr><tr><td align="center">X</td><td align="left">系统在signal信号下终止</td></tr><tr><td align="center">S</td><td align="left">系统在signal信号下停止</td></tr><tr><td align="center">O</td><td align="left">告诉GDB控制台输出（这也是唯一向GDB发出的命令）</td></tr></tbody></table><h1 id="2、目标机上stub的实现">2 2、目标机上stub的实现</h1><p>目标机上stub的基本功能是与主机GDB通信，实现读写内存、寄存器，stop、continue指令。主机GDB与目标机上stub通信的通用模型如图</p><p><img "" class="lazyload placeholder" data-original="/posts/10f4aa60/GDB%E4%B8%8E%E7%9B%AE%E6%A0%87%E6%9C%BA%E4%B8%8Astub%E9%80%9A%E4%BF%A1%E7%9A%84%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9E%8B.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="GDB与目标机上stub通信的通用模型.png"></p><p><img "" class="lazyload placeholder" data-original="/posts/10f4aa60/jtag-debugging-overview_zh.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="jtag-debugging-overview_zh.jpg"></p><h1 id="3、GDB-stub">3 3、GDB stub</h1><ul><li><a href="https://github.com/projectgus/openocd">OpenOCD support</a>：需要单独的jtag</li><li>barebones GDB stub ：仅支持异常捕获，同时要想在smart.js平台之外使用它，需要其他的工作，并且不支持FreeRTOS</li><li><a href="https://github.com/espressif/esp-gdbstub">esp GDB stub</a>：支持裸机和FreeRTOS </li></ul>]]></content>
      
      
      <categories>
          
          <category> ESP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git大全</title>
      <link href="posts/a93bf28c.html"/>
      <url>posts/a93bf28c.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git-GUI-客户端">1 Git GUI 客户端</h1><p><a href="https://www.oschina.net/p/git">Git 客户端下载（Windows）</a></p><p><a href="https://www.oschina.net/p/tortoisegit">TortoiseGit 客户端下载（Windows）</a></p><p><a href="https://www.oschina.net/p/sourcetree">Sourcetree 客户端下载（Windows、Mac）</a></p><p><a href="https://www.oschina.net/p/git-extensions">Git Extensions 客户端下载（Windows、Mac、Linux）</a></p><p><a href="https://www.oschina.net/p/smartgit">SmartGit 客户端下载（Windows、Mac、Linux）</a></p><p><a href="https://www.oschina.net/p/giteye">GitEye 客户端下载 （Windows、Mac、Linux）</a></p><p><a href="https://www.oschina.net/p/gitg">gitg 客户端下载（Windows、Linux）</a></p><p><a href="https://www.oschina.net/p/ungit">ungit 客户端下载（Windows、Mac、Linux）</a></p><p><a href="https://www.oschina.net/p/git-cola">git-cola 客户端下载（Windows、Mac、Linux）</a></p><p><a href="https://www.oschina.net/p/tower">Tower 客户端下载（Windows、Mac）</a></p><p><a href="https://www.oschina.net/p/gitbox">Gitbox 客户端下载（Mac）</a></p><p><a href="https://www.oschina.net/p/gitup">GitUp 客户端下载（Mac）</a></p><p><a href="https://www.oschina.net/p/giggle">giggle 客户端下载（Linux）</a></p><p><a href="https://www.oschina.net/p/pocket-git">Pocket Git 客户端下载（Andorid）</a></p><p><a href="https://workingcopyapp.com/">Working Copy 客户端下载（IOS）</a></p><p><a href="https://git2go.com/">Git2Go 客户端下载（IOS）</a></p><p><a href="http://gitdrive.com/">GitDrive 客户端下载（IOS）</a></p><p><a href="https://git-fork.com/">Fork 客户端（Windows、Mac）</a></p><p><a href="https://www.gitkraken.com/">GitKraken 客户端（Windows、Mac、Linux）</a></p><h1 id="Git-IDE-插件">2 Git IDE 插件</h1><p><a href="https://gitee.com/oschina/eclipse-oscgit">Eclipse、Myeclipse 插件下载</a></p><p><a href="https://www.oschina.net/p/nbgit">Netbeans 插件下载</a></p><p><a href="https://www.oschina.net/p/intellij-gitosc">IntelliJ IDEA 插件下载</a></p><p><a href="https://www.oschina.net/p/codecloud-visualstudio">Visual Studio 插件下载</a></p><p><a href="https://gitee.com/GitGroup/atom-gitosc">Atom 插件下载</a></p><p><a href="https://www.oschina.net/p/gitsavvy">Sublime Text 插件下载</a></p><h1 id="Git-浏览器插件">3 Git 浏览器插件</h1><p><a href="https://gitee.com/oschina/GitCodeTree">Git 浏览器插件下载（Chrome、Firefox、Safari、Opera，支持码云和Github）</a></p><p><a href="https://www.oschina.net/p/octotree">Octotree 浏览器插件下载（Chrome，支持Github）</a></p><p><a href="https://www.oschina.net/p/gitlab-treeview">GitLab-TreeView 浏览器插件下载（Chrome，支持GitLab）</a></p><h1 id="在线-Git-代码托管平台">4 在线 Git 代码托管平台</h1><p><a href="https://gitee.com/">码云 Gitee 官网</a></p><p><a href="https://github.com/">GitHub 官网</a></p><p><a href="https://about.gitlab.com/">GitLab 官网</a></p><p><a href="https://bitbucket.org/">Bitbucket 官网</a></p><h1 id="搭建-Git-服务">5 搭建 Git 服务</h1><p><a href="https://www.oschina.net/p/gitlab">GitLab 开源版本下载</a></p><p><a href="https://www.oschina.net/p/gitblit">Gitblit 开源版本下载</a></p><p><a href="https://www.oschina.net/p/gogs">Gogs 开源版本下载</a></p><p><a href="https://www.oschina.net/p/gitea">Gitea 开源版本下载</a></p><p><a href="https://www.oschina.net/p/gitosis">Gitosis 开源版本下载</a></p><p><a href="https://www.oschina.net/p/gitolite">Gitolite 开源版本下载</a></p><p><a href="https://www.oschina.net/p/gitstack">GitStack 开源版本下载</a></p><p><a href="https://www.oschina.net/p/gidder">Gidder开源版本下载</a></p><h1 id="Git-教程">6 Git 教程</h1><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰 | Git教程</a></p><p><a href="https://git-scm.com/book/zh/v2">Git - Book</a></p><p><a href="https://gitee.com/progit/">Pro Git</a></p><p><a href="http://www.bootcss.com/p/git-guide/">Git 简易指南</a></p><p><a href="http://www.runoob.com/git/git-tutorial.html">菜鸟教程 | Git教程</a></p><p><a href="https://www.cnblogs.com/syp172654682/p/7689328.html">博客园 | 深入浅出Git教程</a></p><p><a href="https://www.w3cschool.cn/git/">W3Cschool | Git教程</a></p><p><a href="https://www.yiibai.com/git/">易百教程 | Git教程</a></p><p><a href="https://backlog.com/git-tutorial/cn/intro/intro1_1.html">Backlog | Git入门</a></p><p><a href="https://blog.csdn.net/Free_Wind22/article/details/50967723">CSDN | Git 使用详细教程</a></p><p><a href="https://lufficc.com/blog/the-core-conception-of-git#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F">Lufficc | Git教程</a></p><h1 id="Git-常用命令">7 Git 常用命令</h1><h3 id="仓库">7.0.1 仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载一个项目和它的整个代码历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [url]</span></span><br></pre></td></tr></table></figure><h3 id="配置">7.0.2 配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示当前的Git配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --list</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑Git配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config -e [--global]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置提交代码时的用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.email <span class="string">&quot;[email address]&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="增加-删除文件">7.0.3 增加/删除文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [dir]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -p</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure><h3 id="代码提交">7.0.4 代码提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit [file1] [file2] ... -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure><h3 id="分支">7.0.5 分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到上一个分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择一个commit，合并进当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure><h3 id="标签">7.0.6 标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在当前commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag] [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/[tagName]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看tag信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交指定tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向某个tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [tag]</span></span><br></pre></td></tr></table></figure><h3 id="查看信息">7.0.7 查看信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示有变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的版本历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索提交历史，根据关键词</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，其<span class="string">&quot;提交说明&quot;</span>必须符合搜索条件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件相关的每一次diff</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示过去5次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和工作区的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和上一个commit的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示两次提交之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示今天你写了多少行代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交的元数据和内容变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交发生变化的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交时，某个文件的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的最近几次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><h3 id="远程同步">7.0.8 远程同步</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载远程仓库的所有变动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch [remote]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个远程仓库的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加一个新的远程仓库，并命名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add [shortname] [url]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull [remote] [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --force</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送所有分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --all</span> </span><br></pre></td></tr></table></figure><h3 id="撤销">7.0.9 撤销</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的指定文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的所有文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></span><br><span class="line"></span><br><span class="line">暂时将未提交的变化移除，稍后再移入</span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure><h3 id="其他">7.0.10 其他</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成一个可供发布的压缩包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git archive</span></span><br></pre></td></tr></table></figure><h3 id="仓库迁移">7.0.11 仓库迁移</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除原有的git地址</span></span><br><span class="line">git remote rm origin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加新地址</span></span><br><span class="line">git remote add origin new_rep.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交代码</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h1 id="常见问题">8 常见问题</h1><h3 id="git-提交报错-error-RPC-failed-curl-92-HTTP-2-stream-0-was-not-closed-cleanly-PROTOCOL-ERROR-err-1">8.0.1 git 提交报错 error: RPC failed; curl 92 HTTP/2 stream 0 was not closed cleanly: PROTOCOL_ERROR (err 1)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: RPC 失败。curl 92 HTTP/2 stream 0 was not closed cleanly: CANCEL (err 8)</span><br><span class="line">send-pack: unexpected disconnect while reading sideband packet</span><br></pre></td></tr></table></figure><p>原因：http2本身的bug</p><p>解决方法：</p><p>①替换掉git的http的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.version HTTP/1.1</span><br></pre></td></tr></table></figure><p>②更改git的克隆方式http为ssh，使用ssh进行代码的下载和提交</p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Halo博客搭建</title>
      <link href="posts/4d966b64.html"/>
      <url>posts/4d966b64.html</url>
      
        <content type="html"><![CDATA[<h1 id="halo博客搭建">1 halo博客搭建</h1><h2 id="1、介绍">1.1 1、介绍</h2><p>Halo 的整个应用程序只有一个 Jar 包，且不包含用户的任何配置，它放在任何目录都是可行的。需要注意的是，Halo 的整个额外文件全部存放在 <code>~/.halo</code> 目录下，包括 <code>application.yaml（用户配置文件）</code>，<code>template/themes（主题目录）</code>，<code>upload（附件上传目录）</code>，<code>halo.db.mv（数据库文件）</code>。一定要保证 <code>~/.halo</code> 的存在，你博客的所有资料可都存在里面。所以你完全不需要担心安装包的安危，它仅仅是个服务而已。</p><h2 id="2、安装OpenJDK11">1.2 2、安装OpenJDK11</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openjdk-11-jdk</span><br></pre></td></tr></table></figure><h2 id="3、安装halo">1.3 3、安装halo</h2><ul><li>新建路径</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir halo</span><br></pre></td></tr></table></figure><ul><li>下载最新的 Halo 安装包， 为版本号，不带 v，更多下载地址请访问 <a href="https://halo.run/archives/download.html">https://halo.run/archives/download.html</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/halo-dev/halo/releases/download/v1.4.2/halo-1.4.2.jar -O halo-latest.jar</span><br></pre></td></tr></table></figure><ul><li>下载配置文件到 ~/.halo 目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o ~/.halo/application.yaml --create-dirs https://dl.halo.run/config/application-template.yaml</span><br></pre></td></tr></table></figure><ul><li>修改配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.halo/application.yaml</span><br></pre></td></tr></table></figure><p>得到如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8090</span>  <span class="comment"># 端口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Response data gzip.</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># H2 数据库配置</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.h2.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:h2:file:~/.halo/db/halo</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">creekwater</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yang0517</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># MySQL database configuration.</span></span><br><span class="line"><span class="comment">#    driver-class-name: com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">#    url: jdbc:mysql://127.0.0.1:3306/halodb?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line"><span class="comment">#    username: root</span></span><br><span class="line"><span class="comment">#    password: 123456</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># H2 database console configuration.</span></span><br><span class="line">  <span class="attr">h2:</span></span><br><span class="line">    <span class="attr">console:</span></span><br><span class="line">      <span class="attr">settings:</span></span><br><span class="line">        <span class="attr">web-allow-others:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/h2-console</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">halo:</span></span><br><span class="line">  <span class="comment"># web后台路径 https://your-domain/&#123;admin-path&#125;</span></span><br><span class="line">  <span class="comment"># https://127.0.0.1/creekwater-admin</span></span><br><span class="line">  <span class="attr">admin-path:</span> <span class="string">creekwater-admin</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># memory or level</span></span><br><span class="line">  <span class="attr">cache:</span> <span class="string">memory</span></span><br></pre></td></tr></table></figure><ol><li>如果需要自定义端口，修改 <code>server</code> 节点下的 <code>port</code> 即可。</li><li>默认使用的是 <code>H2 Database</code> 数据库，这是一种嵌入式的数据库，使用起来非常方便。需要注意的是，默认的用户名和密码为 <code>admin</code> 和 <code>123456</code>，这个是自定义的，最好将其修改，并妥善保存。</li><li>如果需要使用 <code>MySQL</code> 数据库，需要将 <code>H2 Database</code> 的所有相关配置都注释掉，并取消 <code>MySQL</code> 的相关配置。另外，<code>MySQL</code> 的默认数据库名为 <code>halodb</code>，请自行配置 <code>MySQL</code> 并创建数据库，以及修改配置文件中的用户名和密码。</li><li><code>h2</code> 节点为 <code>H2 Database</code> 的控制台配置，默认是关闭的，如需使用请将 <code>h2.console.settings.web-allow-others</code> 和 <code>h2.console.enabled</code> 设置为 <code>true</code>。控制台地址即为 <code>域名/h2-console</code>。注意：非紧急情况，不建议开启该配置。</li><li><code>server.compression.enabled</code> 为 <code>Gzip</code> 功能配置，如有需要请设置为 <code>true</code>，需要注意的是，如果你使用 <code>Nginx</code> 或者 <code>Caddy</code> 进行反向代理的话，默认是有开启 <code>Gzip</code> 的，所以这里可以保持默认。</li><li><code>halo.admin-path</code> 为后台管理的根路径，默认为 <code>admin</code>，如果你害怕别人猜出来默认的 <code>admin</code>（就算猜出来，对方什么都做不了），请自行设置。仅支持一级，且前后不带 <code>/</code>。</li><li><code>halo.cache</code> 为系统缓存形式的配置，可选 <code>memory</code> 和 <code>level</code>，默认为 <code>memory</code>，将数据缓存到内存，使用该方式的话，重启应用会导致缓存清空。如果选择 <code>level</code>，则会将数据缓存到磁盘，重启不会清空缓存。如不知道如何选择，建议默认。</li></ol><blockquote><p>注意</p><p>使用 MySQL 之前，必须要先新建一个 <code>halodb</code> 数据库，MySQL 版本需 5.7 以上。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database halodb <span class="type">character</span> <span class="keyword">set</span> utf8mb4 <span class="keyword">collate</span> utf8mb4_bin;</span><br></pre></td></tr></table></figure></blockquote><ul><li>启动测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar halo-latest.jar</span><br></pre></td></tr></table></figure><ul><li>看到以下输出，说明启动成功</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run.halo.app.listener.StartedListener    : Halo started at         http://127.0.0.1:8090</span><br><span class="line">run.halo.app.listener.StartedListener    : Halo admin started at   http://127.0.0.1:8090/admin</span><br><span class="line">run.halo.app.listener.StartedListener    : Halo has started successfully!</span><br></pre></td></tr></table></figure><h2 id="4、配置halo开机自启动">1.4 4、配置halo开机自启动</h2><p>上面我们已经完成了 Halo 的整个配置和安装过程，接下来我们对其进行更完善的配置，比如：<code>需要开机自启？</code>，<code>更简单的启动方式？</code></p><p>实现以上功能我们只需要新增一个配置文件即可，也就是使用 <code>Systemd</code> 来完成这些工作。</p><ul><li>下载 Halo 官方的 halo.service 模板</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -o /etc/systemd/system/halo.service --create-dirs https://dl.halo.run/config/halo.service</span><br></pre></td></tr></table></figure><ul><li>修改 halo.service</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/halo.service</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Halo Service</span><br><span class="line">Documentation&#x3D;https:&#x2F;&#x2F;halo.run</span><br><span class="line">After&#x3D;network-online.target</span><br><span class="line">Wants&#x3D;network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User&#x3D;wzy</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;java -server -Xms256m -Xmx256m -jar YOUR_JAR_PATH</span><br><span class="line">ExecStop&#x3D;&#x2F;bin&#x2F;kill -s QUIT $MAINPID</span><br><span class="line">Restart&#x3D;always</span><br><span class="line">StandOutput&#x3D;syslog</span><br><span class="line"></span><br><span class="line">StandError&#x3D;inherit</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><ul><li>-Xms256m：为 JVM 启动时分配的内存，请按照服务器的内存做适当调整，512 M 内存的服务器推荐设置为 128，1G 内存的服务器推荐设置为 256，默认为 256。</li><li>-Xmx256m：为 JVM 运行过程中分配的最大内存，配置同上。</li><li>YOUR_JAR_PATH：Halo 安装包的绝对路径，例如 <code>/www/wwwroot/halo-latest.jar</code>。</li></ul><blockquote><p>-Xms256m：为 JVM 启动时分配的内存，请按照服务器的内存做适当调整，512 M 内存的服务器推荐设置为 128，1G 内存的服务器推荐设置为 256，默认为 256。</p><p>-Xmx256m：为 JVM 运行过程中分配的最大内存，配置同上。</p><p>YOUR_JAR_PATH：Halo 安装包的绝对路径，例如 <code>/www/wwwroot/halo-latest.jar</code>。</p></blockquote><p>提示</p><ol><li>如果你不是按照上面的方法安装的 JDK，请确保 <code>/usr/bin/java</code> 是正确无误的。</li><li>systemd 中的所有路径均要写为绝对路径，另外，<code>~</code> 在 systemd 中也是无法被识别的，所以你不能写成类似 <code>~/halo-latest.jar</code> 这种路径。</li><li>如何检验是否修改正确：把 ExecStart 中的命令拿出来执行一遍。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改 service 文件之后需要刷新 Systemd</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使 Halo 开机自启</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> halo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Halo</span></span><br><span class="line">sudo service halo start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 Halo</span></span><br><span class="line">sudo service halo restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止 Halo</span></span><br><span class="line">sudo service halo stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Halo 的运行状态</span></span><br><span class="line">sudo service halo status</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> BLOG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BLOG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hugo配置文件</title>
      <link href="posts/f2ed0f51.html"/>
      <url>posts/f2ed0f51.html</url>
      
        <content type="html"><![CDATA[<h1 id="author">1 author</h1><p>作者</p><blockquote><p>author = “creekwater”</p></blockquote><h1 id="title">2 title</h1><p>文章的标题</p><blockquote><p>title = “hugo配置文件”</p></blockquote><h1 id="data">3 data</h1><p>文章编写的日期</p><blockquote><p>2021-01-05</p></blockquote><h1 id="description">4 description</h1><blockquote><p>description = “hugo配置参数详解”</p></blockquote><h1 id="categories">5 categories</h1><p>文章的分类，在Archives可以看到不同的分类</p><blockquote><p>categories = [<br>    “建站”<br>]</p></blockquote><h1 id="tags">6 tags</h1><p>文章的标签，在主页的右边标签云附近显示</p><blockquote><p>tags = [<br>    “hugo”<br>]</p></blockquote><h1 id="image">7 image</h1><p>首页每个文章的图片</p><blockquote><p>image = “the-creative-exchange-d2zvqp3fpro-unsplash.jpg”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> BLOG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BLOG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令汇总</title>
      <link href="posts/337fc13d.html"/>
      <url>posts/337fc13d.html</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu20设置python2为默认python">1 Ubuntu20设置python2为默认python</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /usr/bin/python </span><br><span class="line">sudo ln -s /usr/bin/python2 /usr/bin/python </span><br></pre></td></tr></table></figure><h1 id="Ubuntu20设置python3为默认python">2 Ubuntu20设置python3为默认python</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-is-python3</span><br></pre></td></tr></table></figure><h1 id="macOS-下设置python3为默认python">3 macOS 下设置python3为默认python</h1><h2 id="方法一（不建议）：alias">3.1 方法一（不建议）：alias</h2><h2 id="方法二（不建议）：关闭sip来设置">3.2 方法二（不建议）：关闭sip来设置</h2><p>在新版macos系统下，系统默认设置需要关闭sip来进行修改。</p><h2 id="方法三（推荐）：软连接">3.3 方法三（推荐）：软连接</h2><p>在<code>/usr/local/bin</code>下新建一个python的软连接，由于PATH中该路径是优先的，在寻找python时优先在该路径下寻找，所以这个路径下有python软连接会覆盖<code>/usr/bin</code>中的python软连接，实现修改默认python</p><ul><li>确保PATH中包含<code>/usr/local/bin</code> ，使用<code>cat $PATH</code>查看，不是的话设置<code>export PATH=/usr/local/bin:$PATH</code></li><li>添加软连接 <code>ln -s /usr/local/bin/python3 /usr/local/bin/python</code></li></ul><p>如果在M1平台，可以将Python3连接到homebrew平台下</p><ul><li><code>ln -s /opt/homebrew/bin/python3 /opt/homebrew/bin/python</code></li></ul><h1 id="Ubuntu更换阿里源">4 Ubuntu更换阿里源</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bak</span><br><span class="line">sudo sed -i &#39;s&#x2F;security.ubuntu&#x2F;mirrors.aliyun&#x2F;g&#39; &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br><span class="line">sudo sed -i &#39;s&#x2F;archive.ubuntu&#x2F;mirrors.aliyun&#x2F;g&#39; &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt-get upgrade# 更新已安装的包到最新，这个是可选的</span><br></pre></td></tr></table></figure><h1 id="Linux安装samba服务">5 Linux安装samba服务</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install samba </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux创建共享文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建文件夹，并右击属性设置为 sambashare 或者 sudo chmod 777 /home/zsh/share</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Samba配置</span></span><br><span class="line">sudo vim /etc/samba/smb.conf </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入：[share]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置共享目录</span></span><br><span class="line"></span><br><span class="line">path = /home/wzy/share</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置访问用户</span> </span><br><span class="line">valid users = wzy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置读写权限</span></span><br><span class="line">writable = yes  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux 设置samba共享用户密码</span></span><br><span class="line">sudo useradd wzy # 新建用户，可以直接使用已有用户</span><br><span class="line">sudo smbpasswd -a wzy</span><br><span class="line">sudo service smbd restart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> linxu访问</span></span><br><span class="line">smb://192.168.0.216/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Windows访问,输入用户名和密码，即可访问</span></span><br><span class="line">\\192.168.0.216\</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看samba服务器中已拥有哪些用户：</span></span><br><span class="line">sudo pdbedit -L</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除samba服务中的某个用户</span></span><br><span class="line">sudo smbpasswd -x 用户名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除linux某个用户</span></span><br><span class="line">sudo userdel 用户名</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除linux中某个用户所有信息</span></span><br><span class="line">sudo userdel -r 用户名</span><br></pre></td></tr></table></figure><h1 id="vscode无法远程连接wsl">6 vscode无法远程连接wsl</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启wsl</span></span><br><span class="line">wsl.exe --shutdown</span><br><span class="line">wsl.exe</span><br></pre></td></tr></table></figure><h1 id="安装wsl">7 安装wsl</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 管理员权限打开终端，开启win10虚拟系统</span></span><br><span class="line">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</span><br><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启电脑</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载内核更新包并安装</span></span><br><span class="line">https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置wsl版本</span></span><br><span class="line">wsl --set-default-version 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在商店安装ubuntu20</span></span><br></pre></td></tr></table></figure><h1 id="linux-交叉编译链">8 linux 交叉编译链</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装arm-linux-gcc</span><br><span class="line">sudo apt-get install g++-arm-linux-gnueabihf</span><br><span class="line"></span><br><span class="line"># 安装arm-linux-g++</span><br><span class="line">sudo apt-get install g++-arm-linux-gnueabihf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 卸载arm-linux-gcc</span></span><br><span class="line">sudo apt-get remove gcc-arm-linux-gnueabihf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载arm-linux-g++</span></span><br><span class="line">sudo apt-get remove g++-arm-linux-gnueabihf</span><br></pre></td></tr></table></figure><h1 id="mac访问linux文件">9 mac访问linux文件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ubuntu开启FTP服务</span></span><br><span class="line">sudo apt-get install vsftpd</span><br><span class="line"></span><br><span class="line">sudo vim /etc/vsftpd.conf</span><br></pre></td></tr></table></figure><p>打开 vsftpd.conf 文件以后找到如下两行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br></pre></td></tr></table></figure><p>确保上面两行前面没有“#”，有的话就取消掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/vsftpd restart</span><br></pre></td></tr></table></figure><p>mac打开浏览器，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下面的IP是Linux的IP地址</span></span><br><span class="line">ftp://192.168.0.112/</span><br></pre></td></tr></table></figure><p>然后会自动打开finder，填入linux的用户名和密码即可</p><h1 id="mac安装CH340驱动">10 mac安装CH340驱动</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.wch.cn/download/CH341SER_MAC_ZIP.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1、esp32 panic详解</title>
      <link href="posts/9ea78192.html"/>
      <url>posts/9ea78192.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-dport-panic-highint-hdl-S">1 1. dport_panic_highint_hdl.S</h1><p>call4 panicHandler：传递(XtExcFrame *)frame</p><h1 id="2-panic-handler">2 2. panic_handler</h1><ul><li><p>保存frame：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_exc_frames[core_id] = frame</span><br></pre></td></tr></table></figure></li><li><p>确保只有一个内核进入panic</p></li><li><p>如果是PANIC_RSN_INTWDT_CPU0引起的，正在执行代码的CPU必须是CPU0</p></li><li><p>如果是PANIC_RSN_INTWDT_CPU1引起的，正在执行代码的CPU必须是CPU1</p></li><li><p>如果是PANIC_RSN_CACHEERR引起的，引起错误的CPU不是正在执行代码的CPU，则不打印，并清掉g_exc_frames[core_id]</p></li><li><p>使能cpu cache</p></li><li><p>如果是PANIC_RSN_INTWDT_CPU0/1引起的，需要重启看门狗</p></li><li><p>将架构异常信息frame（XtExcFrame）转换为抽象的紧急信息info（panic_info_t）</p></li><li><p>打印info</p></li></ul><p><em><strong>引起异常的原因</strong></em></p><blockquote><p>PANIC_RSN_DEBUGEXCEPTION            </p><p>PANIC_RSN_DOUBLEEXCEPTION          </p><p>PANIC_RSN_KERNELEXCEPTION            </p><p>PANIC_RSN_COPROCEXCEPTION          </p><p>PANIC_RSN_INTWDT_CPU0                    </p><p>PANIC_RSN_INTWDT_CPU1                    </p><p>PANIC_RSN_CACHEERR                          </p></blockquote><h1 id="3-frame-to-panic-info-异常信息转换">3 3. frame_to_panic_info:异常信息转换</h1><ul><li><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> core;                               <span class="comment">// 引发异常的核心</span></span><br><span class="line">  <span class="keyword">panic_exception_t</span> exception;            <span class="comment">// 引发异常的原因</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* reason;                     <span class="comment">// 异常字符串</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* description;                <span class="comment">// 异常的简短描述</span></span><br><span class="line">  <span class="keyword">panic_info_dump_fn_t</span> details;           <span class="comment">// 有关异常的更多信息</span></span><br><span class="line">  <span class="keyword">panic_info_dump_fn_t</span> state;             <span class="comment">// 处理器状态，通常是寄存器的内容</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* addr;                       <span class="comment">// 触发异常的指令地址</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* frame;                      <span class="comment">// 参考框架，直接从汇编传过来的</span></span><br><span class="line">  <span class="keyword">bool</span> pseudo_excause;                    <span class="comment">// 表示异常原因有特殊含义的标志</span></span><br><span class="line">&#125; <span class="keyword">panic_info_t</span>;</span><br><span class="line"></span><br><span class="line">info-&gt;core = cpu_hal_get_core_id();</span><br><span class="line">info-&gt;exception = PANIC_EXCEPTION_FAULT;</span><br><span class="line">info-&gt;details = <span class="literal">NULL</span>;   </span><br><span class="line">info-&gt;reason = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">info-&gt;pseudo_excause = pseudo_excause;    <span class="comment">//这里是true</span></span><br><span class="line"></span><br><span class="line">info-&gt;state = print_state;</span><br><span class="line">info-&gt;frame = frame;</span><br></pre></td></tr></table></figure></li><li><p>异常信息格式转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pseudo_excause) &#123;</span><br><span class="line">    panic_soc_fill_info(frame, info);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    panic_arch_fill_info(frame, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-panic-soc-fill-info：信息格式转换">3.1 3.1 panic_soc_fill_info：信息格式转换</h2></li><li><p>CPU0看门狗引起的异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame-&gt;exccause &#x3D;&#x3D; PANIC_RSN_INTWDT_CPU0</span><br></pre></td></tr></table></figure><p>填充：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info-&gt;core = <span class="number">0</span>;</span><br><span class="line">info-&gt;exception = PANIC_EXCEPTION_IWDT;</span><br><span class="line">info-&gt;reason = <span class="string">&quot;Interrupt wdt timeout on CPU0&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>CPU1看门狗引起的异常</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame-&gt;exccause == PANIC_RSN_INTWDT_CPU1</span><br></pre></td></tr></table></figure><p>填充：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info-&gt;core = <span class="number">1</span>;</span><br><span class="line">info-&gt;exception = PANIC_EXCEPTION_IWDT;</span><br><span class="line">info-&gt;reason = <span class="string">&quot;Interrupt wdt timeout on CPU1&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>cache错误引起的异常</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame-&gt;exccause == PANIC_RSN_CACHEERR</span><br></pre></td></tr></table></figure><p>填充：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info-&gt;core =  esp_cache_err_get_cpuid();</span><br></pre></td></tr></table></figure><h1 id="4-esp-panic-handler">4 4. esp_panic_handler</h1></li><li><p>打印panic info的信息</p></li><li><p>如果panic看门狗未启动，则配置RTC看门狗</p></li><li><p>关闭IWDT，启动TWDT，配置1秒后重置，留时间打印调试信息</p></li><li><p>关闭IWDT、TWDT，将panic info写入flash或者uart</p></li><li><p>关闭RTC看门狗</p></li><li><p>设置重启原因，重启系统（或者关闭所有看门狗，进入死循环）</p></li></ul><h1 id="5-默认打印，无关乎写入flash或者uart">5 5. 默认打印，无关乎写入flash或者uart</h1><h3 id="5-1-串口默认显示">5.0.1 5.1 串口默认显示</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Guru Meditation Error of type StoreProhibited occurred on core  0. Exception was unhandled.</span><br><span class="line">Register dump:</span><br><span class="line">PC      : 0x400f360d  PS      : 0x00060330  A0      : 0x800dbf56  A1      : 0x3ffb7e00</span><br><span class="line">A2      : 0x3ffb136c  A3      : 0x00000005  A4      : 0x00000000  A5      : 0x00000000</span><br><span class="line">A6      : 0x00000000  A7      : 0x00000080  A8      : 0x00000000  A9      : 0x3ffb7dd0</span><br><span class="line">A10     : 0x00000003  A11     : 0x00060f23  A12     : 0x00060f20  A13     : 0x3ffba6d0</span><br><span class="line">A14     : 0x00000047  A15     : 0x0000000f  SAR     : 0x00000019  EXCCAUSE: 0x0000001d</span><br><span class="line">EXCVADDR: 0x00000000  LBEG    : 0x4000c46c  LEND    : 0x4000c477  LCOUNT  : 0x00000000</span><br><span class="line"></span><br><span class="line">Backtrace: 0x400f360d:0x3ffb7e00 0x400dbf56:0x3ffb7e20 0x400dbf5e:0x3ffb7e40 0x400dbf82:0x3ffb7e60 0x400d071d:0x3ffb7e90</span><br></pre></td></tr></table></figure><h3 id="5-2-IDF监视器进行补充">5.0.2 5.2 IDF监视器进行补充</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Guru Meditation Error of type StoreProhibited occurred on core  0. Exception was unhandled.</span><br><span class="line">Register dump:</span><br><span class="line">PC      : 0x400f360d  PS      : 0x00060330  A0      : 0x800dbf56  A1      : 0x3ffb7e00</span><br><span class="line">0x400f360d: do_something_to_crash at /home/gus/esp/32/idf/examples/get-started/hello_world/main/./hello_world_main.c:57</span><br><span class="line">(inlined by) inner_dont_crash at /home/gus/esp/32/idf/examples/get-started/hello_world/main/./hello_world_main.c:52</span><br><span class="line">A2      : 0x3ffb136c  A3      : 0x00000005  A4      : 0x00000000  A5      : 0x00000000</span><br><span class="line">A6      : 0x00000000  A7      : 0x00000080  A8      : 0x00000000  A9      : 0x3ffb7dd0</span><br><span class="line">A10     : 0x00000003  A11     : 0x00060f23  A12     : 0x00060f20  A13     : 0x3ffba6d0</span><br><span class="line">A14     : 0x00000047  A15     : 0x0000000f  SAR     : 0x00000019  EXCCAUSE: 0x0000001d</span><br><span class="line">EXCVADDR: 0x00000000  LBEG    : 0x4000c46c  LEND    : 0x4000c477  LCOUNT  : 0x00000000</span><br><span class="line"></span><br><span class="line">Backtrace: 0x400f360d:0x3ffb7e00 0x400dbf56:0x3ffb7e20 0x400dbf5e:0x3ffb7e40 0x400dbf82:0x3ffb7e60 0x400d071d:0x3ffb7e90</span><br><span class="line">0x400f360d: do_something_to_crash at /home/gus/esp/32/idf/examples/get-started/hello_world/main/./hello_world_main.c:57</span><br><span class="line">(inlined by) inner_dont_crash at /home/gus/esp/32/idf/examples/get-started/hello_world/main/./hello_world_main.c:52</span><br><span class="line">0x400dbf56: still_dont_crash at /home/gus/esp/32/idf/examples/get-started/hello_world/main/./hello_world_main.c:47</span><br><span class="line">0x400dbf5e: dont_crash at /home/gus/esp/32/idf/examples/get-started/hello_world/main/./hello_world_main.c:42</span><br><span class="line">0x400dbf82: app_main at /home/gus/esp/32/idf/examples/get-started/hello_world/main/./hello_world_main.c:33</span><br><span class="line">0x400d071d: main_task at /home/gus/esp/32/idf/components/esp32/./cpu_start.c:254</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ESP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2、panic写入串口</title>
      <link href="posts/4e4cdbae.html"/>
      <url>posts/4e4cdbae.html</url>
      
        <content type="html"><![CDATA[<h1 id="elfhdr初始化，写到串口或者flash">1 elfhdr初始化，写到串口或者flash</h1><h1 id="处理task-reg，写入信息，并计算其长度">2 处理task reg，写入信息，并计算其长度</h1><ul><li><p>获取当前任务索引</p></li><li><p>判断当前任务是否损坏，坏掉的话则self-&gt;bad_tasks_num++</p></li><li><p>判断其他任务是否损坏，坏掉的话则self-&gt;bad_tasks_num++</p></li><li><p>打印所有任务的xtensa_elf_reg_dump_t信息</p></li><li><p>将当前任务和其他任务的长度加起来</p></li><li><p>如果coredump发生在中断服务程序里，加上其长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">xtensa_pr_status_t</span> pr_status;</span><br><span class="line">    <span class="keyword">xtensa_gregset_t</span> regs;</span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line">&#125; __attribute__((packed)) <span class="keyword">xtensa_elf_reg_dump_t</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> si_signo;</span><br><span class="line">    <span class="keyword">uint32_t</span> si_code;</span><br><span class="line">    <span class="keyword">uint32_t</span> si_errno;</span><br><span class="line">    <span class="keyword">uint16_t</span> pr_cursig;</span><br><span class="line">    <span class="keyword">uint16_t</span> pr_pad0;</span><br><span class="line">    <span class="keyword">uint32_t</span> pr_sigpend;</span><br><span class="line">    <span class="keyword">uint32_t</span> pr_sighold;</span><br><span class="line">    <span class="keyword">uint32_t</span> pr_pid;</span><br><span class="line">    <span class="keyword">uint32_t</span> pr_ppid;</span><br><span class="line">    <span class="keyword">uint32_t</span> pr_pgrp;</span><br><span class="line">    <span class="keyword">uint32_t</span> pr_sid;</span><br><span class="line">    <span class="keyword">uint64_t</span> pr_utime;</span><br><span class="line">    <span class="keyword">uint64_t</span> pr_stime;</span><br><span class="line">    <span class="keyword">uint64_t</span> pr_cutime;</span><br><span class="line">    <span class="keyword">uint64_t</span> pr_cstime;</span><br><span class="line">&#125; __attribute__((packed)) <span class="keyword">xtensa_pr_status_t</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pc;</span><br><span class="line">    <span class="keyword">uint32_t</span> ps;</span><br><span class="line">    <span class="keyword">uint32_t</span> lbeg;</span><br><span class="line">    <span class="keyword">uint32_t</span> lend;</span><br><span class="line">    <span class="keyword">uint32_t</span> lcount;</span><br><span class="line">    <span class="keyword">uint32_t</span> sar;</span><br><span class="line">    <span class="keyword">uint32_t</span> windowstart;</span><br><span class="line">    <span class="keyword">uint32_t</span> windowbase;</span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">8</span>+<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> ar[XCHAL_NUM_AREGS];</span><br><span class="line">&#125; __attribute__((packed)) <span class="keyword">xtensa_gregset_t</span>;</span><br></pre></td></tr></table></figure><h1 id="处理task-tcb和task-stack，将堆栈数据写入分区">3 处理task tcb和task stack，将堆栈数据写入分区</h1></li><li><p>elf_process_task_tcb、elf_process_task_stack</p></li><li><p>构造elf_phdr，并将其写入uart或者flash，同时返回其大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_phdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word p_type;</span><br><span class="line">    Elf32_Off p_offset;</span><br><span class="line">    Elf32_Addr p_vaddr;</span><br><span class="line">    Elf32_Addr p_paddr;</span><br><span class="line">    Elf32_Word p_filesz;</span><br><span class="line">    Elf32_Word p_memsz;</span><br><span class="line">    Elf32_Word p_flags;</span><br><span class="line">    Elf32_Word p_align;</span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure><h1 id="写入用户数据的core-dump">4 写入用户数据的core dump</h1></li><li><p>获取四个不同RAM控件的起始地址和大小</p><blockquote><p>DRAM    IRAM    RTC   RTC_FAST </p></blockquote></li><li><p>构造elf_phdr，写入uart或者flash，同时返回大小</p></li></ul><h1 id="写入elf版本信息">5 写入elf版本信息</h1><h1 id="写入额外信息">6 写入额外信息</h1><h1 id="写入额外信息字段">7 写入额外信息字段</h1><h1 id="最终打印输出">8 最终打印输出</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">===============================================================</span><br><span class="line">==================== ESP32 CORE DUMP START ====================</span><br><span class="line"></span><br><span class="line">================== CURRENT THREAD REGISTERS ===================</span><br><span class="line">pc             0x400d206f       0x400d206f &lt;app_main+95&gt;</span><br><span class="line">lbeg           0x400014fd       1073747197</span><br><span class="line">lend           0x4000150d       1073747213</span><br><span class="line">lcount         0xfffffffd       4294967293</span><br><span class="line">sar            0x14     20</span><br><span class="line">ps             0x60220  393760</span><br><span class="line">threadptr      &lt;unavailable&gt;</span><br><span class="line">br             &lt;unavailable&gt;</span><br><span class="line">scompare1      &lt;unavailable&gt;</span><br><span class="line">acclo          &lt;unavailable&gt;</span><br><span class="line">acchi          &lt;unavailable&gt;</span><br><span class="line">m0             &lt;unavailable&gt;</span><br><span class="line">m1             &lt;unavailable&gt;</span><br><span class="line">m2             &lt;unavailable&gt;</span><br><span class="line">m3             &lt;unavailable&gt;</span><br><span class="line">expstate       &lt;unavailable&gt;</span><br><span class="line">f64r_lo        &lt;unavailable&gt;</span><br><span class="line">f64r_hi        &lt;unavailable&gt;</span><br><span class="line">f64s           &lt;unavailable&gt;</span><br><span class="line">fcr            &lt;unavailable&gt;</span><br><span class="line">fsr            &lt;unavailable&gt;</span><br><span class="line">a0             0x400d0829       1074595881</span><br><span class="line">a1             0x3ffb49f0       1073433072</span><br><span class="line">a2             0x0      0</span><br><span class="line">a3             0x1      1</span><br><span class="line">a4             0x1      1</span><br><span class="line">a5             0x3ffb4ab4       1073433268</span><br><span class="line">a6             0x0      0</span><br><span class="line">a7             0x1      1</span><br><span class="line">a8             0x5      5</span><br><span class="line">a9             0x3ffb49a0       1073432992</span><br><span class="line">a10            0x13     19</span><br><span class="line">a11            0x3ffb4b1c       1073433372</span><br><span class="line">a12            0x3f402c50       1061170256</span><br><span class="line">a13            0x3f402c3c       1061170236</span><br><span class="line">a14            0x3ffaffec       1073414124</span><br><span class="line">a15            0x0      0</span><br><span class="line"></span><br><span class="line">==================== CURRENT THREAD STACK =====================</span><br><span class="line"><span class="meta">#</span><span class="bash">0  0x400d206f <span class="keyword">in</span> app_main () at /home/nicholas/Sources/<span class="built_in">test</span>/hello_world/main/./hello_world_main.c:38</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1  0x400d0829 <span class="keyword">in</span> main_task (args=0x0) at /home/nicholas/Sources/Github/LuaNode/LuaNode_Esp32/esp-idf/components/esp32/./cpu_start.c:449</span></span><br><span class="line"></span><br><span class="line">======================== THREADS INFO =========================</span><br><span class="line">  Id   Target Id         Frame</span><br><span class="line">  8    process 7         0x40084611 in xQueueGenericReceive (xQueue=0x3ffafd18, pvBuffer=0x0, xTicksToWait=4294967295, xJustPeeking=0) at /home/nicholas/Sources/Github/LuaNode/LuaNode_Esp32/esp-idf/components/freertos/./queue.c:1591</span><br><span class="line">  7    process 6         0x40081096 in esp_crosscore_int_send_yield (core_id=1) at /home/nicholas/Sources/Github/LuaNode/LuaNode_Esp32/esp-idf/  mponents/esp32/./crosscore_int.c:112</span><br><span class="line">▽ 6    process 5         0x40084611 in xQueueGenericReceive (xQueue=0x3ffaea14, pvBuffer=0x0, xTicksToWait=4294967295, xJustPeeking=0) at /home/nicholas/Sources/Github/LuaNode/LuaNode_Esp32/esp-idf/components/freertos/./queue.c:1591</span><br><span class="line">  5    process 4         0x4008528a in vTaskDelete (xTaskToDelete=&lt;optimized out&gt;) at /home/nicholas/Sources/Github/LuaNode/LuaNode_Esp32/esp-idf/components/freertos/./tasks.c:1316</span><br><span class="line">  4    process 3         0x40085ec4 in prvProcessTimerOrBlockTask (xNextExpireTime=&lt;optimized out&gt;, xListWasEmpty=&lt;optimized out&gt;) at /home/nicholas/Sources/Github/LuaNode/LuaNode_Esp32/esp-idf/components/freertos/./timers.c:588</span><br><span class="line">  3    process 2         prvIdleTask (pvParameters=0x0) at /home/nicholas/Sources/Github/LuaNode/LuaNode_Esp32/esp-idf/components/freertos/./tasks.c:3353</span><br><span class="line">  2    process 1         prvIdleTask (pvParameters=0x0) at /home/nicholas/Sources/Github/LuaNode/LuaNode_Esp32/esp-idf/components/freertos/./tasks.c:3353</span><br><span class="line">* 1    &lt;main task&gt;       0x400d206f in app_main () at /home/nicholas/Sources/test/hello_world/main/./hello_world_main.c:38</span><br><span class="line"></span><br><span class="line">======================= ALL MEMORY REGIONS ========================</span><br><span class="line">Name   Address   Size   Attrs</span><br><span class="line">.rtc.text 0x400c0000 0x0 RW  </span><br><span class="line">.iram0.vectors 0x40080000 0x400 R XA</span><br><span class="line">.iram0.text 0x40080400 0x8b08 R XA</span><br><span class="line">.dram0.data 0x3ffb0000 0x24ac RW A</span><br><span class="line">.flash.rodata 0x3f400020 0x5254 RW A</span><br><span class="line">.flash.text 0x400d0018 0x1334c R XA</span><br><span class="line">.coredump.tasks 0x3ffb4ab4 0x164 RW</span><br><span class="line">.coredump.tasks 0x3ffb4930 0x17c RW</span><br><span class="line">.coredump.tasks 0x3ffb5610 0x164 RW</span><br><span class="line">.coredump.tasks 0x3ffb54e0 0x128 RW</span><br><span class="line">.coredump.tasks 0x3ffb50a4 0x164 RW</span><br><span class="line">.coredump.tasks 0x3ffb4f70 0x12c RW</span><br><span class="line">.coredump.tasks 0x3ffb6070 0x164 RW</span><br><span class="line">.coredump.tasks 0x3ffb5ee0 0x188 RW</span><br><span class="line">.coredump.tasks 0x3ffb3948 0x164 RW</span><br><span class="line">.coredump.tasks 0x3ffb37e0 0x160 RW</span><br><span class="line">.coredump.tasks 0x3ffafa6c 0x164 RW</span><br><span class="line">.coredump.tasks 0x3ffaf8e0 0x184 RW</span><br><span class="line">.coredump.tasks 0x3ffb34dc 0x164 RW</span><br><span class="line">.coredump.tasks 0x3ffb3330 0x1a4 RW</span><br><span class="line">.coredump.tasks 0x3ffafd6c 0x164 RW</span><br><span class="line">.coredump.tasks 0x3ffb2f50 0x180 RW</span><br><span class="line"></span><br><span class="line">===================== ESP32 CORE DUMP END =====================</span><br><span class="line">===============================================================</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ESP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mbedtls加密组件分析</title>
      <link href="posts/841b00c2.html"/>
      <url>posts/841b00c2.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、伪随机数生成器（ctr-drbg）的配置与使用">1 一、伪随机数生成器（ctr_drbg）的配置与使用</h1><h2 id="真随机数和伪随机数">1.1 真随机数和伪随机数</h2><h3 id="区别">1.1.1 区别</h3><p>随机数在安全技术中通常被用于生成随机序列（eg. 秘钥），对于一个随机数的生成而言，是否真正的做到“随机”是最重要的。</p><p>真随机数通常来源于硬件随机数生成器，每次生成的随机数都是真正的随机数，但是因为物理因素，<strong>生成的时间较慢</strong>。比如STM32中提供的RNG硬件外设。</p><p>伪随机数通常来源于某个生成算法，每次生成的随机数虽然是随机的，但还是遵循生成算法的规则，优点是<strong>生成速度较快</strong>。比如C库中提供的rand函数，在相同的种子下，其生成的随机数序列相同，所以称之为伪随机数。</p><p>所以一般情况下，有一种比较巧妙的办法：将两者结合起来，<strong>先使用真随机数生成种子，然后使用伪随机数生成算法</strong>，这样既保证了生成速度，又保证了生成的序列是真正的随机数。</p><p>对应到 mbedtls 中，将产生真随机数的模块称为真随机数生成器（TRNG），将    产生伪随机数的模块称为伪随机数发生器（PRNG）（也叫做确定性随机数生成器，DRBG），其中伪随机数所使用的种子称为<strong>熵源（熵池）</strong>。</p><h3 id="伪随机数生成算法">1.1.2 伪随机数生成算法</h3><p>NIST SP 800-90A规范中描述了三种产生伪随机数的算法：</p><ul><li>Hash_DRBG：使用单向散列算法作为伪随机数生成的基础算法；</li><li>HMAC_DRBG：使用消息认证码算法作为随机数生成的基础算法；</li><li>CRT_DRBG：使用分组密码算法的计数器模式作为随机数生成的基础算法（重点）。</li></ul><p>CRT_DRBG 可以理解为一个AES加密过程，加密结果为期望随机数序列。</p><h2 id="自定义熵源接口">1.2 自定义熵源接口</h2><p>mbedtls中可以通过开启宏定义 <strong>MBEDTLS_ENTROPY_HARDWARE_ALT</strong> 来开启熵源接口，用户可以在熵源接口中实现自己的硬件获取真随机数代码。</p><h3 id="开启宏定义">1.2.1 开启宏定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义此宏，以使mbed TLS使用您自己的硬件熵收集器实现。</span></span><br><span class="line"><span class="comment">// 函数原型必须为 int mbedtls_hardware_poll( void *data, unsigned char *output, size_t len, size_t *olen );</span></span><br><span class="line"><span class="comment">// 并接受NULL作为第一个参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ENTROPY_HARDWARE_ALT</span></span><br></pre></td></tr></table></figure><h3 id="自定义实现mbedtls-hardware-poll函数">1.2.2 自定义实现mbedtls_hardware_poll函数</h3><p>创建一个新文件用于存放我们编写的该函数实现，这里我创建文件<code>entropy_hardware_alt.c</code>。</p><p>实现时需要包含头文件<code>entropy_poll.h</code>，其中包含了 mbedtls_hardware_poll() 函数的原型定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MBEDTLS_ENTROPY_HARDWARE_ALT)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_hardware_poll</span><span class="params">( <span class="keyword">void</span> *data, <span class="keyword">unsigned</span> <span class="keyword">char</span> *output, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *olen )</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里以stm32为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/entropy_poll.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MBEDTLS_ENTROPY_HARDWARE_ALT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32l4xx_hal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/entropy_poll.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> RNG_HandleTypeDef hrng;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_hardware_poll</span><span class="params">( <span class="keyword">void</span> *Data, <span class="keyword">unsigned</span> <span class="keyword">char</span> *Output, <span class="keyword">size_t</span> Len, <span class="keyword">size_t</span> *oLen )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> index;</span><br><span class="line">    <span class="keyword">uint32_t</span> randomValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; Len/<span class="number">4</span>; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (HAL_RNG_GenerateRandomNumber(&amp;hrng, &amp;randomValue) == HAL_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            *oLen += <span class="number">4</span>;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;(Output[index * <span class="number">4</span>]), (<span class="keyword">int</span>)randomValue, <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Error_Handler();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*MBEDTLS_ENTROPY_HARDWARE_ALT*/</span></span></span><br></pre></td></tr></table></figure><h2 id="使用mbedtls-CTR-DRBG接口生成随机数">1.3 使用mbedtls CTR_DRBG接口生成随机数</h2><h3 id="宏配置">1.3.1 宏配置</h3><p>使用mbedtls随机数生成功能需要开启以下宏：</p><table><thead><tr><th>宏定义</th><th>功能</th></tr></thead><tbody><tr><td>MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES</td><td>不使用默认熵源<strong>（如果已有、要屏蔽该宏）</strong><br>定义此宏，以防止加在默认的熵函数<br>基于mbedtls_timing_hardclock和基于HAVEGE的轮询功能。</td></tr><tr><td>MBEDTLS_NO_PLATFORM_ENTROPY</td><td>不使用系统内置熵源</td></tr><tr><td>MBEDTLS_AES_C</td><td>使用AES算法</td></tr><tr><td>MBEDTLS_ENTROPY_C</td><td>使能熵源模块</td></tr><tr><td>MBEDTLS_CTR_DRBG_C</td><td>使能随机数模块</td></tr><tr><td>MBEDTLS_ENTROPY_FORCE_SHA256</td><td>使能SHA256算法</td></tr><tr><td>MBEDTLS_AES_ROM_TABLES</td><td>将AES表存储在ROM中（节约内存空间）</td></tr></tbody></table><p>根据以上代码，编写针对本实验的配置文件<code>mbedtls_config_ctr_drbg.h</code>：</p><p>cmakefile.txt中添加<code>CPPFLAGS += -DMBEDTLS_CONFIG_FILE=&#39;&quot;mbedtls/mbedtls_config_ctr_drbg.h&quot;&#39;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MBEDTLS_CONFIG_CTR_DRBG_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MBEDTLS_CONFIG_CTR_DRBG_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* System support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_HAVE_ASM</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_HAVE_TIME</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed feature support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ENTROPY_HARDWARE_ALT<span class="comment">// 使用自己的硬件熵</span></span></span><br><span class="line"><span class="comment">//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES// 不定义此宏，系统将调用默认的熵函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_NO_PLATFORM_ENTROPY<span class="comment">// 不使用系统内置熵源</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed modules */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_C<span class="comment">// 使用AES算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_ROM_TABLES<span class="comment">// 将aes表存储在rom中</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_CTR_DRBG_C<span class="comment">// 使能随机数模块</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ENTROPY_C<span class="comment">// 使能熵源模块</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA256_C<span class="comment">// 使能sha算法</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/check_config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _MBEDTLS_CONFIG_CTR_DRBG_H_ */</span></span></span><br></pre></td></tr></table></figure><h3 id="API说明">1.3.2 API说明</h3><h4 id="熵相关">1.3.2.1 熵相关</h4><p>① 初始化熵</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_entropy_init</span><span class="params">( mbedtls_entropy_context *ctx )</span></span>;</span><br></pre></td></tr></table></figure><p>② 释放熵</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_entropy_free</span><span class="params">( mbedtls_entropy_context *ctx )</span></span>;</span><br></pre></td></tr></table></figure><p>③ 错误码说明（用于根据返回值判定错误）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_ENTROPY_SOURCE_FAILED                 -0x003C  <span class="comment">/**&lt; Critical entropy source failure. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_ENTROPY_MAX_SOURCES                   -0x003E  <span class="comment">/**&lt; No more sources can be added. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED            -0x0040  <span class="comment">/**&lt; No sources have been added to poll. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE              -0x003D  <span class="comment">/**&lt; No strong sources have been added to poll. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR                 -0x003F  <span class="comment">/**&lt; Read/write error in file. */</span></span></span><br></pre></td></tr></table></figure><h4 id="crt-drbg相关">1.3.2.2 crt_drbg相关</h4><p>① 初始化ctr_drbg随机数种子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_ctr_drbg_init</span><span class="params">( mbedtls_ctr_drbg_context *ctx )</span></span>;</span><br></pre></td></tr></table></figure><p>② 根据熵生成随机数种子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief               This function seeds and sets up the CTR_DRBG</span></span><br><span class="line"><span class="comment"> *                      entropy source for future reseeds.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note Personalization data can be provided in addition to the more generic</span></span><br><span class="line"><span class="comment"> *       entropy source, to make this instantiation as unique as possible.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx           The CTR_DRBG context to seed.</span></span><br><span class="line"><span class="comment"> * \param f_entropy     The entropy callback, taking as arguments the</span></span><br><span class="line"><span class="comment"> *                      \p p_entropy context, the buffer to fill, and the</span></span><br><span class="line"><span class="comment">                        length of the buffer.</span></span><br><span class="line"><span class="comment"> * \param p_entropy     The entropy context.</span></span><br><span class="line"><span class="comment"> * \param custom        Personalization data, that is device-specific</span></span><br><span class="line"><span class="comment">                        identifiers. Can be NULL.</span></span><br><span class="line"><span class="comment"> * \param len           The length of the personalization data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return              \c 0 on success, or</span></span><br><span class="line"><span class="comment"> *                      #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_ctr_drbg_seed</span><span class="params">( mbedtls_ctr_drbg_context *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">int</span> (*f_entropy)(<span class="keyword">void</span> *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> *p_entropy,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *custom,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">size_t</span> len )</span></span>;</span><br></pre></td></tr></table></figure><p>③ 根据随机数种子生成随机数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_ctr_drbg_random</span><span class="params">( <span class="keyword">void</span> *p_rng, <span class="keyword">unsigned</span> <span class="keyword">char</span> *output, <span class="keyword">size_t</span> output_len )</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>最大生成长度是：MBEDTLS_CTR_DRBG_MAX_REQUEST（1024），如果需要修改的话可以在配置文件中定义该宏。</p></blockquote><p>④ 释放ctr_drbg随机数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void mbedtls_ctr_drbg_free( mbedtls_ctr_drbg_context *ctx );</span><br></pre></td></tr></table></figure><p>⑤ 错误码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED        -0x0034  <span class="comment">/**&lt; The entropy source failed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG              -0x0036  <span class="comment">/**&lt; The requested random buffer length is too big. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG                -0x0038  <span class="comment">/**&lt; The input (entropy + additional data) is too large. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR                -0x003A  <span class="comment">/**&lt; Read or write error in file. */</span></span></span><br></pre></td></tr></table></figure><h4 id="编写测试代码">1.3.2.3 编写测试代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MBEDTLS_CONFIG_FILE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> MBEDTLS_CONFIG_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MBEDTLS_CTR_DRBG_C)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/entropy.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/ctr_drbg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_ctr_drbg_test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">uint8_t</span> data_buf[<span class="number">10</span>];</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pers = <span class="string">&quot;crbg_test&quot;</span>;</span><br><span class="line">    mbedtls_entropy_context entropy;<span class="comment">// 熵</span></span><br><span class="line">    mbedtls_ctr_drbg_context ctr_drbg;<span class="comment">// 随机数种子</span></span><br><span class="line"></span><br><span class="line">    mbedtls_entropy_init(&amp;entropy);<span class="comment">// 初始化熵</span></span><br><span class="line">    mbedtls_ctr_drbg_init(&amp;ctr_drbg);<span class="comment">// 初始化随机数种子</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 根据熵生成随机数种子</span></span><br><span class="line">    <span class="keyword">if</span>( ( ret = mbedtls_ctr_drbg_seed( &amp;ctr_drbg, mbedtls_entropy_func, &amp;entropy,</span><br><span class="line">                               (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *) pers,</span><br><span class="line">                               <span class="built_in">strlen</span>( pers ) ) ) != <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;\n  . Seeding the random number generator... failed\n  ! mbedtls_ctr_drbg_seed returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . Seeding the random number generator... ok\n&quot;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据随机数种子生成随机数</span></span><br><span class="line">    <span class="keyword">if</span> ( ( ret = mbedtls_ctr_drbg_random(&amp;ctr_drbg, data_buf, <span class="keyword">sizeof</span>(data_buf) ) ) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;\n  . generate random data... failed\n  ! mbedtls_ctr_drbg_random returned %d\n&quot;</span>, ret );</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . generate random data... ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 打印随机数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;random data:[&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(data_buf); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, data_buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\r\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 5. 释放随机数种子 */</span></span><br><span class="line">    mbedtls_ctr_drbg_free(&amp;ctr_drbg);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 6. 释放熵*/</span></span><br><span class="line">    mbedtls_entropy_free(&amp;entropy);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MBEDTLS_CTR_DRBG_C */</span></span></span><br></pre></td></tr></table></figure><h1 id="二、单向散列算法的配置与使用-MD5-SHA1-SHA256-SHA512">2 二、单向散列算法的配置与使用(MD5-SHA1-SHA256-SHA512)</h1><h2 id="单向散列算法">2.1 单向散列算法</h2><h3 id="单向散列函数">2.1.1 单向散列函数</h3><p>单向散列函数是一类满足密码学算法安全属性的特殊散列函数，可以根据消息的内容计算出散列值，又称为安全散列函数或者哈希函数，通常用于<strong>检验消息完整性</strong>。<br>输入数据称为<strong>消息</strong>，计算出的散列值称为<strong>消息摘要（摘要）</strong>。<br>单向散列函数具有如下特点：</p><ul><li>输入长度任意；</li><li><strong>输出长度固定</strong>；</li><li><strong>单向性</strong>：无法根据散列值还原出消息；<br>单向散列函数主要用在：</li><li>消息完整性检测；</li><li>构造伪随机数生成算法；</li><li>消息认证码；</li><li>数字签名；</li><li>一次性口令；</li></ul><h3 id="单向散列算法-1">2.1.2 单向散列算法</h3><p>单向散列算法是单向散列函数的实现，主要包括两大算法实现：MD4/5系列实现、SHA系列实现。</p><h4 id="MD系列实现">2.1.2.1 MD系列实现</h4><p>MD系列算法最早是MD4，后来诞生了MD5，两者都可以产生128 bit 的散列值。</p><h4 id="SHA系列算法">2.1.2.2 SHA系列算法</h4><p>SHA系列算法由美国国家标准与技术研究所NIST确定，主要包含以下几个：</p><ul><li>SHA0：1993年发布，可以产生160 bit 的消息摘要，但是存在重大缺陷被撤销；</li><li>SHA1：1995年发布，可以产生160 bit 的消息摘要，也存在缺陷（不推荐使用）；</li><li>SHA2：包括SHA256算法、SHA384算法、SHA512算法；</li><li>SHA3：支持与SHA2相同的消息摘要长度，但是算法内部结构不同；</li></ul><h3 id="mbedtls中提供的单向散列算法">2.1.3 mbedtls中提供的单向散列算法</h3><ul><li>MD2</li><li>MD4</li><li>MD5</li><li>SHA1</li><li>SHA224</li><li>SHA256</li><li>SHA384</li><li>SHA512</li></ul><h2 id="功能模块的使用">2.2 功能模块的使用</h2><h3 id="配置宏">2.2.1 配置宏</h3><p>mbedtls中提供的这些单向散列算法，<strong>每个都是一个独立的模块，由对应的宏控制是否开启</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_MD2_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_MD4_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_MD5_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA1_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA224_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA256_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA384_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA512_C</span></span><br></pre></td></tr></table></figure><p>在使用的时候，除了可以使用每个功能模块提供的API，还可以使用<strong>md通用接口</strong>，通过下面的宏开启：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_MD_C</span></span><br></pre></td></tr></table></figure><p>测试SHA1、SHA256、SHA512三个算法，所以编写一个新的配置头文件<code>mbedtls_config_sha_x.h</code>，内容如下：</p><p>cmakefile.txt中添加<code>CPPFLAGS += -DMBEDTLS_CONFIG_FILE=&#39;&quot;mbedtls_config_sha_x.h&quot;&#39;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   Minimal configuration for SHAX Function</span></span><br><span class="line"><span class="comment"> * @author  mculover666</span></span><br><span class="line"><span class="comment"> * @date    2020/09/22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MBEDTLS_CONFIG_SHA_X_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MBEDTLS_CONFIG_SHA_X_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* System support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_HAVE_ASM</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_HAVE_TIME</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed feature support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_NO_PLATFORM_ENTROPY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed modules */</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_MD2_C</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_MD4_C</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_MD5_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA1_C</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_SHA224_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA256_C</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_SHA384_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA512_C</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* enable generic message digest wrappers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_MD_C</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/check_config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _MBEDTLS_CONFIG_SHA_X_H_ */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="md通用接口api说明">2.2.2 md通用接口api说明</h3><p>头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/md.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>① 初始化MD结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_md_init</span><span class="params">( <span class="keyword">mbedtls_md_context_t</span> *ctx )</span></span>;</span><br></pre></td></tr></table></figure><p>② 根据算法类型得到md信息结构体指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">mbedtls_md_info_t</span> *<span class="title">mbedtls_md_info_from_type</span><span class="params">( <span class="keyword">mbedtls_md_type_t</span> md_type )</span></span>;</span><br></pre></td></tr></table></figure><p>其中算法类型 mbedtls_md_type_t 是枚举类型，有以下值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    MBEDTLS_MD_NONE=<span class="number">0</span>,    <span class="comment">/**&lt; None. */</span></span><br><span class="line">    MBEDTLS_MD_MD2,       <span class="comment">/**&lt; The MD2 message digest. */</span></span><br><span class="line">    MBEDTLS_MD_MD4,       <span class="comment">/**&lt; The MD4 message digest. */</span></span><br><span class="line">    MBEDTLS_MD_MD5,       <span class="comment">/**&lt; The MD5 message digest. */</span></span><br><span class="line">    MBEDTLS_MD_SHA1,      <span class="comment">/**&lt; The SHA-1 message digest. */</span></span><br><span class="line">    MBEDTLS_MD_SHA224,    <span class="comment">/**&lt; The SHA-224 message digest. */</span></span><br><span class="line">    MBEDTLS_MD_SHA256,    <span class="comment">/**&lt; The SHA-256 message digest. */</span></span><br><span class="line">    MBEDTLS_MD_SHA384,    <span class="comment">/**&lt; The SHA-384 message digest. */</span></span><br><span class="line">    MBEDTLS_MD_SHA512,    <span class="comment">/**&lt; The SHA-512 message digest. */</span></span><br><span class="line">    MBEDTLS_MD_RIPEMD160, <span class="comment">/**&lt; The RIPEMD-160 message digest. */</span></span><br><span class="line">&#125; <span class="keyword">mbedtls_md_type_t</span>;</span><br></pre></td></tr></table></figure><p>③ 设置md结构体，完成md结构体内部接口初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_md_setup</span><span class="params">( <span class="keyword">mbedtls_md_context_t</span> *ctx, <span class="keyword">const</span> <span class="keyword">mbedtls_md_info_t</span> *md_info, <span class="keyword">int</span> hmac )</span></span>;</span><br></pre></td></tr></table></figure><p>④ 获取单向散列算法名称：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">mbedtls_md_get_name</span><span class="params">( <span class="keyword">const</span> <span class="keyword">mbedtls_md_info_t</span> *md_info )</span></span>;</span><br></pre></td></tr></table></figure><p>⑤ 获取单向散列算法输出消息摘要的长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">mbedtls_md_get_size</span><span class="params">( <span class="keyword">const</span> <span class="keyword">mbedtls_md_info_t</span> *md_info )</span></span>;</span><br></pre></td></tr></table></figure><p>⑥ md启动接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_md_starts</span><span class="params">( <span class="keyword">mbedtls_md_context_t</span> *ctx )</span></span>;</span><br></pre></td></tr></table></figure><p>⑦ md更新接口，处理输入数据，计算散列值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_md_update</span><span class="params">( <span class="keyword">mbedtls_md_context_t</span> *ctx, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *input, <span class="keyword">size_t</span> ilen )</span></span>;</span><br></pre></td></tr></table></figure><p>⑧ md完成接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_md_finish</span><span class="params">( <span class="keyword">mbedtls_md_context_t</span> *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *output )</span></span>;</span><br></pre></td></tr></table></figure><p>⑨ 释放md结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_md_free</span><span class="params">( <span class="keyword">mbedtls_md_context_t</span> *ctx )</span></span>;</span><br></pre></td></tr></table></figure><p>⑩ 错误码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE                -0x5080  <span class="comment">/**&lt; The selected feature is not available. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_MD_BAD_INPUT_DATA                     -0x5100  <span class="comment">/**&lt; Bad input parameters to function. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_MD_ALLOC_FAILED                       -0x5180  <span class="comment">/**&lt; Failed to allocate memory. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_MD_FILE_IO_ERROR                      -0x5200  <span class="comment">/**&lt; Opening or reading of file failed. */</span></span></span><br></pre></td></tr></table></figure><p><strong>调用过程为：</strong></p><ul><li>starts：初始化，只需调用一次；</li><li>update：计算值，可以多次调用；</li><li>finish：获取计算出的消息摘要；</li></ul><p>新建文件<code>mbedtls_sha_x_test.c</code>，编写如下测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MBEDTLS_CONFIG_FILE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> MBEDTLS_CONFIG_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MBEDTLS_MD_C)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/md.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_shax_test</span><span class="params">(<span class="keyword">mbedtls_md_type_t</span> md_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len, i;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="string">&quot;mculover666&quot;</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> digest[<span class="number">32</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mbedtls_md_context_t</span> ctx;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">mbedtls_md_info_t</span> *info;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;message is:%s\r\n&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. init mbedtls_md_context_t structure */</span></span><br><span class="line">    mbedtls_md_init(&amp;ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 2. get md info structure pointer */</span></span><br><span class="line">    info = mbedtls_md_info_from_type(md_type);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 3. setup md info structure */</span></span><br><span class="line">    ret = mbedtls_md_setup(&amp;ctx, info, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 4. start */</span></span><br><span class="line">    ret = mbedtls_md_starts(&amp;ctx);</span><br><span class="line">     <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* 5. update */</span></span><br><span class="line">    ret = mbedtls_md_update(&amp;ctx, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)message, <span class="built_in">strlen</span>(message));</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* 6. finish */</span></span><br><span class="line">    ret = mbedtls_md_finish(&amp;ctx, digest);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* show */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s digest context is:[&quot;</span>, mbedtls_md_get_name(info));</span><br><span class="line">    len= mbedtls_md_get_size(info);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%02x&quot;</span>, digest[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>:</span><br><span class="line">    <span class="comment">/* 7. free */</span></span><br><span class="line">    mbedtls_md_free(&amp;ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MBEDTLS_MD_C */</span></span></span><br></pre></td></tr></table></figure><h1 id="三、对称加密算法的配置与使用（AES算法）">3 三、对称加密算法的配置与使用（AES算法）</h1><h2 id="AES对称加密算法">3.1 AES对称加密算法</h2><h3 id="什么是对称加密算法">3.1.1 什么是对称加密算法</h3><p>对称算法是一种通信双方使用<strong>相同的秘钥</strong>进行加密和解密的密码算法。</p><p>其中这份相同的秘钥称为对称秘钥或者共享秘钥，只有通信双方持有，如果传输的密文被拦截，没有秘钥也无法解密出原文。</p><h3 id="对称加密算法的几种模式">3.1.2 对称加密算法的几种模式</h3><h4 id="分组密码模式">3.1.2.1 分组密码模式</h4><p>分组密码只能加密或者加密<strong>固定长度</strong>的数据，如果需要加密的明文长度超过了分组长度，则需要对明文进行分组，然后对各分组进行处理。</p><p>① <strong>ECB模式（电子密码本模式）</strong></p><p>ECB（Electronic CodeBook）模式将明文进行分组，然后针对每组单独进行加密，处理之后再将每组密文合并在一起，同理，解析也是一样的过程。</p><p>这种模式之下明文和密文一一对应，存在明显的缺点，所以实际中禁止使用。</p><p>② <strong>CBC模式（密码分组链接模式）</strong></p><p>CBC（Cipher Block Chaining）模式中，每组明文在加密前都要先与前面的一组密文进行异或操作，然后使用秘钥计算出密文。</p><p>同理，每组密文在解密时先使用秘钥计算出明文，然后与前面的一组密文进行异或运算，还原出最终明文。</p><p>在这种方式下，由于第一个明文分组前面没有密文分组，所以需要提前设置一个与分组长度相等的序列来代替密文分组，称之为初始化向量（Intialization Vector）。一般在发送端使用伪随机数生成器生成一个初始化的IV，然后通过某种方式发送给接收端。</p><p>所以，<strong>在CBC模式下，要想通信双方能正常加密解密，除了拥有相同的秘钥，还必须要拥有相同的初始化向量</strong>。</p><p>③ <strong>CRT模式（计数器模式）</strong></p><p>CRT模式中，使用与分组长度的计数值参与运算。通过对逐次累加的计数器值进行加密来生成密钥流，然后秘钥流与明文分组进行异或运算，得到密文分组。</p><p>同理，接收端解密的时候：通过对逐次累加的计数器值进行加密来生成密钥流，然后秘钥流与密文分组进行异或运算，得到明文分组。</p><p>④ 三种模式对比</p><p>相比之下：</p><ul><li>CTR模式中对于每个分组的加密/解密是独立的，可以进行并行计算，大幅提高计算效率；</li><li>CBC模式中密文分组的解密过程依赖于前一个密文分组，而CRT模式中每个密文分组的解密过程是独立的；</li><li>CTR模式中仅需要加密算法（对计数值加密）、不需要解密算法，而ECB和CBC模式都需要加密和解密算法；</li><li>CTR模式不需要对明文进行填充，而ECB和CBC模式需要；</li></ul><h4 id="PKCS7填充方案">3.1.2.2 PKCS7填充方案</h4><p>在EBC模式和CBC模式中，要求<strong>输入明文长度不是分组长度的整数倍时，要对明文进行填充</strong>。</p><p>常用的填充方案是 PKCS7 方案，规则如下：</p><h3 id="AES算法">3.1.3 AES算法</h3><p>AES算法的固定分组大小为128位（16字节），秘钥长度为128、192、256位。</p><p>AES算法中的S盒是唯一的非线性实现，解密过程中需要使用S盒完整字节替换，<strong>通常S盒计算通过查表法实现</strong>。</p><h3 id="mbedtls中提供的对称加密算法">3.1.4 mbedtls中提供的对称加密算法</h3><p>mbedtls中提供的对称加密算法如下：</p><ul><li>AES：支持ECB、CBC、CTR、CFB、GCM模式；</li><li>ARCFOUR(RC4)</li><li>Blowfish</li><li>Camellia</li><li>DES/3DES</li><li>XTEA</li></ul><h2 id="AES功能模块的配置与使用">3.2 AES功能模块的配置与使用</h2><h3 id="配置宏定义">3.2.1 配置宏定义</h3><h4 id="AES功能相关宏">3.2.1.1 AES功能相关宏</h4><p>mbedtls中提供的这些对称加密算法，每个都是一个独立的模块，由对应的宏控制是否开启，要使用AES相关功能，需要开启以下宏：</p><table><thead><tr><th>宏定义</th><th>说明</th></tr></thead><tbody><tr><td>MBEDTLS_AES_C</td><td>开启AES算法</td></tr><tr><td>MBEDTLS_CIPHER_MODE_CBC</td><td>开启CBC模式</td></tr><tr><td>MBEDTLS_CIPHER_MODE_CTR</td><td>开启CRT模式</td></tr><tr><td>MBEDTLS_AES_ROM_TABLES</td><td>开启预定义S盒</td></tr><tr><td>MBEDTLS_CIPHER_PADDING_PKCS7</td><td>开启PKCS7填充方案</td></tr></tbody></table><p>① <strong>MBEDTLS_AES_C</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_C</span></span><br></pre></td></tr></table></figure><p>② <strong>MBEDTLS_CIPHER_MODE_CBC</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_CIPHER_MODE_CBC</span></span><br></pre></td></tr></table></figure><p>③ <strong>MBEDTLS_CIPHER_MODE_CTR</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_CIPHER_MODE_CTR</span></span><br></pre></td></tr></table></figure><p>④ <strong>MBEDTLS_AES_ROM_TABLES</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_ROM_TABLES</span></span><br></pre></td></tr></table></figure><p>⑤<strong>MBEDTLS_CIPHER_PADDING_PKCS7</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_CIPHER_PADDING_PKCS7</span></span><br></pre></td></tr></table></figure><h4 id="cipher通用接口">3.2.1.2 cipher通用接口</h4><p>除了使用功能模块所提供的接口，mbedtls还提供了cipher通用接口，通过宏定义 <strong>MBEDTLS_CIPHER_C</strong> 开启：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_CIPHER_C</span></span><br></pre></td></tr></table></figure><h4 id="编写本实验配置文件">3.2.1.3 编写本实验配置文件</h4><p>编写<code>mbedtls_config_aes.h</code>文件，作为针对本实验的mbedtls配置文件，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MBEDTLS_CONFIG_AES_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MBEDTLS_CONFIG_AES_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* System support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_HAVE_ASM</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_HAVE_TIME</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed feature support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_CIPHER_MODE_CBC<span class="comment">// 开启CBC模式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_CIPHER_MODE_CTR<span class="comment">// 开启CRT模式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_NO_PLATFORM_ENTROPY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed modules */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_C<span class="comment">// 开启AES算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_ROM_TABLES<span class="comment">// 开启预定义S盒</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_CIPHER_PADDING_PKCS7<span class="comment">// 开启PKCS7填充方案</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_CIPHER_C</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/check_config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _MBEDTLS_CONFIG_CTR_DRBG_H_ */</span></span></span><br></pre></td></tr></table></figure><h3 id="cipher通用接口API说明">3.2.2 cipher通用接口API说明</h3><p>包含头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/cipher.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>① 初始化cipher结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_cipher_init</span><span class="params">( <span class="keyword">mbedtls_cipher_context_t</span> *ctx )</span></span>;</span><br></pre></td></tr></table></figure><p>② 通过加密算法名类型获取cipher信息结构体指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">mbedtls_cipher_info_t</span> *<span class="title">mbedtls_cipher_info_from_type</span><span class="params">( <span class="keyword">const</span> <span class="keyword">mbedtls_cipher_type_t</span> cipher_type )</span></span>;</span><br></pre></td></tr></table></figure><p>③ 设置cipher结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_cipher_setup</span><span class="params">( <span class="keyword">mbedtls_cipher_context_t</span> *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="keyword">mbedtls_cipher_info_t</span> *cipher_info )</span></span>;</span><br></pre></td></tr></table></figure><p>④ 获取算法名称：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">mbedtls_cipher_get_name</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">mbedtls_cipher_context_t</span> *ctx )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MBEDTLS_INTERNAL_VALIDATE_RET( ctx != <span class="literal">NULL</span>, <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span>( ctx-&gt;cipher_info == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ctx-&gt;cipher_info-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑤ 获取算法分组长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mbedtls_cipher_get_block_size</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">mbedtls_cipher_context_t</span> *ctx )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MBEDTLS_INTERNAL_VALIDATE_RET( ctx != <span class="literal">NULL</span>, <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span>( ctx-&gt;cipher_info == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ctx-&gt;cipher_info-&gt;block_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑥ 设置解密秘钥接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_cipher_setkey</span><span class="params">( <span class="keyword">mbedtls_cipher_context_t</span> *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> key_bitlen,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> <span class="keyword">mbedtls_operation_t</span> operation )</span></span>;</span><br></pre></td></tr></table></figure><p>⑦ 设置iv接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_cipher_set_iv</span><span class="params">( <span class="keyword">mbedtls_cipher_context_t</span> *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">size_t</span> iv_len )</span></span>;</span><br></pre></td></tr></table></figure><p>⑧ cipher更新接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_cipher_update</span><span class="params">( <span class="keyword">mbedtls_cipher_context_t</span> *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *input,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">size_t</span> ilen, <span class="keyword">unsigned</span> <span class="keyword">char</span> *output,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">size_t</span> *olen )</span></span>;</span><br></pre></td></tr></table></figure><p>⑨ cipher完成接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_cipher_finish</span><span class="params">( <span class="keyword">mbedtls_cipher_context_t</span> *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> <span class="keyword">char</span> *output, <span class="keyword">size_t</span> *olen )</span></span>;</span><br></pre></td></tr></table></figure><p>⑩ 释放cipher结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_cipher_free</span><span class="params">( <span class="keyword">mbedtls_cipher_context_t</span> *ctx )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="编写测试函数">3.2.3 编写测试函数</h3><p>新建demo文件<code>mbedtls_aes_test.c</code>，编写以下测试内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MBEDTLS_CONFIG_FILE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> MBEDTLS_CONFIG_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MBEDTLS_CIPHER_C)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/cipher.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private Key */</span></span><br><span class="line"><span class="keyword">uint8_t</span> key[<span class="number">16</span>] = &#123;</span><br><span class="line">    <span class="number">0x06</span>, <span class="number">0xa9</span>, <span class="number">0x21</span>, <span class="number">0x40</span>, <span class="number">0x36</span>, <span class="number">0xb8</span>, <span class="number">0xa1</span>, <span class="number">0x5b</span>,</span><br><span class="line">    <span class="number">0x51</span>, <span class="number">0x2e</span>, <span class="number">0x03</span>, <span class="number">0xd5</span>, <span class="number">0x34</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x06</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Intialization Vector */</span></span><br><span class="line"><span class="keyword">uint8_t</span> iv[<span class="number">16</span>] = &#123;</span><br><span class="line">    <span class="number">0x3d</span>, <span class="number">0xaf</span>, <span class="number">0xba</span>, <span class="number">0x42</span>, <span class="number">0x9d</span>, <span class="number">0x9e</span>, <span class="number">0xb4</span>, <span class="number">0x30</span>,</span><br><span class="line">    <span class="number">0xb4</span>, <span class="number">0x22</span>, <span class="number">0xda</span>, <span class="number">0x80</span>, <span class="number">0x2c</span>, <span class="number">0x9f</span>, <span class="number">0xac</span>, <span class="number">0x41</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump_buf</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf:&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s%02X%s&quot;</span>, i % <span class="number">16</span> == <span class="number">0</span> ? <span class="string">&quot;\r\n\t&quot;</span> : <span class="string">&quot; &quot;</span>, </span><br><span class="line">                           buf[i], </span><br><span class="line">                           i == len - <span class="number">1</span> ? <span class="string">&quot;\r\n&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aes_test</span><span class="params">(<span class="keyword">mbedtls_cipher_type_t</span> cipher_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">int</span> olen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> output_buf[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *input = <span class="string">&quot;creekwater is learning aes of mbedtls.&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mbedtls_cipher_context_t</span> ctx;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">mbedtls_cipher_info_t</span> *info;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 1. 初始化cipher context结构体 */</span></span><br><span class="line">    mbedtls_cipher_init(&amp;ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 2. 从类型获取cipher info */</span></span><br><span class="line">    info = mbedtls_cipher_info_from_type(cipher_type);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 3. 设置cipher context结构体 */</span></span><br><span class="line">    ret = mbedtls_cipher_setup(&amp;ctx, info);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 4. 设置key */</span></span><br><span class="line">    ret = mbedtls_cipher_setkey(&amp;ctx, key, <span class="keyword">sizeof</span>(key) * <span class="number">8</span>, MBEDTLS_ENCRYPT);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 5. 设置iv */</span></span><br><span class="line">    ret = mbedtls_cipher_set_iv(&amp;ctx, iv, <span class="keyword">sizeof</span>(iv));</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 6. 更新 cipher */</span></span><br><span class="line">    ret = mbedtls_cipher_update(&amp;ctx, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)input, <span class="built_in">strlen</span>(input), output_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    olen += len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 7. 结束 cipher */</span></span><br><span class="line">    ret = mbedtls_cipher_finish(&amp;ctx, output_buf, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    olen += len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 打印结果 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\nsource_context:%s\r\n&quot;</span>, input);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cipher name:%s block size is:%d\r\n&quot;</span>, mbedtls_cipher_get_name(&amp;ctx), mbedtls_cipher_get_block_size(&amp;ctx));</span><br><span class="line">    dump_buf(output_buf, olen);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>:</span><br><span class="line">    <span class="comment">/* 8. 释放 cipher 结构体 */</span></span><br><span class="line">    mbedtls_cipher_free(&amp;ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MBEDTLS_CIPHER_C */</span></span></span><br></pre></td></tr></table></figure><h3 id="测试结果">3.2.4 测试结果</h3><p>从结果可以看到：</p><ul><li>AES算法分组大小为16个字节（128位）；</li><li>CBC模式下，AES算法会将55个字节的明文加密为64个字节；</li><li>CRT模式下，AES算法加密之后的密文长度仍然是55个字节，和明文长度相同；</li></ul><h1 id="四、消息认证码">4 四、消息认证码</h1><h2 id="什么是消息认证码">4.1 什么是消息认证码</h2><p>消息认证码（Message Authentication Code）可<strong>用来检查消息的完整性和消息来源的可靠性</strong>。</p><p>消息认证码算法的输入为任意长度的消息和通信双方共享的秘钥，消息认证码的输出为固定长度的数据，该输出数据称为MAC值、Tag值、T值。</p><h2 id="消息认证码的实现方式">4.2 消息认证码的实现方式</h2><h3 id="基于单向散列算法实现">4.2.1 基于单向散列算法实现</h3><p>这类实现称为<strong>HMAC</strong>，比如HMAC-SHA1、HMAC-SHA256等。因为单向散列算法无法验证消息来源的可靠性，所以不能直接用于生成消息认证码。</p><p>另外，在HMAC算法中，<strong>通信双方共享秘钥没有长度限制，明文也没有长度限制，但是最后生成的消息认证码长度是固定的</strong>。</p><p>比如基于SHA256算法的HAMC算法，因为SHA256计算出的消息摘要是256字节，32个字节，所以最后生成的消息认证码长度也是32个字节固定长度。</p><h3 id="基于分组加密算法实现">4.2.2 基于分组加密算法实现</h3><p>比如将CBC分组加密结果的最后一个分组作为消息认证码的<strong>CBC-MAC</strong>算法。</p><p>还有通过共享秘钥派生出两个中间秘钥的<strong>CMAC</strong>算法，安全性更高。</p><h3 id="认证加密算法实现">4.2.3 认证加密算法实现</h3><p>认证加密算法在通信过程中提供数据机密性和完整性的密码算法，是对称加密算法（eg. AES）和消息认证码的结合，典型实现包括<strong>GCM</strong>、<strong>CCM</strong>等。</p><p>CCM认证加密过程对明文进行两次处理，第一次使用CBC-MAC计算消息认证码，第二次使用CRT模式将消息认证码（明文）加密。</p><p>GCM认证加密过程和CCM类似，只不过第一次计算使用的是GHASH算法，第二次计算使用的是GCTR算法。</p><p>另外，<strong>GCM的消息认证码长度只能为16字节，而CCM模式的消息认证码长度最小为4字节、最大为16字节</strong>。</p><h2 id="mbedtls中的消息认证码实现">4.3 mbedtls中的消息认证码实现</h2><p>mbedtls中提供了HMAC计算接口和GCM计算接口。</p><h2 id="配置宏-1">4.4 配置宏</h2><p>开启一种单向散列函数功能和MD通用接口即可：</p><table><thead><tr><th>宏定义</th><th>说明</th></tr></thead><tbody><tr><td>MBEDTLS_MD_C</td><td>开启MD通用接口</td></tr><tr><td>MBEDTLS_SHA256_C</td><td>开启SHA256单向散列算法</td></tr></tbody></table><p>新建一个针对本实验的配置文件<code>mbedtls_config_hmac.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MBEDTLS_CONFIG_SHA_X_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MBEDTLS_CONFIG_SHA_X_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* System support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_HAVE_ASM</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_HAVE_TIME</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed feature support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_NO_PLATFORM_ENTROPY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed modules */</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_MD2_C</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_MD4_C</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_MD5_C</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_SHA1_C</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_SHA224_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA256_C</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_SHA384_C</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_SHA512_C</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* enable generic message digest wrappers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_MD_C</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/check_config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _MBEDTLS_CONFIG_SHA_X_H_ */</span></span></span><br></pre></td></tr></table></figure><p>cmakefile.txt中添加<code>CPPFLAGS += -DMBEDTLS_CONFIG_FILE=&#39;&quot;mbedtls_config_hmac.h&quot;&#39;</code></p><h2 id="HMAC功能模块API说明">4.5 HMAC功能模块API说明</h2><p>① hmac启动接口（完成秘钥、ipad、opad计算）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_md_hmac_starts</span><span class="params">( <span class="keyword">mbedtls_md_context_t</span> *ctx, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *key,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">size_t</span> keylen )</span></span>;</span><br></pre></td></tr></table></figure><p>② hmac更新接口（处理输入数据）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_md_hmac_update</span><span class="params">( <span class="keyword">mbedtls_md_context_t</span> *ctx, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *input,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">size_t</span> ilen )</span></span>;</span><br></pre></td></tr></table></figure><p>③ hmac完成接口（输出消息认证码）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_md_hmac_finish</span><span class="params">( <span class="keyword">mbedtls_md_context_t</span> *ctx, <span class="keyword">unsigned</span> <span class="keyword">char</span> *output)</span></span>;</span><br></pre></td></tr></table></figure><p>④ 错误码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE                -0x5080  <span class="comment">/**&lt; The selected feature is not available. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_MD_BAD_INPUT_DATA                     -0x5100  <span class="comment">/**&lt; Bad input parameters to function. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_MD_ALLOC_FAILED                       -0x5180  <span class="comment">/**&lt; Failed to allocate memory. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_MD_FILE_IO_ERROR                      -0x5200  <span class="comment">/**&lt; Opening or reading of file failed. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MBEDTLS_ERR_MD_HW_ACCEL_FAILED is deprecated and should not be used. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_MD_HW_ACCEL_FAILED                    -0x5280  <span class="comment">/**&lt; MD hardware accelerator failed. */</span></span></span><br></pre></td></tr></table></figure><p>特别注意，与计算单向散列值不同，<strong>在计算消息认证码的时候要在设置时表明使用HMAC</strong>，也就是 mbedtls_md_setup 函数的第三个参数要设置为非零值，通常设为1即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_md_setup</span><span class="params">( <span class="keyword">mbedtls_md_context_t</span> *ctx, <span class="keyword">const</span> <span class="keyword">mbedtls_md_info_t</span> *md_info, <span class="keyword">int</span> hmac )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="编写测试函数-1">4.6 编写测试函数</h2><p>新建文件<code>mbedtls_hmac_test.c</code>，编写如下测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MBEDTLS_CONFIG_FILE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> MBEDTLS_CONFIG_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MBEDTLS_MD_C)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/md.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_hmac_test</span><span class="params">(<span class="keyword">mbedtls_md_type_t</span> md_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len, i;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *key     = <span class="string">&quot;mculover666&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> hmac[<span class="number">32</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mbedtls_md_context_t</span> ctx;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">mbedtls_md_info_t</span> *info;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;message is:%s\r\n&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 初始化 mbedtls_md_context_t 结构体 */</span></span><br><span class="line">    mbedtls_md_init(&amp;ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 2. get md info structure pointer */</span></span><br><span class="line">    info = mbedtls_md_info_from_type(md_type);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 3. setup md info structure */</span></span><br><span class="line">    ret = mbedtls_md_setup(&amp;ctx, info, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 4. start */</span></span><br><span class="line">    ret = mbedtls_md_hmac_starts(&amp;ctx, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)key, <span class="built_in">strlen</span>(key));</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* 5. update */</span></span><br><span class="line">    ret = mbedtls_md_hmac_update(&amp;ctx, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)message, <span class="built_in">strlen</span>(message));</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/* 6. finish */</span></span><br><span class="line">    ret = mbedtls_md_hmac_finish(&amp;ctx, hmac);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* show */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s hmac context is:[&quot;</span>, mbedtls_md_get_name(info));</span><br><span class="line">    len= mbedtls_md_get_size(info);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%02x&quot;</span>, hmac[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>:</span><br><span class="line">    <span class="comment">/* 7. free */</span></span><br><span class="line">    mbedtls_md_free(&amp;ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MBEDTLS_MD_C */</span></span></span><br></pre></td></tr></table></figure><h2 id="测试结果-1">4.7 测试结果</h2><p>在main.c中声明该测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private user code ---------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/md.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_hmac_test</span><span class="params">(<span class="keyword">mbedtls_md_type_t</span> md_type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure><p>然后在main函数中调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 3. hamc test */</span></span><br><span class="line">mbedtls_hmac_test(MBEDTLS_MD_SHA256);</span><br></pre></td></tr></table></figure><p>编译、下载、测试结果如图：</p><p>在MDK中配置：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20200926151128537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><h2 id="GCM功能模块相关的API说明">4.8 GCM功能模块相关的API说明</h2><p>① cipher认证加密：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_cipher_auth_encrypt</span><span class="params">( <span class="keyword">mbedtls_cipher_context_t</span> *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv, <span class="keyword">size_t</span> iv_len,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *ad, <span class="keyword">size_t</span> ad_len,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *input, <span class="keyword">size_t</span> ilen,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">char</span> *output, <span class="keyword">size_t</span> *olen,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">char</span> *tag, <span class="keyword">size_t</span> tag_len )</span></span>;</span><br></pre></td></tr></table></figure><p>② cipher认证解密</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_cipher_auth_decrypt</span><span class="params">( <span class="keyword">mbedtls_cipher_context_t</span> *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv, <span class="keyword">size_t</span> iv_len,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *ad, <span class="keyword">size_t</span> ad_len,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *input, <span class="keyword">size_t</span> ilen,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">char</span> *output, <span class="keyword">size_t</span> *olen,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *tag, <span class="keyword">size_t</span> tag_len )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="编写测试代码-1">4.9 编写测试代码</h2><p>新建文件<code>mbedtls_config_gcm.c</code>，编写测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MBEDTLS_CONFIG_FILE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> MBEDTLS_CONFIG_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MBEDTLS_GCM_C)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/cipher.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* source context */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> input[<span class="number">16</span>] = &#123;</span><br><span class="line">    <span class="number">0xc3</span>, <span class="number">0xb3</span>, <span class="number">0xc4</span>, <span class="number">0x1f</span>, <span class="number">0x11</span>, <span class="number">0x3a</span>, <span class="number">0x31</span>, <span class="number">0xb7</span>, </span><br><span class="line">    <span class="number">0x3d</span>, <span class="number">0x9a</span>, <span class="number">0x5c</span>, <span class="number">0xd4</span>, <span class="number">0x32</span>, <span class="number">0x10</span>, <span class="number">0x30</span>, <span class="number">0x69</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Private Key */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> key[<span class="number">16</span>] = &#123;</span><br><span class="line">    <span class="number">0xc9</span>, <span class="number">0x39</span>, <span class="number">0xcc</span>, <span class="number">0x13</span>, <span class="number">0x39</span>, <span class="number">0x7c</span>, <span class="number">0x1d</span>, <span class="number">0x37</span>,</span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0x6a</span>, <span class="number">0xe0</span>, <span class="number">0xe1</span>, <span class="number">0xcb</span>, <span class="number">0x7c</span>, <span class="number">0x42</span>, <span class="number">0x3c</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Intialization Vector */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> iv[<span class="number">12</span>] = &#123;</span><br><span class="line">    <span class="number">0xb3</span>, <span class="number">0xd8</span>, <span class="number">0xcc</span>, <span class="number">0x01</span>, </span><br><span class="line">    <span class="number">0x7c</span>, <span class="number">0xbb</span>, <span class="number">0x89</span>, <span class="number">0xb3</span>,</span><br><span class="line">    <span class="number">0x9e</span>, <span class="number">0x0f</span>, <span class="number">0x67</span>, <span class="number">0xe2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The additional data to authenticate */</span></span><br><span class="line"><span class="keyword">uint8_t</span> add[<span class="number">16</span>] = &#123;</span><br><span class="line">    <span class="number">0x24</span>, <span class="number">0x82</span>, <span class="number">0x56</span>, <span class="number">0x02</span>, <span class="number">0xbd</span>, <span class="number">0x12</span>, <span class="number">0xa9</span>, <span class="number">0x84</span>, </span><br><span class="line">    <span class="number">0xe0</span>, <span class="number">0x09</span>, <span class="number">0x2d</span>, <span class="number">0x3e</span>, <span class="number">0x44</span>, <span class="number">0x8e</span>, <span class="number">0xda</span>, <span class="number">0x5f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump_buf</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s%02X%s&quot;</span>, i % <span class="number">16</span> == <span class="number">0</span> ? <span class="string">&quot;\r\n\t&quot;</span> : <span class="string">&quot; &quot;</span>, </span><br><span class="line">                           buf[i], </span><br><span class="line">                           i == len - <span class="number">1</span> ? <span class="string">&quot;\r\n&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcm_test</span><span class="params">(<span class="keyword">mbedtls_cipher_type_t</span> cipher_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">int</span> olen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> output_buf[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> tag_buf[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> decrypt_out_buf[<span class="number">16</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mbedtls_cipher_context_t</span> ctx;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">mbedtls_cipher_info_t</span> *info;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 1. init cipher structuer */</span></span><br><span class="line">    mbedtls_cipher_init(&amp;ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 2. get info structuer from type */</span></span><br><span class="line">    info = mbedtls_cipher_info_from_type(cipher_type);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 3. setup cipher structuer */</span></span><br><span class="line">    ret = mbedtls_cipher_setup(&amp;ctx, info);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 4. set encrypt key */</span></span><br><span class="line">    ret = mbedtls_cipher_setkey(&amp;ctx, key, <span class="keyword">sizeof</span>(key) * <span class="number">8</span>, MBEDTLS_ENCRYPT);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 5. auth encrypt */</span></span><br><span class="line">    ret = mbedtls_cipher_auth_encrypt(&amp;ctx, </span><br><span class="line">                                      iv, <span class="keyword">sizeof</span>(iv), add, <span class="keyword">sizeof</span>(add), </span><br><span class="line">                                      (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)input, <span class="keyword">sizeof</span>(input), </span><br><span class="line">                                      output_buf, &amp;len, tag_buf, <span class="keyword">sizeof</span>(tag_buf));</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    olen += len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* show */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cipher name:%s block size is:%d\r\n&quot;</span>, mbedtls_cipher_get_name(&amp;ctx), mbedtls_cipher_get_block_size(&amp;ctx));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\noutput_buf:\r\n&quot;</span>);</span><br><span class="line">    dump_buf((<span class="keyword">uint8_t</span> *)output_buf, olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\ntag_buf:\r\n&quot;</span>);</span><br><span class="line">    dump_buf(tag_buf, <span class="keyword">sizeof</span>(tag_buf));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 6. set decrypt key */</span></span><br><span class="line">    ret = mbedtls_cipher_setkey(&amp;ctx, key, <span class="keyword">sizeof</span>(key) * <span class="number">8</span>, MBEDTLS_DECRYPT);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 7. auth decrypt */</span></span><br><span class="line">    olen = <span class="number">0</span>;</span><br><span class="line">    len  = <span class="number">0</span>;</span><br><span class="line">    ret = mbedtls_cipher_auth_decrypt(&amp;ctx, </span><br><span class="line">                                      iv, <span class="keyword">sizeof</span>(iv), add, <span class="keyword">sizeof</span>(add), </span><br><span class="line">                                      (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)output_buf, <span class="keyword">sizeof</span>(output_buf), </span><br><span class="line">                                      decrypt_out_buf, &amp;len, tag_buf, <span class="keyword">sizeof</span>(tag_buf));</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    olen += len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* show */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cipher name:%s block size is:%d\r\n&quot;</span>, mbedtls_cipher_get_name(&amp;ctx), mbedtls_cipher_get_block_size(&amp;ctx));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\ndecrypt_out_buf:\r\n&quot;</span>);</span><br><span class="line">    dump_buf((<span class="keyword">uint8_t</span> *)decrypt_out_buf, olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\ntag_buf:\r\n&quot;</span>);</span><br><span class="line">    dump_buf(tag_buf, <span class="keyword">sizeof</span>(tag_buf));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>:</span><br><span class="line">    <span class="comment">/* 8. free cipher structure */</span></span><br><span class="line">    mbedtls_cipher_free(&amp;ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MBEDTLS_CIPHER_C */</span></span></span><br></pre></td></tr></table></figure><h2 id="测试结果-2">4.10 测试结果</h2><p>在main.c 中声明该外部函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private user code ---------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/cipher.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcm_test</span><span class="params">(<span class="keyword">mbedtls_cipher_type_t</span> cipher_type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure><p>接着在main函数中调用测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 4.gcm test */</span></span><br><span class="line">gcm_test(MBEDTLS_CIPHER_AES_128_GCM);</span><br></pre></td></tr></table></figure><p>编译、下载，测试结果为：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20200926151709761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><h1 id="五、非对称加密算法的配置与使用（RSA算法）">5 五、非对称加密算法的配置与使用（RSA算法）</h1><h2 id="非对称加密算法——RSA">5.1 非对称加密算法——RSA</h2><h3 id="对称加密算法和非对称加密算法">5.1.1 对称加密算法和非对称加密算法</h3><p>对称加密算法，比如AES算法，在发送端（加密）和接收端（解密）使用相同的一份秘钥，称为共享秘钥。</p><p>非对称加密算法，比如RSA算法，在加密使用<strong>公钥</strong>，而在解密时使用<strong>私钥</strong>。</p><h3 id="RSA算法">5.1.2 RSA算法</h3><p>RSA算法是一种常用的非对称加密算法。</p><p>RSA算法主要包括三个过程：</p><ul><li>生成秘钥对</li><li>使用公钥加密明文</li><li>使用私钥解密密文</li></ul><h3 id="RSA加速技术">5.1.3 RSA加速技术</h3><p>RSA算法在计算过程中存在较多的取模运算和幂运算，计算速度比对称加密算法要慢，所以不适合对大量数据进行加密和解密，在实际中常用于加密或解密小数据片段。</p><p>RSA公钥加密过程可使用短公开指数进行快速计算，而RSA私钥解密过程可使用中国剩余定理（CRT）进行加速执行。</p><h3 id="RSA填充方法">5.1.4 RSA填充方法</h3><p>RSA加密结果是<strong>确定的</strong>。当公钥确定的时候，一段明文总是会加密的到对应的密文，这样未免存在安全隐患。</p><p>实际使用RSA算法中需要包含填充方案，在计算之前会对明文进行随机注入，这样在公钥和明文相同的情况下，也不会生成相同的秘文。</p><p>常用的RSA填充方案有两种：RSAES-OAEP（推荐使用）和RSAES-PKCS1V1_5（较早、不推荐使用）。</p><h2 id="RSA功能模块的配置与使用">5.2 RSA功能模块的配置与使用</h2><h3 id="配置宏-2">5.2.1 配置宏</h3><p>使用RSA功能需要提前开启伪随机数生成器（依赖AES算法、SHA256算法、MD通用接口），其中伪随机数生成器的硬件适配移植实现已经讲述，请参考对应的第二篇博客，不再赘述。</p><p>综合上述，本实验中需要开启的宏如下表：</p><table><thead><tr><th>宏定义</th><th>功能</th></tr></thead><tbody><tr><td>MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES</td><td>不使用默认熵源<strong>（如果已有、要屏蔽该宏）</strong></td></tr><tr><td>MBEDTLS_NO_PLATFORM_ENTROPY</td><td>不使用系统内置熵源</td></tr><tr><td>MBEDTLS_AES_C</td><td>使用AES算法</td></tr><tr><td>MBEDTLS_ENTROPY_C</td><td>使能熵源模块</td></tr><tr><td>MBEDTLS_CTR_DRBG_C</td><td>使能随机数模块</td></tr><tr><td>MBEDTLS_SHA256_C</td><td>使能SHA256算法</td></tr><tr><td>MBEDTLS_MD_C</td><td>开启MD通用接口</td></tr><tr><td>MBEDTLS_AES_ROM_TABLES</td><td>使能预定义S盒（节约内存空间）</td></tr><tr><td>MBEDTLS_BIGNUM_C</td><td>开启大数运算</td></tr><tr><td>MBEDTLS_GENPRIME</td><td>开启生成素数</td></tr><tr><td>MBEDTLS_OID_C</td><td>开启OID数据结构模块</td></tr><tr><td>MBEDTLS_RSA_C</td><td>开启RSA算法</td></tr><tr><td>MBEDTLS_PKCS1_V21</td><td>开启PKCS#1 v2.1填充方案（OAEP）</td></tr></tbody></table><p>下面补充几个第一次出现宏的定义。</p><p>① <strong>MBEDTLS_BIGNUM_C</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \def MBEDTLS_BIGNUM_C</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Enable the multi-precision integer library.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Module:  library/bignum.c</span></span><br><span class="line"><span class="comment"> * Caller:  library/dhm.c</span></span><br><span class="line"><span class="comment"> *          library/ecp.c</span></span><br><span class="line"><span class="comment"> *          library/ecdsa.c</span></span><br><span class="line"><span class="comment"> *          library/rsa.c</span></span><br><span class="line"><span class="comment"> *          library/rsa_internal.c</span></span><br><span class="line"><span class="comment"> *          library/ssl_tls.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This module is required for RSA, DHM and ECC (ECDH, ECDSA) support.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_BIGNUM_C</span></span><br></pre></td></tr></table></figure><p>② <strong>MBEDTLS_GENPRIME</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \def MBEDTLS_GENPRIME</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Enable the prime-number generation code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Requires: MBEDTLS_BIGNUM_C</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_GENPRIME</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><p>③ <strong>MBEDTLS_OID_C</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \def MBEDTLS_OID_C</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Enable the OID database.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Module:  library/oid.c</span></span><br><span class="line"><span class="comment"> * Caller:  library/asn1write.c</span></span><br><span class="line"><span class="comment"> *          library/pkcs5.c</span></span><br><span class="line"><span class="comment"> *          library/pkparse.c</span></span><br><span class="line"><span class="comment"> *          library/pkwrite.c</span></span><br><span class="line"><span class="comment"> *          library/rsa.c</span></span><br><span class="line"><span class="comment"> *          library/x509.c</span></span><br><span class="line"><span class="comment"> *          library/x509_create.c</span></span><br><span class="line"><span class="comment"> *          library/x509_crl.c</span></span><br><span class="line"><span class="comment"> *          library/x509_crt.c</span></span><br><span class="line"><span class="comment"> *          library/x509_csr.c</span></span><br><span class="line"><span class="comment"> *          library/x509write_crt.c</span></span><br><span class="line"><span class="comment"> *          library/x509write_csr.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This modules translates between OIDs and internal values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_OID_C</span></span><br></pre></td></tr></table></figure><p>④ <strong>MBEDTLS_RSA_C</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \def MBEDTLS_RSA_C</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Enable the RSA public-key cryptosystem.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Module:  library/rsa.c</span></span><br><span class="line"><span class="comment"> *          library/rsa_internal.c</span></span><br><span class="line"><span class="comment"> * Caller:  library/ssl_cli.c</span></span><br><span class="line"><span class="comment"> *          library/ssl_srv.c</span></span><br><span class="line"><span class="comment"> *          library/ssl_tls.c</span></span><br><span class="line"><span class="comment"> *          library/x509.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This module is used by the following key exchanges:</span></span><br><span class="line"><span class="comment"> *      RSA, DHE-RSA, ECDHE-RSA, RSA-PSK</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Requires: MBEDTLS_BIGNUM_C, MBEDTLS_OID_C</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_RSA_C</span></span><br></pre></td></tr></table></figure><p>⑤ <strong>MBEDTLS_PKCS1_V21</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \def MBEDTLS_PKCS1_V21</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Enable support for PKCS#1 v2.1 encoding.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Requires: MBEDTLS_MD_C, MBEDTLS_RSA_C</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This enables support for RSAES-OAEP and RSASSA-PSS operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_PKCS1_V21</span></span><br></pre></td></tr></table></figure><p>编辑针对本实验的配置文件<code>mbedtls_config_rsa.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MBEDTLS_CONFIG_RSA_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MBEDTLS_CONFIG_RSA_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* System support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_HAVE_ASM</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_HAVE_TIME</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed feature support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ENTROPY_HARDWARE_ALT</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_NO_PLATFORM_ENTROPY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed modules */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_ROM_TABLES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_CTR_DRBG_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ENTROPY_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA256_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_MD_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_BIGNUM_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_GENPRIME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_OID_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_RSA_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_PKCS1_V21</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/check_config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _MBEDTLS_CONFIG_RSA_H_ */</span></span></span><br></pre></td></tr></table></figure><p>在MDK配置mbedtls使用该配置文件：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20200927110342915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><h3 id="RSA功能模块API说明">5.2.2 RSA功能模块API说明</h3><p>使用该功能模块需要包含头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/rsa.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>① 初始化RSA结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          This function initializes an RSA context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           Set padding to #MBEDTLS_RSA_PKCS_V21 for the RSAES-OAEP</span></span><br><span class="line"><span class="comment"> *                 encryption scheme and the RSASSA-PSS signature scheme.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           The \p hash_id parameter is ignored when using</span></span><br><span class="line"><span class="comment"> *                 #MBEDTLS_RSA_PKCS_V15 padding.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           The choice of padding mode is strictly enforced for private key</span></span><br><span class="line"><span class="comment"> *                 operations, since there might be security concerns in</span></span><br><span class="line"><span class="comment"> *                 mixing padding modes. For public key operations it is</span></span><br><span class="line"><span class="comment"> *                 a default value, which can be overridden by calling specific</span></span><br><span class="line"><span class="comment"> *                 \c rsa_rsaes_xxx or \c rsa_rsassa_xxx functions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           The hash selected in \p hash_id is always used for OEAP</span></span><br><span class="line"><span class="comment"> *                 encryption. For PSS signatures, it is always used for</span></span><br><span class="line"><span class="comment"> *                 making signatures, but can be overridden for verifying them.</span></span><br><span class="line"><span class="comment"> *                 If set to #MBEDTLS_MD_NONE, it is always overridden.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx      The RSA context to initialize. This must not be \c NULL.</span></span><br><span class="line"><span class="comment"> * \param padding  The padding mode to use. This must be either</span></span><br><span class="line"><span class="comment"> *                 #MBEDTLS_RSA_PKCS_V15 or #MBEDTLS_RSA_PKCS_V21.</span></span><br><span class="line"><span class="comment"> * \param hash_id  The hash identifier of ::mbedtls_md_type_t type, if</span></span><br><span class="line"><span class="comment"> *                 \p padding is #MBEDTLS_RSA_PKCS_V21. It is unused</span></span><br><span class="line"><span class="comment"> *                 otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_rsa_init</span><span class="params">( mbedtls_rsa_context *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> padding,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> hash_id )</span></span>;</span><br></pre></td></tr></table></figure><p>② RSA生成秘钥对：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          This function generates an RSA keypair.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           mbedtls_rsa_init() must be called before this function,</span></span><br><span class="line"><span class="comment"> *                 to set up the RSA context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx      The initialized RSA context used to hold the key.</span></span><br><span class="line"><span class="comment"> * \param f_rng    The RNG function to be used for key generation.</span></span><br><span class="line"><span class="comment"> *                 This must not be \c NULL.</span></span><br><span class="line"><span class="comment"> * \param p_rng    The RNG context to be passed to \p f_rng.</span></span><br><span class="line"><span class="comment"> *                 This may be \c NULL if \p f_rng doesn&#x27;t need a context.</span></span><br><span class="line"><span class="comment"> * \param nbits    The size of the public key in bits.</span></span><br><span class="line"><span class="comment"> * \param exponent The public exponent to use. For example, \c 65537.</span></span><br><span class="line"><span class="comment"> *                 This must be odd and greater than \c 1.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return         \c 0 on success.</span></span><br><span class="line"><span class="comment"> * \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_rsa_gen_key</span><span class="params">( mbedtls_rsa_context *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> (*f_rng)(<span class="keyword">void</span> *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">void</span> *p_rng,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">int</span> nbits, <span class="keyword">int</span> exponent )</span></span>;</span><br></pre></td></tr></table></figure><p>③ RSA加密操作，通过参数指定公钥加密：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          This function adds the message padding, then performs an RSA</span></span><br><span class="line"><span class="comment"> *                 operation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                 It is the generic wrapper for performing a PKCS#1 encryption</span></span><br><span class="line"><span class="comment"> *                 operation using the \p mode from the context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \deprecated     It is deprecated and discouraged to call this function</span></span><br><span class="line"><span class="comment"> *                 in #MBEDTLS_RSA_PRIVATE mode. Future versions of the library</span></span><br><span class="line"><span class="comment"> *                 are likely to remove the \p mode argument and have it</span></span><br><span class="line"><span class="comment"> *                 implicitly set to #MBEDTLS_RSA_PUBLIC.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           Alternative implementations of RSA need not support</span></span><br><span class="line"><span class="comment"> *                 mode being set to #MBEDTLS_RSA_PRIVATE and might instead</span></span><br><span class="line"><span class="comment"> *                 return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx      The initialized RSA context to use.</span></span><br><span class="line"><span class="comment"> * \param f_rng    The RNG to use. It is mandatory for PKCS#1 v2.1 padding</span></span><br><span class="line"><span class="comment"> *                 encoding, and for PKCS#1 v1.5 padding encoding when used</span></span><br><span class="line"><span class="comment"> *                 with \p mode set to #MBEDTLS_RSA_PUBLIC. For PKCS#1 v1.5</span></span><br><span class="line"><span class="comment"> *                 padding encoding and \p mode set to #MBEDTLS_RSA_PRIVATE,</span></span><br><span class="line"><span class="comment"> *                 it is used for blinding and should be provided in this</span></span><br><span class="line"><span class="comment"> *                 case; see mbedtls_rsa_private() for more.</span></span><br><span class="line"><span class="comment"> * \param p_rng    The RNG context to be passed to \p f_rng. May be</span></span><br><span class="line"><span class="comment"> *                 \c NULL if \p f_rng is \c NULL or if \p f_rng doesn&#x27;t</span></span><br><span class="line"><span class="comment"> *                 need a context argument.</span></span><br><span class="line"><span class="comment"> * \param mode     The mode of operation. This must be either</span></span><br><span class="line"><span class="comment"> *                 #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE (deprecated).</span></span><br><span class="line"><span class="comment"> * \param ilen     The length of the plaintext in Bytes.</span></span><br><span class="line"><span class="comment"> * \param input    The input data to encrypt. This must be a readable</span></span><br><span class="line"><span class="comment"> *                 buffer of size \p ilen Bytes. It may be \c NULL if</span></span><br><span class="line"><span class="comment"> *                 `ilen == 0`.</span></span><br><span class="line"><span class="comment"> * \param output   The output buffer. This must be a writable buffer</span></span><br><span class="line"><span class="comment"> *                 of length \c ctx-&gt;len Bytes. For example, \c 256 Bytes</span></span><br><span class="line"><span class="comment"> *                 for an 2048-bit RSA modulus.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return         \c 0 on success.</span></span><br><span class="line"><span class="comment"> * \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_rsa_pkcs1_encrypt</span><span class="params">( mbedtls_rsa_context *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> (*f_rng)(<span class="keyword">void</span> *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *p_rng,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> mode, <span class="keyword">size_t</span> ilen,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *input,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">char</span> *output )</span></span>;</span><br></pre></td></tr></table></figure><p>④ RSA解密操作，通过指定私钥解密：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          This function performs an RSA operation, then removes the</span></span><br><span class="line"><span class="comment"> *                 message padding.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                 It is the generic wrapper for performing a PKCS#1 decryption</span></span><br><span class="line"><span class="comment"> *                 operation using the \p mode from the context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           The output buffer length \c output_max_len should be</span></span><br><span class="line"><span class="comment"> *                 as large as the size \p ctx-&gt;len of \p ctx-&gt;N (for example,</span></span><br><span class="line"><span class="comment"> *                 128 Bytes if RSA-1024 is used) to be able to hold an</span></span><br><span class="line"><span class="comment"> *                 arbitrary decrypted message. If it is not large enough to</span></span><br><span class="line"><span class="comment"> *                 hold the decryption of the particular ciphertext provided,</span></span><br><span class="line"><span class="comment"> *                 the function returns \c MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \deprecated     It is deprecated and discouraged to call this function</span></span><br><span class="line"><span class="comment"> *                 in #MBEDTLS_RSA_PUBLIC mode. Future versions of the library</span></span><br><span class="line"><span class="comment"> *                 are likely to remove the \p mode argument and have it</span></span><br><span class="line"><span class="comment"> *                 implicitly set to #MBEDTLS_RSA_PRIVATE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           Alternative implementations of RSA need not support</span></span><br><span class="line"><span class="comment"> *                 mode being set to #MBEDTLS_RSA_PUBLIC and might instead</span></span><br><span class="line"><span class="comment"> *                 return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx      The initialized RSA context to use.</span></span><br><span class="line"><span class="comment"> * \param f_rng    The RNG function. If \p mode is #MBEDTLS_RSA_PRIVATE,</span></span><br><span class="line"><span class="comment"> *                 this is used for blinding and should be provided; see</span></span><br><span class="line"><span class="comment"> *                 mbedtls_rsa_private() for more. If \p mode is</span></span><br><span class="line"><span class="comment"> *                 #MBEDTLS_RSA_PUBLIC, it is ignored.</span></span><br><span class="line"><span class="comment"> * \param p_rng    The RNG context to be passed to \p f_rng. This may be</span></span><br><span class="line"><span class="comment"> *                 \c NULL if \p f_rng is \c NULL or doesn&#x27;t need a context.</span></span><br><span class="line"><span class="comment"> * \param mode     The mode of operation. This must be either</span></span><br><span class="line"><span class="comment"> *                 #MBEDTLS_RSA_PRIVATE or #MBEDTLS_RSA_PUBLIC (deprecated).</span></span><br><span class="line"><span class="comment"> * \param olen     The address at which to store the length of</span></span><br><span class="line"><span class="comment"> *                 the plaintext. This must not be \c NULL.</span></span><br><span class="line"><span class="comment"> * \param input    The ciphertext buffer. This must be a readable buffer</span></span><br><span class="line"><span class="comment"> *                 of length \c ctx-&gt;len Bytes. For example, \c 256 Bytes</span></span><br><span class="line"><span class="comment"> *                 for an 2048-bit RSA modulus.</span></span><br><span class="line"><span class="comment"> * \param output   The buffer used to hold the plaintext. This must</span></span><br><span class="line"><span class="comment"> *                 be a writable buffer of length \p output_max_len Bytes.</span></span><br><span class="line"><span class="comment"> * \param output_max_len The length in Bytes of the output buffer \p output.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return         \c 0 on success.</span></span><br><span class="line"><span class="comment"> * \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_rsa_pkcs1_decrypt</span><span class="params">( mbedtls_rsa_context *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> (*f_rng)(<span class="keyword">void</span> *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *p_rng,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> mode, <span class="keyword">size_t</span> *olen,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *input,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">char</span> *output,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">size_t</span> output_max_len )</span></span>;</span><br></pre></td></tr></table></figure><p>⑤ 释放RSA结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          This function frees the components of an RSA key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx      The RSA context to free. May be \c NULL, in which case</span></span><br><span class="line"><span class="comment"> *                 this function is a no-op. If it is not \c NULL, it must</span></span><br><span class="line"><span class="comment"> *                 point to an initialized RSA context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_rsa_free</span><span class="params">( mbedtls_rsa_context *ctx )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="编写测试函数-2">5.2.3 编写测试函数</h3><p>新建文件<code>mbedtls_rsa_test.c</code>，编写以下测试内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   RSA Function demo</span></span><br><span class="line"><span class="comment"> * @author  mculover666</span></span><br><span class="line"><span class="comment"> * @date    2020/09/27</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MBEDTLS_CONFIG_FILE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> MBEDTLS_CONFIG_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MBEDTLS_RSA_C)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/entropy.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/ctr_drbg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/rsa.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">516</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump_rsa_key</span><span class="params">(mbedtls_rsa_context *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> olen;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  +++++++++++++++++ rsa keypair +++++++++++++++++\n\n&quot;</span>);</span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;N , <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;N: %s\n&quot;</span>, buf); </span><br><span class="line"></span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;E , <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;E: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;D , <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;D: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;P , <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;P: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;Q , <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Q: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;DP, <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DP: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;DQ, <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DQ: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;QP, <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;QP: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  +++++++++++++++++ rsa keypair +++++++++++++++++\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump_buf</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s%02X%s&quot;</span>, i % <span class="number">16</span> == <span class="number">0</span> ? <span class="string">&quot;\r\n\t&quot;</span> : <span class="string">&quot; &quot;</span>, </span><br><span class="line">                           buf[i], </span><br><span class="line">                           i == len - <span class="number">1</span> ? <span class="string">&quot;\r\n&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> output_buf[<span class="number">2048</span>/<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_rsa_test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">size_t</span> olen;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* msg = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> decrypt_buf[<span class="number">20</span>];</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pers = <span class="string">&quot;rsa_test&quot;</span>;</span><br><span class="line">    mbedtls_entropy_context entropy;</span><br><span class="line">    mbedtls_ctr_drbg_context ctr_drbg;</span><br><span class="line">    mbedtls_rsa_context ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. init structure */</span></span><br><span class="line">    mbedtls_entropy_init(&amp;entropy);</span><br><span class="line">    mbedtls_ctr_drbg_init(&amp;ctr_drbg);</span><br><span class="line">    mbedtls_rsa_init(&amp;ctx, MBEDTLS_RSA_PKCS_V21, MBEDTLS_MD_SHA256);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 2. update seed with we own interface ported */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . Seeding the random number generator...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_ctr_drbg_seed( &amp;ctr_drbg, mbedtls_entropy_func, &amp;entropy,</span><br><span class="line">                               (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *) pers,</span><br><span class="line">                               <span class="built_in">strlen</span>(pers));</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_ctr_drbg_seed returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. generate an RSA keypair */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . Generate RSA keypair...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_rsa_gen_key(&amp;ctx, mbedtls_ctr_drbg_random, &amp;ctr_drbg, <span class="number">2048</span>, <span class="number">65537</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_rsa_gen_key returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* shwo RSA keypair */</span></span><br><span class="line">    dump_rsa_key(&amp;ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 4. encrypt */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . RSA pkcs1 encrypt...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_rsa_pkcs1_encrypt(&amp;ctx, mbedtls_ctr_drbg_random, &amp;ctr_drbg, MBEDTLS_RSA_PUBLIC, </span><br><span class="line">                                    <span class="built_in">strlen</span>(msg), (<span class="keyword">uint8_t</span> *)msg, output_buf);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_rsa_pkcs1_encrypt returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* show encrypt result */</span></span><br><span class="line">    dump_buf(output_buf, <span class="keyword">sizeof</span>(output_buf));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 5. decrypt */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . RSA pkcs1 decrypt...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_rsa_pkcs1_decrypt(&amp;ctx, mbedtls_ctr_drbg_random, &amp;ctr_drbg, MBEDTLS_RSA_PRIVATE, </span><br><span class="line">                                    &amp;olen, output_buf, decrypt_buf, <span class="keyword">sizeof</span>(decrypt_buf));</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_rsa_pkcs1_decrypt returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* show decrypt result */</span></span><br><span class="line">    decrypt_buf[olen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decrypt result:[%s]\r\n&quot;</span>, decrypt_buf);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 5. release structure */</span></span><br><span class="line">    mbedtls_ctr_drbg_free(&amp;ctr_drbg);</span><br><span class="line">    mbedtls_entropy_free(&amp;entropy);</span><br><span class="line">    mbedtls_rsa_free(&amp;ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MBEDTLS_RSA_C */</span></span></span><br></pre></td></tr></table></figure><h3 id="测试结果-3">5.2.4 测试结果</h3><p>在 main.c 中声明该测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">mbedtls_rsa_test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>然后在main函数中调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 5. rsa test */</span></span><br><span class="line">mbedtls_rsa_test();</span><br></pre></td></tr></table></figure><h3 id="堆内存空间的设置">5.2.5 堆内存空间的设置</h3><p><strong>特别注意：</strong></p><p>mbedtls RSA算法中的生成秘钥对比较占用空间，再加上RSA算法计算过程涉及到大数运算，所以RSA算法对内存的消耗比较大。</p><p>mbedtls使用的是动态内存，从堆空间中分配，所以要在STM32启动文件中将堆空间设置的大一点：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20200928201926696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><h3 id="测试结果-4">5.2.6 测试结果</h3><p>编译、下载到开发板中，可以看到：</p><p>① 秘钥对生成结果（花费大概5min左右，主控芯片STM32L431主频为80Mhz）：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20200927143614723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><p>② 使用公钥加密结果（因为RSA算法中的特性，所以同一份程序，同一份明文，每次重新运行生成的密文也不同）：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20200927143637213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>③ 使用私钥解密结果：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20200927143743879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><h1 id="六、DH秘钥协商算法的配置与使用">6 六、DH秘钥协商算法的配置与使用</h1><h2 id="DH秘钥协商算法">6.1 DH秘钥协商算法</h2><p>DH是一种秘钥协商算法，使得通信双方在不安全通道交换共享参数，从而协商出一个会话秘钥。</p><p>DH秘钥协商的过程如下：</p><p>① 通信双方A和B确认共享参数；<br>② A生成随机秘钥x；<br>③ B生成随机秘钥y；<br>④ A计算共享秘钥；<br>⑤ B计算共享秘钥；</p><p>DH秘钥协商算法可以有效防止中间窃听者，但是无法方式中间拦截者。</p><h2 id="DH秘钥协商功能的配置和使用">6.2 DH秘钥协商功能的配置和使用</h2><h3 id="配置宏-3">6.2.1 配置宏</h3><p>使用DH秘钥协商功能需要提前开启伪随机数生成器（依赖AES算法、SHA256算法、MD通用接口），其中伪随机数生成器的硬件适配移植实现已经讲述，请参考对应的第二篇博客，不再赘述。</p><p>综合上述，本实验中需要开启的宏如下表：</p><table><thead><tr><th>宏定义</th><th>功能</th></tr></thead><tbody><tr><td>MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES</td><td>不使用默认熵源<strong>（如果已有、要屏蔽该宏）</strong></td></tr><tr><td>MBEDTLS_NO_PLATFORM_ENTROPY</td><td>不使用系统内置熵源</td></tr><tr><td>MBEDTLS_AES_C</td><td>使用AES算法</td></tr><tr><td>MBEDTLS_ENTROPY_C</td><td>使能熵源模块</td></tr><tr><td>MBEDTLS_CTR_DRBG_C</td><td>使能随机数模块</td></tr><tr><td>MBEDTLS_SHA256_C</td><td>使能SHA256算法</td></tr><tr><td>MBEDTLS_MD_C</td><td>开启MD通用接口</td></tr><tr><td>MBEDTLS_AES_ROM_TABLES</td><td>使能预定义S盒（节约内存空间）</td></tr><tr><td>MBEDTLS_BIGNUM_C</td><td>开启大数运算</td></tr><tr><td>MBEDTLS_GENPRIME</td><td>开启生成素数</td></tr><tr><td>MBEDTLS_DHM_C</td><td>开启DH秘钥协商模块</td></tr></tbody></table><p>下面补充几个一个第一次出现宏的定义。</p><p>① <strong>MBEDTLS_DHM_C</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \def MBEDTLS_DHM_C</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Enable the Diffie-Hellman-Merkle module.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Module:  library/dhm.c</span></span><br><span class="line"><span class="comment"> * Caller:  library/ssl_cli.c</span></span><br><span class="line"><span class="comment"> *          library/ssl_srv.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This module is used by the following key exchanges:</span></span><br><span class="line"><span class="comment"> *      DHE-RSA, DHE-PSK</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \warning    Using DHE constitutes a security risk as it</span></span><br><span class="line"><span class="comment"> *             is not possible to validate custom DH parameters.</span></span><br><span class="line"><span class="comment"> *             If possible, it is recommended users should consider</span></span><br><span class="line"><span class="comment"> *             preferring other methods of key exchange.</span></span><br><span class="line"><span class="comment"> *             See dhm.h for more details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_DHM_C</span></span><br></pre></td></tr></table></figure><p>编辑针对本实验的配置文件<code>mbedtls_config_dhm.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   Minimal configuration for DHM Function</span></span><br><span class="line"><span class="comment"> * @author  mculover666</span></span><br><span class="line"><span class="comment"> * @date    2020/09/28</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MBEDTLS_CONFIG_DHM_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MBEDTLS_CONFIG_DHM_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* System support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_HAVE_ASM</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_HAVE_TIME</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed feature support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ENTROPY_HARDWARE_ALT</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_NO_PLATFORM_ENTROPY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed modules */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_ROM_TABLES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_CTR_DRBG_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ENTROPY_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA256_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_MD_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_BIGNUM_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_GENPRIME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_DHM_C</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/check_config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _MBEDTLS_CONFIG_DHM_H_ */</span></span></span><br></pre></td></tr></table></figure><p>在MDK配置mbedtls使用该配置文件：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20200928201900998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><h3 id="DH秘钥协商功能API说明">6.2.2 DH秘钥协商功能API说明</h3><p>使用该功能模块需要包含头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/dhm.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>① 初始化DH结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          This function initializes the DHM context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx      The DHM context to initialize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_dhm_init</span><span class="params">( mbedtls_dhm_context *ctx )</span></span>;</span><br></pre></td></tr></table></figure><p>② 生成公开参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          This function creates a DHM key pair and exports</span></span><br><span class="line"><span class="comment"> *                 the raw public key in big-endian format.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           The destination buffer is always fully written</span></span><br><span class="line"><span class="comment"> *                 so as to contain a big-endian representation of G^X mod P.</span></span><br><span class="line"><span class="comment"> *                 If it is larger than \c ctx-&gt;len, it is padded accordingly</span></span><br><span class="line"><span class="comment"> *                 with zero-bytes at the beginning.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx      The DHM context to use. This must be initialized and</span></span><br><span class="line"><span class="comment"> *                 have the DHM parameters set. It may or may not already</span></span><br><span class="line"><span class="comment"> *                 have imported the peer&#x27;s public key.</span></span><br><span class="line"><span class="comment"> * \param x_size   The private key size in Bytes.</span></span><br><span class="line"><span class="comment"> * \param output   The destination buffer. This must be a writable buffer of</span></span><br><span class="line"><span class="comment"> *                 size \p olen Bytes.</span></span><br><span class="line"><span class="comment"> * \param olen     The length of the destination buffer. This must be at least</span></span><br><span class="line"><span class="comment"> *                 equal to `ctx-&gt;len` (the size of \c P).</span></span><br><span class="line"><span class="comment"> * \param f_rng    The RNG function. This must not be \c NULL.</span></span><br><span class="line"><span class="comment"> * \param p_rng    The RNG context to be passed to \p f_rng. This may be \c NULL</span></span><br><span class="line"><span class="comment"> *                 if \p f_rng doesn&#x27;t need a context argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return         \c 0 on success.</span></span><br><span class="line"><span class="comment"> * \return         An \c MBEDTLS_ERR_DHM_XXX error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_dhm_make_public</span><span class="params">( mbedtls_dhm_context *ctx, <span class="keyword">int</span> x_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">unsigned</span> <span class="keyword">char</span> *output, <span class="keyword">size_t</span> olen,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> (*f_rng)(<span class="keyword">void</span> *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">void</span> *p_rng )</span></span>;</span><br></pre></td></tr></table></figure><p>③ 读取公开参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          This function imports the raw public value of the peer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           In a TLS handshake, this is the how the server imports</span></span><br><span class="line"><span class="comment"> *                 the Client&#x27;s public DHM key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx      The DHM context to use. This must be initialized and have</span></span><br><span class="line"><span class="comment"> *                 its DHM parameters set, e.g. via mbedtls_dhm_set_group().</span></span><br><span class="line"><span class="comment"> *                 It may or may not already have generated its own private key.</span></span><br><span class="line"><span class="comment"> * \param input    The input buffer containing the \c G^Y value of the peer.</span></span><br><span class="line"><span class="comment"> *                 This must be a readable buffer of size \p ilen Bytes.</span></span><br><span class="line"><span class="comment"> * \param ilen     The size of the input buffer \p input in Bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return         \c 0 on success.</span></span><br><span class="line"><span class="comment"> * \return         An \c MBEDTLS_ERR_DHM_XXX error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_dhm_read_public</span><span class="params">( mbedtls_dhm_context *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *input, <span class="keyword">size_t</span> ilen )</span></span>;</span><br></pre></td></tr></table></figure><p>④ 计算共享秘钥：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          This function derives and exports the shared secret</span></span><br><span class="line"><span class="comment"> *                 \c (G^Y)^X mod \c P.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           If \p f_rng is not \c NULL, it is used to blind the input as</span></span><br><span class="line"><span class="comment"> *                 a countermeasure against timing attacks. Blinding is used</span></span><br><span class="line"><span class="comment"> *                 only if our private key \c X is re-used, and not used</span></span><br><span class="line"><span class="comment"> *                 otherwise. We recommend always passing a non-NULL</span></span><br><span class="line"><span class="comment"> *                 \p f_rng argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx           The DHM context to use. This must be initialized</span></span><br><span class="line"><span class="comment"> *                      and have its own private key generated and the peer&#x27;s</span></span><br><span class="line"><span class="comment"> *                      public key imported.</span></span><br><span class="line"><span class="comment"> * \param output        The buffer to write the generated shared key to. This</span></span><br><span class="line"><span class="comment"> *                      must be a writable buffer of size \p output_size Bytes.</span></span><br><span class="line"><span class="comment"> * \param output_size   The size of the destination buffer. This must be at</span></span><br><span class="line"><span class="comment"> *                      least the size of \c ctx-&gt;len (the size of \c P).</span></span><br><span class="line"><span class="comment"> * \param olen          On exit, holds the actual number of Bytes written.</span></span><br><span class="line"><span class="comment"> * \param f_rng         The RNG function, for blinding purposes. This may</span></span><br><span class="line"><span class="comment"> *                      b \c NULL if blinding isn&#x27;t needed.</span></span><br><span class="line"><span class="comment"> * \param p_rng         The RNG context. This may be \c NULL if \p f_rng</span></span><br><span class="line"><span class="comment"> *                      doesn&#x27;t need a context argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return              \c 0 on success.</span></span><br><span class="line"><span class="comment"> * \return              An \c MBEDTLS_ERR_DHM_XXX error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_dhm_calc_secret</span><span class="params">( mbedtls_dhm_context *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">unsigned</span> <span class="keyword">char</span> *output, <span class="keyword">size_t</span> output_size, <span class="keyword">size_t</span> *olen,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> (*f_rng)(<span class="keyword">void</span> *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">void</span> *p_rng )</span></span>;</span><br></pre></td></tr></table></figure><p>⑤ 释放DH结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          This function frees and clears the components</span></span><br><span class="line"><span class="comment"> *                 of a DHM context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx      The DHM context to free and clear. This may be \c NULL,</span></span><br><span class="line"><span class="comment"> *                 in which case this function is a no-op. If it is not \c NULL,</span></span><br><span class="line"><span class="comment"> *                 it must point to an initialized DHM context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_dhm_free</span><span class="params">( mbedtls_dhm_context *ctx )</span></span>;</span><br></pre></td></tr></table></figure><p>⑥ 错误码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_DHM_BAD_INPUT_DATA                    -0x3080  <span class="comment">/**&lt; Bad input parameters. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_DHM_READ_PARAMS_FAILED                -0x3100  <span class="comment">/**&lt; Reading of the DHM parameters failed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_DHM_MAKE_PARAMS_FAILED                -0x3180  <span class="comment">/**&lt; Making of the DHM parameters failed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_DHM_READ_PUBLIC_FAILED                -0x3200  <span class="comment">/**&lt; Reading of the public values failed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_DHM_MAKE_PUBLIC_FAILED                -0x3280  <span class="comment">/**&lt; Making of the public value failed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_DHM_CALC_SECRET_FAILED                -0x3300  <span class="comment">/**&lt; Calculation of the DHM secret failed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_DHM_INVALID_FORMAT                    -0x3380  <span class="comment">/**&lt; The ASN.1 data is not formatted correctly. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_DHM_ALLOC_FAILED                      -0x3400  <span class="comment">/**&lt; Allocation of memory failed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_DHM_FILE_IO_ERROR                     -0x3480  <span class="comment">/**&lt; Read or write of file failed. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MBEDTLS_ERR_DHM_HW_ACCEL_FAILED is deprecated and should not be used. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_DHM_HW_ACCEL_FAILED                   -0x3500  <span class="comment">/**&lt; DHM hardware accelerator failed. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_DHM_SET_GROUP_FAILED                  -0x3580  <span class="comment">/**&lt; Setting the modulus and generator failed. */</span></span></span><br></pre></td></tr></table></figure><h3 id="编写测试函数-3">6.2.3 编写测试函数</h3><p>新建测试文件``，编写以下测试内容，其中服务器和客户端之间直接通信，没有采用网络通信：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MBEDTLS_CONFIG_FILE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> MBEDTLS_CONFIG_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MBEDTLS_DHM_C)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/entropy.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/ctr_drbg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/dhm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENERATOR   <span class="meta-string">&quot;2&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_P          <span class="meta-string">&quot;FFFFFFFFFFFFFFFFADF85458A2BB4A9AAFDC5620273D3CF1D8B9C583CE2D3695&quot;</span> \</span></span><br><span class="line">                     <span class="string">&quot;A9E13641146433FBCC939DCE249B3EF97D2FE363630C75D8F681B202AEC4617A&quot;</span>\</span><br><span class="line">                     <span class="string">&quot;D3DF1ED5D5FD65612433F51F5F066ED0856365553DED1AF3B557135E7F57C935&quot;</span>\</span><br><span class="line">                     <span class="string">&quot;984F0C70E0E68B77E2A689DAF3EFE8721DF158A136ADE73530ACCA4F483A797A&quot;</span>\</span><br><span class="line">                     <span class="string">&quot;BC0AB182B324FB61D108A94BB2C8E3FBB96ADAB760D7F4681D4F42A3DE394DF4&quot;</span>\</span><br><span class="line">                     <span class="string">&quot;AE56EDE76372BB190B07A7C8EE0A6D709E02FCE1CDF7E2ECC03404CD28342F61&quot;</span>\</span><br><span class="line">                     <span class="string">&quot;9172FE9CE98583FF8E4F1232EEF28183C3FE3B1B4C6FAD733BB5FCBC2EC22005&quot;</span>\</span><br><span class="line">                     <span class="string">&quot;C58EF1837D1683B2C6F34A26C1B2EFFA886B423861285C97FFFFFFFFFFFFFFFF&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> server_pub[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">uint8_t</span> client_pub[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">uint8_t</span> server_secret[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">uint8_t</span> client_secret[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump_buf</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s%02X%s&quot;</span>, i % <span class="number">16</span> == <span class="number">0</span> ? <span class="string">&quot;\r\n\t&quot;</span> : <span class="string">&quot; &quot;</span>, </span><br><span class="line">                           buf[i], </span><br><span class="line">                           i == len - <span class="number">1</span> ? <span class="string">&quot;\r\n&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_dhm_test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">size_t</span> olen;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pers = <span class="string">&quot;dhm_test&quot;</span>;</span><br><span class="line">    mbedtls_entropy_context entropy;</span><br><span class="line">    mbedtls_ctr_drbg_context ctr_drbg;</span><br><span class="line">    mbedtls_dhm_context dhm_server, dhm_client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. init structure */</span></span><br><span class="line">    mbedtls_entropy_init(&amp;entropy);</span><br><span class="line">    mbedtls_ctr_drbg_init(&amp;ctr_drbg);</span><br><span class="line">    mbedtls_dhm_init(&amp;dhm_server);</span><br><span class="line">    mbedtls_dhm_init(&amp;dhm_client);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 2. update seed with we own interface ported */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . Seeding the random number generator...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_ctr_drbg_seed( &amp;ctr_drbg, mbedtls_entropy_func, &amp;entropy,</span><br><span class="line">                               (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *) pers,</span><br><span class="line">                               <span class="built_in">strlen</span>(pers));</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_ctr_drbg_seed returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. genetate 2048 bit prime(G, P) */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  . Genetate 2048 bit prime(G, P)...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    mbedtls_mpi_read_string(&amp;dhm_server.P, <span class="number">16</span>, T_P);</span><br><span class="line">    mbedtls_mpi_read_string(&amp;dhm_server.G, <span class="number">10</span>, GENERATOR);</span><br><span class="line">    dhm_server.len = mbedtls_mpi_size(&amp;dhm_server.P);</span><br><span class="line">    </span><br><span class="line">    mbedtls_mpi_read_string(&amp;dhm_client.P, <span class="number">16</span>, T_P);</span><br><span class="line">    mbedtls_mpi_read_string(&amp;dhm_client.G, <span class="number">10</span>, GENERATOR);</span><br><span class="line">    dhm_client.len = mbedtls_mpi_size(&amp;dhm_client.P);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ok\r\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 4. Server create a DHM key pair */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  . Server creates a DHM key pair...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_dhm_make_public(&amp;dhm_server, <span class="number">256</span>, server_pub, <span class="keyword">sizeof</span>(server_pub), mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_dhm_make_public returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    dump_buf(server_pub, <span class="keyword">sizeof</span>(server_pub));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 5. Client creates a DHM key pair */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  . Client create a DHM key pair...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_dhm_make_public(&amp;dhm_client, <span class="number">256</span>, client_pub, <span class="keyword">sizeof</span>(client_pub), mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_dhm_make_public returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    dump_buf(client_pub, <span class="keyword">sizeof</span>(client_pub));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 6. Server Read public key pair */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  . Server Read public key pair...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_dhm_read_public(&amp;dhm_server, client_pub, <span class="keyword">sizeof</span>(client_pub));</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_dhm_read_public returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 7. Client Read public key pair */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  . Client Read public key pair...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_dhm_read_public(&amp;dhm_client, server_pub, <span class="keyword">sizeof</span>(server_pub));</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_dhm_read_public returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> ); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 8. calc the shared secret */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  . Server calc the shared secret...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_dhm_calc_secret(&amp;dhm_server, server_secret, <span class="keyword">sizeof</span>(server_secret), &amp;olen, mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_dhm_calc_secret returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> ); </span><br><span class="line">    dump_buf(server_secret, <span class="keyword">sizeof</span>(server_secret));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 9. calc the shared secret */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  . Client calc the shared secret...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_dhm_calc_secret(&amp;dhm_client, client_secret, <span class="keyword">sizeof</span>(client_secret), &amp;olen, mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_dhm_calc_secret returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> ); </span><br><span class="line">    dump_buf(client_secret, <span class="keyword">sizeof</span>(client_secret));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 10. release structure */</span></span><br><span class="line">    mbedtls_ctr_drbg_free(&amp;ctr_drbg);</span><br><span class="line">    mbedtls_entropy_free(&amp;entropy);</span><br><span class="line">    mbedtls_dhm_free(&amp;dhm_server);</span><br><span class="line">    mbedtls_dhm_free(&amp;dhm_client);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MBEDTLS_DHM_C */</span></span></span><br></pre></td></tr></table></figure><h3 id="测试结果-5">6.2.4 测试结果</h3><p>在 mian.c 中声明此测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">mbedtls_dhm_test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>然后在main函数中调用测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 6. dh test */</span></span><br><span class="line">mbedtls_dhm_test();</span><br></pre></td></tr></table></figure><p>因为本实验内存消耗较大，需要加大堆空间：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20200929152619282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>编译、下载、测试结果如下。</p><p>① 服务端生成的公开参数：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20200929152724594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>② 客户端生成的公开参数（<strong>可以看到与服务端的公开参数不同</strong>）：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20200929152750286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>③ 服务端计算共享秘钥：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20200929152846684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>④ 客户端计算共享秘钥（<strong>可以看到与服务端相同</strong>）：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20200929152907206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><h1 id="七、ECDH秘钥协商算法的配置与使用">7 七、ECDH秘钥协商算法的配置与使用</h1><h2 id="ECDH秘钥协商算法">7.1 ECDH秘钥协商算法</h2><p>ECDH是一种秘钥协商算法，使得通信双方在不安全通道交换共享参数，从而使用共享参数和自身私密参数计算出一个会话秘钥。</p><p>ECDH秘钥协商算法基于椭圆曲线密码系统（ECC），使用较短的秘钥长度可提供与RSA或DH算法同样的安全等级，<strong>秘钥长度为160-256bit的椭圆曲线算法，与1024-3072bit的非ECC算法安全强度相同</strong>。</p><p>ECDH秘钥协商的过程如下：</p><p>① 通信双方选择共同的椭圆曲线方程、相同的大素数P、相同的生成元G；</p><p>② 通信方A生成一个随机数作为自己的私钥，通过椭圆曲线标量乘法得到公开参数（公钥）；</p><p>③ 通信方B生成一个随机数作为自己的私钥，通过椭圆曲线标量乘法得到公开参数（公钥）；</p><p>④ 通信双方交换公钥，和自己的私钥一起计算得到共同的会话秘钥。</p><h2 id="ECDH秘钥协商功能的配置和使用">7.2 ECDH秘钥协商功能的配置和使用</h2><h3 id="配置宏-4">7.2.1 配置宏</h3><p>使用ECDH秘钥协商功能需要提前开启伪随机数生成器（依赖AES算法、SHA256算法、MD通用接口），其中伪随机数生成器的硬件适配移植实现已经讲述，请参考对应的第二篇博客，不再赘述。</p><p>综合上述，本实验中需要开启的宏如下表：</p><table><thead><tr><th>宏定义</th><th>功能</th></tr></thead><tbody><tr><td>MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES</td><td>不使用默认熵源<strong>（如果已有、要屏蔽该宏）</strong></td></tr><tr><td>MBEDTLS_NO_PLATFORM_ENTROPY</td><td>不使用系统内置熵源</td></tr><tr><td>MBEDTLS_AES_C</td><td>使用AES算法</td></tr><tr><td>MBEDTLS_ENTROPY_C</td><td>使能熵源模块</td></tr><tr><td>MBEDTLS_CTR_DRBG_C</td><td>使能随机数模块</td></tr><tr><td>MBEDTLS_SHA256_C</td><td>使能SHA256算法</td></tr><tr><td>MBEDTLS_MD_C</td><td>开启MD通用接口</td></tr><tr><td>MBEDTLS_AES_ROM_TABLES</td><td>使能预定义S盒（节约内存空间）</td></tr><tr><td>MBEDTLS_BIGNUM_C</td><td>开启大数运算</td></tr><tr><td>MBEDTLS_ECP_C</td><td>开启椭圆曲线基础运算</td></tr><tr><td>MBEDTLS_ECDH_C</td><td>开启椭圆曲线秘钥协商算法模块</td></tr><tr><td>MBEDTLS_ECP_DP_SECP256R1_ENABLED</td><td>选择secp256r1曲线参数</td></tr></tbody></table><p>下面补充几个一个第一次出现宏的定义。</p><p>① <strong>MBEDTLS_ECP_C</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \def MBEDTLS_ECP_C</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Enable the elliptic curve over GF(p) library.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Module:  library/ecp.c</span></span><br><span class="line"><span class="comment"> * Caller:  library/ecdh.c</span></span><br><span class="line"><span class="comment"> *          library/ecdsa.c</span></span><br><span class="line"><span class="comment"> *          library/ecjpake.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Requires: MBEDTLS_BIGNUM_C and at least one MBEDTLS_ECP_DP_XXX_ENABLED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ECP_C</span></span><br></pre></td></tr></table></figure><p>② <strong>MBEDTLS_ECDH_C</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \def MBEDTLS_ECDH_C</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Enable the elliptic curve Diffie-Hellman library.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Module:  library/ecdh.c</span></span><br><span class="line"><span class="comment"> * Caller:  library/ssl_cli.c</span></span><br><span class="line"><span class="comment"> *          library/ssl_srv.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This module is used by the following key exchanges:</span></span><br><span class="line"><span class="comment"> *      ECDHE-ECDSA, ECDHE-RSA, DHE-PSK</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Requires: MBEDTLS_ECP_C</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ECDH_C</span></span><br></pre></td></tr></table></figure><p>③ <strong>MBEDTLS_ECP_DP_SECP256R1_ENABLED</strong>（至少开启一种）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \def MBEDTLS_ECP_DP_SECP192R1_ENABLED</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MBEDTLS_ECP_XXXX_ENABLED: Enables specific curves within the Elliptic Curve</span></span><br><span class="line"><span class="comment"> * module.  By default all supported curves are enabled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Comment macros to disable the curve and functions for it</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_ECP_DP_SECP192R1_ENABLED</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_ECP_DP_SECP224R1_ENABLED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ECP_DP_SECP256R1_ENABLED</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_ECP_DP_SECP384R1_ENABLED</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_ECP_DP_SECP521R1_ENABLED</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_ECP_DP_SECP192K1_ENABLED</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_ECP_DP_SECP224K1_ENABLED</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_ECP_DP_SECP256K1_ENABLED</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_ECP_DP_BP256R1_ENABLED</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_ECP_DP_BP384R1_ENABLED</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_ECP_DP_BP512R1_ENABLED</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_ECP_DP_CURVE25519_ENABLED</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_ECP_DP_CURVE448_ENABLED</span></span><br></pre></td></tr></table></figure><p>编辑针对本实验的配置文件<code>mbedtls_config_ecdh.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MBEDTLS_CONFIG_ECDH_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MBEDTLS_CONFIG_ECDH_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* System support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_HAVE_ASM</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_HAVE_TIME</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed feature support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ENTROPY_HARDWARE_ALT</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_NO_PLATFORM_ENTROPY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed modules */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_ROM_TABLES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_CTR_DRBG_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ENTROPY_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA256_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_MD_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_BIGNUM_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ECP_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ECDH_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ECP_DP_SECP256R1_ENABLED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/check_config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _MBEDTLS_CONFIG_ECDH_H_ */</span></span></span><br></pre></td></tr></table></figure><h3 id="ECDH秘钥协商功能API说明">7.2.2 ECDH秘钥协商功能API说明</h3><p>① 初始化椭圆曲线群结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief           This function initializes an ECP group context</span></span><br><span class="line"><span class="comment"> *                  without loading any domain parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note            After this function is called, domain parameters</span></span><br><span class="line"><span class="comment"> *                  for various ECP groups can be loaded through the</span></span><br><span class="line"><span class="comment"> *                  mbedtls_ecp_group_load() or mbedtls_ecp_tls_read_group()</span></span><br><span class="line"><span class="comment"> *                  functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_ecp_group_init</span><span class="params">( mbedtls_ecp_group *grp )</span></span>;</span><br></pre></td></tr></table></figure><p>② 初始化椭圆曲线点结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief           This function initializes an ECP group context</span></span><br><span class="line"><span class="comment"> *                  without loading any domain parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note            After this function is called, domain parameters</span></span><br><span class="line"><span class="comment"> *                  for various ECP groups can be loaded through the</span></span><br><span class="line"><span class="comment"> *                  mbedtls_ecp_group_load() or mbedtls_ecp_tls_read_group()</span></span><br><span class="line"><span class="comment"> *                  functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_ecp_group_init</span><span class="params">( mbedtls_ecp_group *grp )</span></span>;</span><br></pre></td></tr></table></figure><p>③ 加载椭圆曲线：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief           This function sets up an ECP group context</span></span><br><span class="line"><span class="comment"> *                  from a standardized set of domain parameters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note            The index should be a value of the NamedCurve enum,</span></span><br><span class="line"><span class="comment"> *                  as defined in &lt;em&gt;RFC-4492: Elliptic Curve Cryptography</span></span><br><span class="line"><span class="comment"> *                  (ECC) Cipher Suites for Transport Layer Security (TLS)&lt;/em&gt;,</span></span><br><span class="line"><span class="comment"> *                  usually in the form of an \c MBEDTLS_ECP_DP_XXX macro.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param grp       The group context to setup. This must be initialized.</span></span><br><span class="line"><span class="comment"> * \param id        The identifier of the domain parameter set to load.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return          \c 0 on success.</span></span><br><span class="line"><span class="comment"> * \return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \p id doesn&#x27;t</span></span><br><span class="line"><span class="comment"> *                  correspond to a known group.</span></span><br><span class="line"><span class="comment"> * \return          Another negative error code on other kinds of failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_ecp_group_load</span><span class="params">( mbedtls_ecp_group *grp, mbedtls_ecp_group_id id )</span></span>;</span><br></pre></td></tr></table></figure><p>④ 生成公开参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief           This function generates an ECDH keypair on an elliptic</span></span><br><span class="line"><span class="comment"> *                  curve.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                  This function performs the first of two core computations</span></span><br><span class="line"><span class="comment"> *                  implemented during the ECDH key exchange. The second core</span></span><br><span class="line"><span class="comment"> *                  computation is performed by mbedtls_ecdh_compute_shared().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \see             ecp.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param grp       The ECP group to use. This must be initialized and have</span></span><br><span class="line"><span class="comment"> *                  domain parameters loaded, for example through</span></span><br><span class="line"><span class="comment"> *                  mbedtls_ecp_load() or mbedtls_ecp_tls_read_group().</span></span><br><span class="line"><span class="comment"> * \param d         The destination MPI (private key).</span></span><br><span class="line"><span class="comment"> *                  This must be initialized.</span></span><br><span class="line"><span class="comment"> * \param Q         The destination point (public key).</span></span><br><span class="line"><span class="comment"> *                  This must be initialized.</span></span><br><span class="line"><span class="comment"> * \param f_rng     The RNG function to use. This must not be \c NULL.</span></span><br><span class="line"><span class="comment"> * \param p_rng     The RNG context to be passed to \p f_rng. This may be</span></span><br><span class="line"><span class="comment"> *                  \c NULL in case \p f_rng doesn&#x27;t need a context argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return          \c 0 on success.</span></span><br><span class="line"><span class="comment"> * \return          Another \c MBEDTLS_ERR_ECP_XXX or</span></span><br><span class="line"><span class="comment"> *                  \c MBEDTLS_MPI_XXX error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_ecdh_gen_public</span><span class="params">( mbedtls_ecp_group *grp, mbedtls_mpi *d, mbedtls_ecp_point *Q,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> (*f_rng)(<span class="keyword">void</span> *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">void</span> *p_rng )</span></span>;</span><br></pre></td></tr></table></figure><p>⑤ 计算共享秘钥：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief           This function computes the shared secret.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                  This function performs the second of two core computations</span></span><br><span class="line"><span class="comment"> *                  implemented during the ECDH key exchange. The first core</span></span><br><span class="line"><span class="comment"> *                  computation is performed by mbedtls_ecdh_gen_public().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \see             ecp.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note            If \p f_rng is not NULL, it is used to implement</span></span><br><span class="line"><span class="comment"> *                  countermeasures against side-channel attacks.</span></span><br><span class="line"><span class="comment"> *                  For more information, see mbedtls_ecp_mul().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param grp       The ECP group to use. This must be initialized and have</span></span><br><span class="line"><span class="comment"> *                  domain parameters loaded, for example through</span></span><br><span class="line"><span class="comment"> *                  mbedtls_ecp_load() or mbedtls_ecp_tls_read_group().</span></span><br><span class="line"><span class="comment"> * \param z         The destination MPI (shared secret).</span></span><br><span class="line"><span class="comment"> *                  This must be initialized.</span></span><br><span class="line"><span class="comment"> * \param Q         The public key from another party.</span></span><br><span class="line"><span class="comment"> *                  This must be initialized.</span></span><br><span class="line"><span class="comment"> * \param d         Our secret exponent (private key).</span></span><br><span class="line"><span class="comment"> *                  This must be initialized.</span></span><br><span class="line"><span class="comment"> * \param f_rng     The RNG function. This may be \c NULL if randomization</span></span><br><span class="line"><span class="comment"> *                  of intermediate results during the ECP computations is</span></span><br><span class="line"><span class="comment"> *                  not needed (discouraged). See the documentation of</span></span><br><span class="line"><span class="comment"> *                  mbedtls_ecp_mul() for more.</span></span><br><span class="line"><span class="comment"> * \param p_rng     The RNG context to be passed to \p f_rng. This may be</span></span><br><span class="line"><span class="comment"> *                  \c NULL if \p f_rng is \c NULL or doesn&#x27;t need a</span></span><br><span class="line"><span class="comment"> *                  context argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return          \c 0 on success.</span></span><br><span class="line"><span class="comment"> * \return          Another \c MBEDTLS_ERR_ECP_XXX or</span></span><br><span class="line"><span class="comment"> *                  \c MBEDTLS_MPI_XXX error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_ecdh_compute_shared</span><span class="params">( mbedtls_ecp_group *grp, mbedtls_mpi *z,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> mbedtls_ecp_point *Q, <span class="keyword">const</span> mbedtls_mpi *d,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> (*f_rng)(<span class="keyword">void</span> *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">void</span> *p_rng )</span></span>;</span><br></pre></td></tr></table></figure><p>⑥ 释放椭圆曲线群结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief           This function frees the components of an ECP group.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param grp       The group to free. This may be \c NULL, in which</span></span><br><span class="line"><span class="comment"> *                  case this function returns immediately. If it is not</span></span><br><span class="line"><span class="comment"> *                  \c NULL, it must point to an initialized ECP group.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_ecp_group_free</span><span class="params">( mbedtls_ecp_group *grp )</span></span>;</span><br></pre></td></tr></table></figure><p>⑦ 释放椭圆曲线点结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief           This function frees the components of a point.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param pt        The point to free.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_ecp_point_free</span><span class="params">( mbedtls_ecp_point *pt )</span></span>;</span><br></pre></td></tr></table></figure><p>⑧ 错误码（ECP计算部分）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ECP error codes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_ECP_BAD_INPUT_DATA                    -0x4F80  <span class="comment">/**&lt; Bad input parameters to function. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL                  -0x4F00  <span class="comment">/**&lt; The buffer is too small to write to. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE               -0x4E80  <span class="comment">/**&lt; The requested feature is not available, for example, the requested curve is not supported. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_ECP_VERIFY_FAILED                     -0x4E00  <span class="comment">/**&lt; The signature is not valid. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_ECP_ALLOC_FAILED                      -0x4D80  <span class="comment">/**&lt; Memory allocation failed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_ECP_RANDOM_FAILED                     -0x4D00  <span class="comment">/**&lt; Generation of random value, such as ephemeral key, failed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_ECP_INVALID_KEY                       -0x4C80  <span class="comment">/**&lt; Invalid private or public key. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH                  -0x4C00  <span class="comment">/**&lt; The buffer contains a valid signature followed by more data. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MBEDTLS_ERR_ECP_HW_ACCEL_FAILED is deprecated and should not be used. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_ECP_HW_ACCEL_FAILED                   -0x4B80  <span class="comment">/**&lt; The ECP hardware accelerator failed. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_ECP_IN_PROGRESS                       -0x4B00  <span class="comment">/**&lt; Operation in progress, call again with the same parameters to continue. */</span></span></span><br></pre></td></tr></table></figure><h3 id="编写测试函数-4">7.2.3 编写测试函数</h3><p>新建测试文件<code>mbedtls_ecdh_test.c</code>，编写以下测试内容，其中服务器和客户端之间直接通信，没有采用网络通信：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MBEDTLS_CONFIG_FILE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> MBEDTLS_CONFIG_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MBEDTLS_ECDH_C)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/entropy.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/ctr_drbg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/ecdh.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GENERATOR   <span class="meta-string">&quot;2&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_P          <span class="meta-string">&quot;FFFFFFFFFFFFFFFFADF85458A2BB4A9AAFDC5620273D3CF1D8B9C583CE2D3695&quot;</span> \</span></span><br><span class="line">                     <span class="string">&quot;A9E13641146433FBCC939DCE249B3EF97D2FE363630C75D8F681B202AEC4617A&quot;</span>\</span><br><span class="line">                     <span class="string">&quot;D3DF1ED5D5FD65612433F51F5F066ED0856365553DED1AF3B557135E7F57C935&quot;</span>\</span><br><span class="line">                     <span class="string">&quot;984F0C70E0E68B77E2A689DAF3EFE8721DF158A136ADE73530ACCA4F483A797A&quot;</span>\</span><br><span class="line">                     <span class="string">&quot;BC0AB182B324FB61D108A94BB2C8E3FBB96ADAB760D7F4681D4F42A3DE394DF4&quot;</span>\</span><br><span class="line">                     <span class="string">&quot;AE56EDE76372BB190B07A7C8EE0A6D709E02FCE1CDF7E2ECC03404CD28342F61&quot;</span>\</span><br><span class="line">                     <span class="string">&quot;9172FE9CE98583FF8E4F1232EEF28183C3FE3B1B4C6FAD733BB5FCBC2EC22005&quot;</span>\</span><br><span class="line">                     <span class="string">&quot;C58EF1837D1683B2C6F34A26C1B2EFFA886B423861285C97FFFFFFFFFFFFFFFF&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> buf[<span class="number">65</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump_buf</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s%02X%s&quot;</span>, i % <span class="number">16</span> == <span class="number">0</span> ? <span class="string">&quot;\r\n\t&quot;</span> : <span class="string">&quot; &quot;</span>, </span><br><span class="line">                           buf[i], </span><br><span class="line">                           i == len - <span class="number">1</span> ? <span class="string">&quot;\r\n&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_ecdh_test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">size_t</span> olen;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pers = <span class="string">&quot;ecdh_test&quot;</span>;</span><br><span class="line">    mbedtls_entropy_context entropy;</span><br><span class="line">    mbedtls_ctr_drbg_context ctr_drbg;</span><br><span class="line">    mbedtls_ecp_point client_pub, server_pub;</span><br><span class="line">    mbedtls_ecp_group grp;</span><br><span class="line">    mbedtls_mpi client_secret, server_secret;</span><br><span class="line">    mbedtls_mpi client_pri, server_pri;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 1. init structure */</span></span><br><span class="line">    mbedtls_entropy_init(&amp;entropy);</span><br><span class="line">    mbedtls_ctr_drbg_init(&amp;ctr_drbg);</span><br><span class="line">    mbedtls_mpi_init(&amp;client_secret);</span><br><span class="line">    mbedtls_mpi_init(&amp;server_secret);</span><br><span class="line">    mbedtls_mpi_init(&amp;client_pri);</span><br><span class="line">    mbedtls_mpi_init(&amp;server_pri);</span><br><span class="line">    mbedtls_ecp_group_init(&amp;grp);</span><br><span class="line">    mbedtls_ecp_point_init(&amp;client_pub);</span><br><span class="line">    mbedtls_ecp_point_init(&amp;server_pub);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 2. update seed with we own interface ported */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . Seeding the random number generator...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_ctr_drbg_seed( &amp;ctr_drbg, mbedtls_entropy_func, &amp;entropy,</span><br><span class="line">                               (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *) pers,</span><br><span class="line">                               <span class="built_in">strlen</span>(pers));</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_ctr_drbg_seed returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3.  select ecp group SECP256R1 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  . Select ecp group SECP256R1...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_ecp_group_load(&amp;grp, MBEDTLS_ECP_DP_SECP256R1);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_ecp_group_load returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ok\r\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 4. Client generate public parameter */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  . Client Generate public parameter...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_ecdh_gen_public(&amp;grp, &amp;client_pri, &amp;client_pub, mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_ecdh_gen_public returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* show public parameter */</span></span><br><span class="line">    mbedtls_ecp_point_write_binary(&amp;grp, &amp;client_pub, MBEDTLS_ECP_PF_UNCOMPRESSED, &amp;olen, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    dump_buf(buf, olen);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 5. Client generate public parameter */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  . Server Generate public parameter...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_ecdh_gen_public(&amp;grp, &amp;server_pri, &amp;server_pub, mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_ecdh_gen_public returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* show public parameter */</span></span><br><span class="line">    mbedtls_ecp_point_write_binary(&amp;grp, &amp;server_pub, MBEDTLS_ECP_PF_UNCOMPRESSED, &amp;olen, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    dump_buf(buf, olen);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 6. Calc shared secret */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  . Client Calc shared secret...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_ecdh_compute_shared(&amp;grp, &amp;client_secret, &amp;server_pub, &amp;client_pri, mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_ecdh_compute_shared returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* show public parameter */</span></span><br><span class="line">    mbedtls_mpi_write_binary(&amp;client_secret, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    dump_buf(buf, olen);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 7. Server Calc shared secret */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  . Server Calc shared secret...&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_ecdh_compute_shared(&amp;grp, &amp;server_secret, &amp;client_pub, &amp;server_pri, mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_ecdh_compute_shared returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* show public parameter */</span></span><br><span class="line">    mbedtls_mpi_write_binary(&amp;server_secret, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    dump_buf(buf, olen);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 8. mpi compare */</span></span><br><span class="line">    ret = mbedtls_mpi_cmp_mpi(&amp;server_secret, &amp;client_secret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;compare result: %d\r\n&quot;</span>, ret);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 10. release structure */</span></span><br><span class="line">    mbedtls_ctr_drbg_free(&amp;ctr_drbg);</span><br><span class="line">    mbedtls_entropy_free(&amp;entropy);</span><br><span class="line">    mbedtls_mpi_free(&amp;client_secret);</span><br><span class="line">    mbedtls_mpi_free(&amp;server_secret);</span><br><span class="line">    mbedtls_mpi_free(&amp;client_pri);</span><br><span class="line">    mbedtls_mpi_free(&amp;server_pri);</span><br><span class="line">    mbedtls_ecp_group_free(&amp;grp);</span><br><span class="line">    mbedtls_ecp_point_free(&amp;client_pub);</span><br><span class="line">    mbedtls_ecp_point_free(&amp;server_pub);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MBEDTLS_DHM_C */</span></span></span><br></pre></td></tr></table></figure><h3 id="调用测试函数">7.2.4 调用测试函数</h3><p>在 main.c 中声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">mbedtls_ecdh_test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在 main 函数中调用此测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 7. ecdh test */</span></span><br><span class="line">mbedtls_ecdh_test();</span><br></pre></td></tr></table></figure><p>编译、下载、在串口助手查看结果：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20200930161558673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><h1 id="八、数字签名算法的配置与使用（RSA数字签名算法、ECDSA数字签名算法）">8 八、数字签名算法的配置与使用（RSA数字签名算法、ECDSA数字签名算法）</h1><h2 id="数字签名算法">8.1 数字签名算法</h2><h3 id="什么是数字签名">8.1.1 什么是数字签名</h3><p>数字签名类似于盖章和签字，数字签名可以检查消息是否被篡改、并验证消息的可靠性，因为私钥只有签名者持有，所以还可以防止否认。</p><h3 id="数字签名算法-1">8.1.2 数字签名算法</h3><p>① <strong>RSA数字签名</strong></p><p>RSA数字签名算法基于RSA非对称加密算法，在用于数字签名时公钥和私钥的用法刚好相反：</p><ul><li>发送方使用私钥对消息执行加密操作 = 对消息进行签名；</li><li>接收方使用公钥对签名进行解密 = 对签名进行认证；</li></ul><p>RSA签名算法还需要包括填充方法，有两种：PKCS1-V1.5和PSS（使用随机数填充，<strong>推荐使用</strong>）。</p><p>② <strong>DSA算法</strong></p><p>③ <strong>ECDSA算法</strong></p><p>在相同的安全等级下，ECDSA算法具有秘钥短、执行效率高的特点，更适合物联网应用。</p><h2 id="RSA数字签名功能模块的配置与使用">8.2 RSA数字签名功能模块的配置与使用</h2><h3 id="配置宏-5">8.2.1 配置宏</h3><p>使用RSA功能需要提前开启伪随机数生成器（依赖AES算法、SHA256算法、MD通用接口），其中伪随机数生成器的硬件适配移植实现已经讲述，请参考对应的第二篇博客，不再赘述。</p><p>综合上述，本实验中需要开启的宏如下表：</p><table><thead><tr><th>宏定义</th><th>功能</th></tr></thead><tbody><tr><td>MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES</td><td>不使用默认熵源<strong>（如果已有、要屏蔽该宏）</strong></td></tr><tr><td>MBEDTLS_NO_PLATFORM_ENTROPY</td><td>不使用系统内置熵源</td></tr><tr><td>MBEDTLS_AES_C</td><td>使用AES算法</td></tr><tr><td>MBEDTLS_ENTROPY_C</td><td>使能熵源模块</td></tr><tr><td>MBEDTLS_CTR_DRBG_C</td><td>使能随机数模块</td></tr><tr><td>MBEDTLS_SHA256_C</td><td>使能SHA256算法</td></tr><tr><td>MBEDTLS_MD_C</td><td>开启MD通用接口</td></tr><tr><td>MBEDTLS_AES_ROM_TABLES</td><td>使能预定义S盒（节约内存空间）</td></tr><tr><td>MBEDTLS_BIGNUM_C</td><td>开启大数运算</td></tr><tr><td>MBEDTLS_GENPRIME</td><td>开启生成素数</td></tr><tr><td>MBEDTLS_OID_C</td><td>开启OID数据结构模块</td></tr><tr><td>MBEDTLS_RSA_C</td><td>开启RSA算法</td></tr><tr><td>MBEDTLS_PKCS1_V21</td><td>开启PKCS#1 v2.1填充方案（OAEP）</td></tr></tbody></table><p>新建配置文件<code>mbedtls_config_rsa_sign.h</code>，编写以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MBEDTLS_CONFIG_RSA_SIGN_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MBEDTLS_CONFIG_RSA_SIGN_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* System support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_HAVE_ASM</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_HAVE_TIME</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed feature support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ENTROPY_HARDWARE_ALT</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_NO_PLATFORM_ENTROPY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed modules */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_ROM_TABLES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_CTR_DRBG_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ENTROPY_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA256_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_MD_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_BIGNUM_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_GENPRIME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_OID_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_RSA_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_PKCS1_V21</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/check_config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _MBEDTLS_CONFIG_RSA_SIGN_H_ */</span></span></span><br></pre></td></tr></table></figure><p>在MDK中设置使用该配置文件：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201003110740288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><h3 id="RSA数字签名功能模块API说明">8.2.2 RSA数字签名功能模块API说明</h3><p>使用该功能模块需要包含头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/rsa.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>① RSA签名接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          This function performs a private RSA operation to sign</span></span><br><span class="line"><span class="comment"> *                 a message digest using PKCS#1.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                 It is the generic wrapper for performing a PKCS#1</span></span><br><span class="line"><span class="comment"> *                 signature using the \p mode from the context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           The \p sig buffer must be as large as the size</span></span><br><span class="line"><span class="comment"> *                 of \p ctx-&gt;N. For example, 128 Bytes if RSA-1024 is used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           For PKCS#1 v2.1 encoding, see comments on</span></span><br><span class="line"><span class="comment"> *                 mbedtls_rsa_rsassa_pss_sign() for details on</span></span><br><span class="line"><span class="comment"> *                 \p md_alg and \p hash_id.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \deprecated     It is deprecated and discouraged to call this function</span></span><br><span class="line"><span class="comment"> *                 in #MBEDTLS_RSA_PUBLIC mode. Future versions of the library</span></span><br><span class="line"><span class="comment"> *                 are likely to remove the \p mode argument and have it</span></span><br><span class="line"><span class="comment"> *                 implicitly set to #MBEDTLS_RSA_PRIVATE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           Alternative implementations of RSA need not support</span></span><br><span class="line"><span class="comment"> *                 mode being set to #MBEDTLS_RSA_PUBLIC and might instead</span></span><br><span class="line"><span class="comment"> *                 return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx      The initialized RSA context to use.</span></span><br><span class="line"><span class="comment"> * \param f_rng    The RNG function to use. If the padding mode is PKCS#1 v2.1,</span></span><br><span class="line"><span class="comment"> *                 this must be provided. If the padding mode is PKCS#1 v1.5 and</span></span><br><span class="line"><span class="comment"> *                 \p mode is #MBEDTLS_RSA_PRIVATE, it is used for blinding</span></span><br><span class="line"><span class="comment"> *                 and should be provided; see mbedtls_rsa_private() for more</span></span><br><span class="line"><span class="comment"> *                 more. It is ignored otherwise.</span></span><br><span class="line"><span class="comment"> * \param p_rng    The RNG context to be passed to \p f_rng. This may be \c NULL</span></span><br><span class="line"><span class="comment"> *                 if \p f_rng is \c NULL or doesn&#x27;t need a context argument.</span></span><br><span class="line"><span class="comment"> * \param mode     The mode of operation. This must be either</span></span><br><span class="line"><span class="comment"> *                 #MBEDTLS_RSA_PRIVATE or #MBEDTLS_RSA_PUBLIC (deprecated).</span></span><br><span class="line"><span class="comment"> * \param md_alg   The message-digest algorithm used to hash the original data.</span></span><br><span class="line"><span class="comment"> *                 Use #MBEDTLS_MD_NONE for signing raw data.</span></span><br><span class="line"><span class="comment"> * \param hashlen  The length of the message digest.</span></span><br><span class="line"><span class="comment"> *                 Ths is only used if \p md_alg is #MBEDTLS_MD_NONE.</span></span><br><span class="line"><span class="comment"> * \param hash     The buffer holding the message digest or raw data.</span></span><br><span class="line"><span class="comment"> *                 If \p md_alg is #MBEDTLS_MD_NONE, this must be a readable</span></span><br><span class="line"><span class="comment"> *                 buffer of length \p hashlen Bytes. If \p md_alg is not</span></span><br><span class="line"><span class="comment"> *                 #MBEDTLS_MD_NONE, it must be a readable buffer of length</span></span><br><span class="line"><span class="comment"> *                 the size of the hash corresponding to \p md_alg.</span></span><br><span class="line"><span class="comment"> * \param sig      The buffer to hold the signature. This must be a writable</span></span><br><span class="line"><span class="comment"> *                 buffer of length \c ctx-&gt;len Bytes. For example, \c 256 Bytes</span></span><br><span class="line"><span class="comment"> *                 for an 2048-bit RSA modulus. A buffer length of</span></span><br><span class="line"><span class="comment"> *                 #MBEDTLS_MPI_MAX_SIZE is always safe.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return         \c 0 if the signing operation was successful.</span></span><br><span class="line"><span class="comment"> * \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_rsa_pkcs1_sign</span><span class="params">( mbedtls_rsa_context *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> (*f_rng)(<span class="keyword">void</span> *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *p_rng,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">mbedtls_md_type_t</span> md_alg,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">int</span> hashlen,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *hash,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">char</span> *sig )</span></span>;</span><br></pre></td></tr></table></figure><p>② RSA验证签名接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          This function performs a public RSA operation and checks</span></span><br><span class="line"><span class="comment"> *                 the message digest.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                 This is the generic wrapper for performing a PKCS#1</span></span><br><span class="line"><span class="comment"> *                 verification using the mode from the context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           For PKCS#1 v2.1 encoding, see comments on</span></span><br><span class="line"><span class="comment"> *                 mbedtls_rsa_rsassa_pss_verify() about \p md_alg and</span></span><br><span class="line"><span class="comment"> *                 \p hash_id.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \deprecated     It is deprecated and discouraged to call this function</span></span><br><span class="line"><span class="comment"> *                 in #MBEDTLS_RSA_PRIVATE mode. Future versions of the library</span></span><br><span class="line"><span class="comment"> *                 are likely to remove the \p mode argument and have it</span></span><br><span class="line"><span class="comment"> *                 set to #MBEDTLS_RSA_PUBLIC.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           Alternative implementations of RSA need not support</span></span><br><span class="line"><span class="comment"> *                 mode being set to #MBEDTLS_RSA_PRIVATE and might instead</span></span><br><span class="line"><span class="comment"> *                 return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx      The initialized RSA public key context to use.</span></span><br><span class="line"><span class="comment"> * \param f_rng    The RNG function to use. If \p mode is #MBEDTLS_RSA_PRIVATE,</span></span><br><span class="line"><span class="comment"> *                 this is used for blinding and should be provided; see</span></span><br><span class="line"><span class="comment"> *                 mbedtls_rsa_private() for more. Otherwise, it is ignored.</span></span><br><span class="line"><span class="comment"> * \param p_rng    The RNG context to be passed to \p f_rng. This may be</span></span><br><span class="line"><span class="comment"> *                 \c NULL if \p f_rng is \c NULL or doesn&#x27;t need a context.</span></span><br><span class="line"><span class="comment"> * \param mode     The mode of operation. This must be either</span></span><br><span class="line"><span class="comment"> *                 #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE (deprecated).</span></span><br><span class="line"><span class="comment"> * \param md_alg   The message-digest algorithm used to hash the original data.</span></span><br><span class="line"><span class="comment"> *                 Use #MBEDTLS_MD_NONE for signing raw data.</span></span><br><span class="line"><span class="comment"> * \param hashlen  The length of the message digest.</span></span><br><span class="line"><span class="comment"> *                 This is only used if \p md_alg is #MBEDTLS_MD_NONE.</span></span><br><span class="line"><span class="comment"> * \param hash     The buffer holding the message digest or raw data.</span></span><br><span class="line"><span class="comment"> *                 If \p md_alg is #MBEDTLS_MD_NONE, this must be a readable</span></span><br><span class="line"><span class="comment"> *                 buffer of length \p hashlen Bytes. If \p md_alg is not</span></span><br><span class="line"><span class="comment"> *                 #MBEDTLS_MD_NONE, it must be a readable buffer of length</span></span><br><span class="line"><span class="comment"> *                 the size of the hash corresponding to \p md_alg.</span></span><br><span class="line"><span class="comment"> * \param sig      The buffer holding the signature. This must be a readable</span></span><br><span class="line"><span class="comment"> *                 buffer of length \c ctx-&gt;len Bytes. For example, \c 256 Bytes</span></span><br><span class="line"><span class="comment"> *                 for an 2048-bit RSA modulus.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return         \c 0 if the verify operation was successful.</span></span><br><span class="line"><span class="comment"> * \return         An \c MBEDTLS_ERR_RSA_XXX error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_rsa_pkcs1_verify</span><span class="params">( mbedtls_rsa_context *ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> (*f_rng)(<span class="keyword">void</span> *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> *p_rng,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">mbedtls_md_type_t</span> md_alg,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> <span class="keyword">int</span> hashlen,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *hash,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *sig )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="编写测试函数-5">8.2.3 编写测试函数</h3><p>新建文件<code>mbedtls_rsa_sign_test.c</code>，编写以下测试内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MBEDTLS_CONFIG_FILE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> MBEDTLS_CONFIG_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MBEDTLS_RSA_C)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/entropy.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/ctr_drbg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/rsa.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">516</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump_rsa_key</span><span class="params">(mbedtls_rsa_context *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> olen;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  +++++++++++++++++ rsa keypair +++++++++++++++++\n\n&quot;</span>);</span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;N , <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;N: %s\n&quot;</span>, buf); </span><br><span class="line"></span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;E , <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;E: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;D , <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;D: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;P , <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;P: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;Q , <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Q: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;DP, <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DP: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;DQ, <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DQ: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    mbedtls_mpi_write_string(&amp;ctx-&gt;QP, <span class="number">16</span>, buf, <span class="keyword">sizeof</span>(buf), &amp;olen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;QP: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n  +++++++++++++++++ rsa keypair +++++++++++++++++\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump_buf</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s%02X%s&quot;</span>, i % <span class="number">16</span> == <span class="number">0</span> ? <span class="string">&quot;\r\n\t&quot;</span> : <span class="string">&quot; &quot;</span>, </span><br><span class="line">                           buf[i], </span><br><span class="line">                           i == len - <span class="number">1</span> ? <span class="string">&quot;\r\n&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> output_buf[<span class="number">2048</span>/<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_rsa_sign_test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* msg = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pers = <span class="string">&quot;rsa_sign_test&quot;</span>;</span><br><span class="line">    mbedtls_entropy_context entropy;</span><br><span class="line">    mbedtls_ctr_drbg_context ctr_drbg;</span><br><span class="line">    mbedtls_rsa_context ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. init structure */</span></span><br><span class="line">    mbedtls_entropy_init(&amp;entropy);</span><br><span class="line">    mbedtls_ctr_drbg_init(&amp;ctr_drbg);</span><br><span class="line">    mbedtls_rsa_init(&amp;ctx, MBEDTLS_RSA_PKCS_V21, MBEDTLS_MD_SHA256);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 2. update seed with we own interface ported */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . Seeding the random number generator...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_ctr_drbg_seed( &amp;ctr_drbg, mbedtls_entropy_func, &amp;entropy,</span><br><span class="line">                               (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *) pers,</span><br><span class="line">                               <span class="built_in">strlen</span>(pers));</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_ctr_drbg_seed returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. generate an RSA keypair */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . Generate RSA keypair...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_rsa_gen_key(&amp;ctx, mbedtls_ctr_drbg_random, &amp;ctr_drbg, <span class="number">2048</span>, <span class="number">65537</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_rsa_gen_key returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* shwo RSA keypair */</span></span><br><span class="line">    dump_rsa_key(&amp;ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 4. sign */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . RSA pkcs1 sign...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_rsa_pkcs1_sign(&amp;ctx, mbedtls_ctr_drbg_random, &amp;ctr_drbg, MBEDTLS_RSA_PRIVATE, MBEDTLS_MD_SHA256, <span class="built_in">strlen</span>(msg), (<span class="keyword">uint8_t</span> *)msg, output_buf);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_rsa_pkcs1_sign returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* show sign result */</span></span><br><span class="line">    dump_buf(output_buf, <span class="keyword">sizeof</span>(output_buf));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 5. verify sign*/</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . RSA pkcs1 verify...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_rsa_pkcs1_verify(&amp;ctx, mbedtls_ctr_drbg_random, &amp;ctr_drbg, MBEDTLS_RSA_PUBLIC, MBEDTLS_MD_SHA256, <span class="built_in">strlen</span>(msg), (<span class="keyword">uint8_t</span> *)msg, output_buf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_rsa_pkcs1_encrypt returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 5. release structure */</span></span><br><span class="line">    mbedtls_ctr_drbg_free(&amp;ctr_drbg);</span><br><span class="line">    mbedtls_entropy_free(&amp;entropy);</span><br><span class="line">    mbedtls_rsa_free(&amp;ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MBEDTLS_RSA_C */</span></span></span><br></pre></td></tr></table></figure><h3 id="测试结果-6">8.2.4 测试结果</h3><p>在main.c中声明该测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">mbedtls_rsa_sign_test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在main函数中调用该测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8. rsa sign test */</span></span><br><span class="line">mbedtls_rsa_sign_test();</span><br></pre></td></tr></table></figure><p>编译、下载，在串口助手中查看测试结果：</p><p>① 生成秘钥对成功（需要几min的时间）：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201003113344994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>② 生成签名和验证签名成功：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201003113416619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><h2 id="ECDSA数字签名功能模块的配置与使用">8.3 ECDSA数字签名功能模块的配置与使用</h2><h3 id="配置宏-6">8.3.1 配置宏</h3><p>使用ECDSA秘钥协商功能需要提前开启伪随机数生成器（依赖AES算法、SHA256算法、MD通用接口），其中伪随机数生成器的硬件适配移植实现已经讲述，请参考对应的第二篇博客，不再赘述。</p><p>综合上述，本实验中需要开启的宏如下表：</p><table><thead><tr><th>宏定义</th><th>功能</th></tr></thead><tbody><tr><td>MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES</td><td>不使用默认熵源<strong>（如果已有、要屏蔽该宏）</strong></td></tr><tr><td>MBEDTLS_NO_PLATFORM_ENTROPY</td><td>不使用系统内置熵源</td></tr><tr><td>MBEDTLS_AES_C</td><td>使用AES算法</td></tr><tr><td>MBEDTLS_ENTROPY_C</td><td>使能熵源模块</td></tr><tr><td>MBEDTLS_CTR_DRBG_C</td><td>使能随机数模块</td></tr><tr><td>MBEDTLS_SHA256_C</td><td>使能SHA256算法</td></tr><tr><td>MBEDTLS_MD_C</td><td>开启MD通用接口</td></tr><tr><td>MBEDTLS_AES_ROM_TABLES</td><td>使能预定义S盒（节约内存空间）</td></tr><tr><td>MBEDTLS_BIGNUM_C</td><td>开启大数运算</td></tr><tr><td>MBEDTLS_ECP_C</td><td>开启椭圆曲线基础运算</td></tr><tr><td>MBEDTLS_ECP_DP_SECP256R1_ENABLED</td><td>选择secp256r1曲线参数</td></tr><tr><td>MBEDTLS_ECDSA_C</td><td>开启ECDSA算法</td></tr><tr><td>MBEDTLS_ASN1_WRITE_C</td><td>开启ASN1格式写入</td></tr><tr><td>MBEDTLS_ASN1_PARSE_C</td><td>开启ASN1结构解析</td></tr></tbody></table><p>下面补充几个一个第一次出现宏的定义。</p><p>① <strong>MBEDTLS_ECDSA_C</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \def MBEDTLS_ECDSA_C</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Enable the elliptic curve DSA library.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Module:  library/ecdsa.c</span></span><br><span class="line"><span class="comment"> * Caller:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This module is used by the following key exchanges:</span></span><br><span class="line"><span class="comment"> *      ECDHE-ECDSA</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Requires: MBEDTLS_ECP_C, MBEDTLS_ASN1_WRITE_C, MBEDTLS_ASN1_PARSE_C</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ECDSA_C</span></span><br></pre></td></tr></table></figure><p>② <strong>MBEDTLS_ASN1_WRITE_C</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \def MBEDTLS_ASN1_WRITE_C</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Enable the generic ASN1 writer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Module:  library/asn1write.c</span></span><br><span class="line"><span class="comment"> * Caller:  library/ecdsa.c</span></span><br><span class="line"><span class="comment"> *          library/pkwrite.c</span></span><br><span class="line"><span class="comment"> *          library/x509_create.c</span></span><br><span class="line"><span class="comment"> *          library/x509write_crt.c</span></span><br><span class="line"><span class="comment"> *          library/x509write_csr.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ASN1_WRITE_C</span></span><br></pre></td></tr></table></figure><p>③ <strong>MBEDTLS_ASN1_PARSE_C</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \def MBEDTLS_ASN1_PARSE_C</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Enable the generic ASN1 parser.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Module:  library/asn1.c</span></span><br><span class="line"><span class="comment"> * Caller:  library/x509.c</span></span><br><span class="line"><span class="comment"> *          library/dhm.c</span></span><br><span class="line"><span class="comment"> *          library/pkcs12.c</span></span><br><span class="line"><span class="comment"> *          library/pkcs5.c</span></span><br><span class="line"><span class="comment"> *          library/pkparse.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ASN1_PARSE_C</span></span><br></pre></td></tr></table></figure><p>新建配置文件<code>mbedtls_config_ecdsa.h</code>，编写以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MBEDTLS_CONFIG_ECDSA_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MBEDTLS_CONFIG_ECDSA_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* System support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_HAVE_ASM</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_HAVE_TIME</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed feature support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ENTROPY_HARDWARE_ALT</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_NO_PLATFORM_ENTROPY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed modules */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_AES_ROM_TABLES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_CTR_DRBG_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ENTROPY_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA256_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_MD_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_BIGNUM_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ECP_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ECP_DP_SECP256R1_ENABLED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ECDSA_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ASN1_WRITE_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ASN1_PARSE_C</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/check_config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _MBEDTLS_CONFIG_ECDSA_H_ */</span></span></span><br></pre></td></tr></table></figure><p>在MDK中配置使用该配置文件：<img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201003170538611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><h3 id="ECDSA签名功能API说明">8.3.2 ECDSA签名功能API说明</h3><p>① 初始化ECDSA结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief           This function initializes an ECDSA context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx       The ECDSA context to initialize.</span></span><br><span class="line"><span class="comment"> *                  This must not be \c NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_ecdsa_init</span><span class="params">( mbedtls_ecdsa_context *ctx )</span></span>;</span><br></pre></td></tr></table></figure><p>② ECDSA生成秘钥接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          This function generates an ECDSA keypair on the given curve.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \see            ecp.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx      The ECDSA context to store the keypair in.</span></span><br><span class="line"><span class="comment"> *                 This must be initialized.</span></span><br><span class="line"><span class="comment"> * \param gid      The elliptic curve to use. One of the various</span></span><br><span class="line"><span class="comment"> *                 \c MBEDTLS_ECP_DP_XXX macros depending on configuration.</span></span><br><span class="line"><span class="comment"> * \param f_rng    The RNG function to use. This must not be \c NULL.</span></span><br><span class="line"><span class="comment"> * \param p_rng    The RNG context to be passed to \p f_rng. This may be</span></span><br><span class="line"><span class="comment"> *                 \c NULL if \p f_rng doesn&#x27;t need a context argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return         \c 0 on success.</span></span><br><span class="line"><span class="comment"> * \return         An \c MBEDTLS_ERR_ECP_XXX code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_ecdsa_genkey</span><span class="params">( mbedtls_ecdsa_context *ctx, mbedtls_ecp_group_id gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> (*f_rng)(<span class="keyword">void</span> *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>), <span class="keyword">void</span> *p_rng )</span></span>;</span><br></pre></td></tr></table></figure><p>③ ECDSA签名接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief           This function computes the ECDSA signature of a</span></span><br><span class="line"><span class="comment"> *                  previously-hashed message.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note            The deterministic version implemented in</span></span><br><span class="line"><span class="comment"> *                  mbedtls_ecdsa_sign_det() is usually preferred.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note            If the bitlength of the message hash is larger than the</span></span><br><span class="line"><span class="comment"> *                  bitlength of the group order, then the hash is truncated</span></span><br><span class="line"><span class="comment"> *                  as defined in &lt;em&gt;Standards for Efficient Cryptography Group</span></span><br><span class="line"><span class="comment"> *                  (SECG): SEC1 Elliptic Curve Cryptography&lt;/em&gt;, section</span></span><br><span class="line"><span class="comment"> *                  4.1.3, step 5.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \see             ecp.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param grp       The context for the elliptic curve to use.</span></span><br><span class="line"><span class="comment"> *                  This must be initialized and have group parameters</span></span><br><span class="line"><span class="comment"> *                  set, for example through mbedtls_ecp_group_load().</span></span><br><span class="line"><span class="comment"> * \param r         The MPI context in which to store the first part</span></span><br><span class="line"><span class="comment"> *                  the signature. This must be initialized.</span></span><br><span class="line"><span class="comment"> * \param s         The MPI context in which to store the second part</span></span><br><span class="line"><span class="comment"> *                  the signature. This must be initialized.</span></span><br><span class="line"><span class="comment"> * \param d         The private signing key. This must be initialized.</span></span><br><span class="line"><span class="comment"> * \param buf       The content to be signed. This is usually the hash of</span></span><br><span class="line"><span class="comment"> *                  the original data to be signed. This must be a readable</span></span><br><span class="line"><span class="comment"> *                  buffer of length \p blen Bytes. It may be \c NULL if</span></span><br><span class="line"><span class="comment"> *                  \p blen is zero.</span></span><br><span class="line"><span class="comment"> * \param blen      The length of \p buf in Bytes.</span></span><br><span class="line"><span class="comment"> * \param f_rng     The RNG function. This must not be \c NULL.</span></span><br><span class="line"><span class="comment"> * \param p_rng     The RNG context to be passed to \p f_rng. This may be</span></span><br><span class="line"><span class="comment"> *                  \c NULL if \p f_rng doesn&#x27;t need a context parameter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return          \c 0 on success.</span></span><br><span class="line"><span class="comment"> * \return          An \c MBEDTLS_ERR_ECP_XXX</span></span><br><span class="line"><span class="comment"> *                  or \c MBEDTLS_MPI_XXX error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_ecdsa_sign</span><span class="params">( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> mbedtls_mpi *d, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> blen,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> (*f_rng)(<span class="keyword">void</span> *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>), <span class="keyword">void</span> *p_rng )</span></span>;</span><br></pre></td></tr></table></figure><p>④ ECDSA验证签名接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief           This function verifies the ECDSA signature of a</span></span><br><span class="line"><span class="comment"> *                  previously-hashed message.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note            If the bitlength of the message hash is larger than the</span></span><br><span class="line"><span class="comment"> *                  bitlength of the group order, then the hash is truncated as</span></span><br><span class="line"><span class="comment"> *                  defined in &lt;em&gt;Standards for Efficient Cryptography Group</span></span><br><span class="line"><span class="comment"> *                  (SECG): SEC1 Elliptic Curve Cryptography&lt;/em&gt;, section</span></span><br><span class="line"><span class="comment"> *                  4.1.4, step 3.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \see             ecp.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param grp       The ECP group to use.</span></span><br><span class="line"><span class="comment"> *                  This must be initialized and have group parameters</span></span><br><span class="line"><span class="comment"> *                  set, for example through mbedtls_ecp_group_load().</span></span><br><span class="line"><span class="comment"> * \param buf       The hashed content that was signed. This must be a readable</span></span><br><span class="line"><span class="comment"> *                  buffer of length \p blen Bytes. It may be \c NULL if</span></span><br><span class="line"><span class="comment"> *                  \p blen is zero.</span></span><br><span class="line"><span class="comment"> * \param blen      The length of \p buf in Bytes.</span></span><br><span class="line"><span class="comment"> * \param Q         The public key to use for verification. This must be</span></span><br><span class="line"><span class="comment"> *                  initialized and setup.</span></span><br><span class="line"><span class="comment"> * \param r         The first integer of the signature.</span></span><br><span class="line"><span class="comment"> *                  This must be initialized.</span></span><br><span class="line"><span class="comment"> * \param s         The second integer of the signature.</span></span><br><span class="line"><span class="comment"> *                  This must be initialized.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return          \c 0 on success.</span></span><br><span class="line"><span class="comment"> * \return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the signature</span></span><br><span class="line"><span class="comment"> *                  is invalid.</span></span><br><span class="line"><span class="comment"> * \return          An \c MBEDTLS_ERR_ECP_XXX or \c MBEDTLS_MPI_XXX</span></span><br><span class="line"><span class="comment"> *                  error code on failure for any other reason.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_ecdsa_verify</span><span class="params">( mbedtls_ecp_group *grp,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> blen,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> mbedtls_ecp_point *Q, <span class="keyword">const</span> mbedtls_mpi *r,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> mbedtls_mpi *s)</span></span>;</span><br></pre></td></tr></table></figure><p>⑤ 释放ECDSA结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief           This function frees an ECDSA context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param ctx       The ECDSA context to free. This may be \c NULL,</span></span><br><span class="line"><span class="comment"> *                  in which case this function does nothing. If it</span></span><br><span class="line"><span class="comment"> *                  is not \c NULL, it must be initialized.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_ecdsa_free</span><span class="params">( mbedtls_ecdsa_context *ctx )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="编写测试函数-6">8.3.3 编写测试函数</h3><p>新建文件<code>mbedtls_ecdsa_test</code>，编写以下测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MBEDTLS_CONFIG_FILE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> MBEDTLS_CONFIG_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MBEDTLS_ECDSA_C)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/entropy.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/ctr_drbg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/ecdsa.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> buf[<span class="number">97</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dump_buf</span><span class="params">(<span class="keyword">uint8_t</span> *buf, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s%02X%s&quot;</span>, i % <span class="number">16</span> == <span class="number">0</span> ? <span class="string">&quot;\r\n\t&quot;</span> : <span class="string">&quot; &quot;</span>, </span><br><span class="line">                           buf[i], </span><br><span class="line">                           i == len - <span class="number">1</span> ? <span class="string">&quot;\r\n&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_ecdsa_test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">size_t</span> qlen, dlen;</span><br><span class="line">    <span class="keyword">size_t</span> rlen, slen;</span><br><span class="line">    <span class="keyword">uint8_t</span> hash[<span class="number">32</span>];</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *msg  = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pers = <span class="string">&quot;ecdsa_test&quot;</span>;</span><br><span class="line">    mbedtls_entropy_context entropy;</span><br><span class="line">    mbedtls_ctr_drbg_context ctr_drbg;</span><br><span class="line">    mbedtls_mpi r, s;</span><br><span class="line">    mbedtls_ecdsa_context ctx;</span><br><span class="line">    <span class="keyword">mbedtls_md_context_t</span> md_ctx;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 1. init structure */</span></span><br><span class="line">    mbedtls_md_init(&amp;md_ctx);</span><br><span class="line">    mbedtls_entropy_init(&amp;entropy);</span><br><span class="line">    mbedtls_ctr_drbg_init(&amp;ctr_drbg);</span><br><span class="line">    mbedtls_mpi_init(&amp;r);</span><br><span class="line">    mbedtls_mpi_init(&amp;s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 2. update seed with we own interface ported */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . Seeding the random number generator...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_ctr_drbg_seed( &amp;ctr_drbg, mbedtls_entropy_func, &amp;entropy,</span><br><span class="line">                               (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *) pers,</span><br><span class="line">                               <span class="built_in">strlen</span>(pers));</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_ctr_drbg_seed returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 3. hash message */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . Hash message...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_md(mbedtls_md_info_from_type(MBEDTLS_MD_SHA256), (<span class="keyword">uint8_t</span> *)msg, <span class="built_in">strlen</span>(msg), hash);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_md returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* show hash */</span></span><br><span class="line">    dump_buf(hash, <span class="keyword">sizeof</span>(hash));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 4. generate keypair */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . Generate ecdsa keypair...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_ecdsa_genkey(&amp;ctx, MBEDTLS_ECP_DP_SECP256R1, mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_ecdsa_genkey returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* show keypair */</span></span><br><span class="line">    mbedtls_ecp_point_write_binary(&amp;ctx.grp, &amp;ctx.Q, MBEDTLS_ECP_PF_UNCOMPRESSED, &amp;qlen, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    dlen = mbedtls_mpi_size(&amp;ctx.d);</span><br><span class="line">    mbedtls_mpi_write_binary(&amp;ctx.d, buf + qlen, dlen);</span><br><span class="line">    dump_buf(buf, qlen + dlen);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 5. ecdsa sign */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . ECDSA sign...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_ecdsa_sign(&amp;ctx.grp, &amp;r, &amp;s, &amp;ctx.d, hash, <span class="keyword">sizeof</span>(hash), mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_ecdsa_sign returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* show sign */</span></span><br><span class="line">    rlen = mbedtls_mpi_size(&amp;r);</span><br><span class="line">    slen = mbedtls_mpi_size(&amp;s);</span><br><span class="line">    mbedtls_mpi_write_binary(&amp;r, buf, rlen);</span><br><span class="line">    mbedtls_mpi_write_binary(&amp;s, buf + rlen, slen);</span><br><span class="line">    dump_buf(buf, rlen + slen);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 6. ecdsa verify */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . ECDSA verify...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_ecdsa_verify(&amp;ctx.grp, hash, <span class="keyword">sizeof</span>(hash), &amp;ctx.Q, &amp;r, &amp;s);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_ecdsa_verify returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 7. release structure */</span></span><br><span class="line">    mbedtls_ctr_drbg_free(&amp;ctr_drbg);</span><br><span class="line">    mbedtls_entropy_free(&amp;entropy);</span><br><span class="line">    mbedtls_mpi_free(&amp;r);</span><br><span class="line">    mbedtls_mpi_free(&amp;s);</span><br><span class="line">    mbedtls_md_free(&amp;md_ctx);</span><br><span class="line">    mbedtls_ecdsa_free(&amp;ctx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MBEDTLS_DHM_C */</span></span></span><br></pre></td></tr></table></figure><h3 id="测试结果-7">8.3.4 测试结果</h3><p>在main.c中声明该函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">mbedtls_ecdsa_test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在main函数中调用该函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 9. ecdsa sign test */</span></span><br><span class="line">mbedtls_ecdsa_test();</span><br></pre></td></tr></table></figure><p>编译、下载，在串口助手中查看结果：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201003193818564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><h1 id="九、数字证书及-X-509-证书标准">9 九、数字证书及 X.509 证书标准</h1><h2 id="X-509证书标准">9.1 X.509证书标准</h2><p>X.509是数字证书的一种标准格式，由国际电信联盟的标准化部分定义。</p><h3 id="X-509证书的结构">9.1.1 X.509证书的结构</h3><p>X.509证书主要包括12个字段，如下表：</p><table><thead><tr><th>名称</th><th>字段</th><th>意义</th></tr></thead><tbody><tr><td>Version</td><td>版本</td><td>证书版本</td></tr><tr><td>Serial number</td><td>序列号</td><td>证书的唯一序列号</td></tr><tr><td>Signature</td><td>签名算法</td><td>CA对证书进行签名所使用的签名算法</td></tr><tr><td>Issuer</td><td>发行商名称</td><td>标识对证书进行签名并颁发的实体</td></tr><tr><td>Validity</td><td>有效期</td><td>标识证书的生效日期和终止日期</td></tr><tr><td>Subject</td><td>证书主体名称</td><td>标识获得证书的主体</td></tr><tr><td>Subject public key infomation</td><td>公钥</td><td>用于指示使用者公钥信息</td></tr><tr><td>Issure unique ID</td><td>颁发者唯一标识</td><td>用于标识证书签发机构</td></tr><tr><td>subject unique ID</td><td>使用者唯一标识</td><td>用于标识证书使用者实体</td></tr><tr><td>Extensions</td><td>扩展</td><td>一个或多个扩展域</td></tr><tr><td>signature Algorithm</td><td>签名算法</td><td>标识CA对证书签名所使用的签名算法和参数</td></tr><tr><td>signature Value</td><td>签名值</td><td>CA对证书的签名结果</td></tr></tbody></table><h3 id="获取证书示例（百度）">9.1.2 获取证书示例（百度）</h3><p>下面以百度的证书为例讲解X.509证书标准。</p><p>使用浏览器访问百度首页：<a href="https://www.baidu.com/%EF%BC%8C%E7%82%B9%E5%87%BB%E5%9F%9F%E5%90%8D%E6%97%81%E8%BE%B9%E7%9A%84%E3%80%90%E5%B0%8F%E7%BB%BF%E9%94%81%E3%80%91%EF%BC%8C%E7%82%B9%E5%87%BB%E3%80%90%E8%AF%81%E4%B9%A6%E3%80%91%E3%80%82">https://www.baidu.com/，点击域名旁边的【小绿锁】，点击【证书】。</a><br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201003204805665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>点击之后即可查看到百度的证书：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201003204907406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>① 点击【证书路径】，将一级证书（根证书）导出：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201003205037671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>点击【详细信息】，将此证书内容【复制到文件】：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201003205127263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="、"><br>进入证书导出向导：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/2020100320522449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>选择使用【Base64编码】导出：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/2020100320531961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>选择导出文件路径：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201003205427731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>导出成功：<img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201003205524237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>② 同样的方法，将二级证书导出为baidu_2.cer：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201003205629372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>③ 同样的方法，将三级证书导出为baidu_3.cer：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201003205710197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>三份证书如图：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/2020100320581770.png#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>使用记事本打开任意一份，可以看到该证书内容：<img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201003205912844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br><strong>新建一个空文件<code>baidu_ca.txt</code>，将三份内容按照次序复制到该文件中，后续使用</strong>。<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201003210126170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><h3 id="查看百度证书内容">9.1.3 查看百度证书内容</h3><p>使用openssl工具查看刚刚获取的百度证书内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -text -<span class="keyword">in</span> baidu_3.cer -noout</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>① 证书颁发者和使用者信息：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201004102053366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>② 公钥算法和公钥内容：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201004101257191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>③ 签名算法和内容：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/2020100410141193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"><br>同样的方法可以查看百度二级证书和百度一级证书（根证书）的内容。</p><h2 id="X509证书解析验证功能的配置与使用">9.2 X509证书解析验证功能的配置与使用</h2><h3 id="配置宏-7">9.2.1 配置宏</h3><p>①</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_PK_C</span></span><br></pre></td></tr></table></figure><p>②</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_PK_PARSE_C</span></span><br></pre></td></tr></table></figure><p>③</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ASN1_PARSE_C</span></span><br></pre></td></tr></table></figure><p>④</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ASN1_WRITE_C</span></span><br></pre></td></tr></table></figure><p>⑤</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_X509_USE_C</span></span><br></pre></td></tr></table></figure><p>⑥</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_BASE64_C</span></span><br></pre></td></tr></table></figure><p>⑦</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_PEM_PARSE_C</span></span><br></pre></td></tr></table></figure><p>⑧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_X509_CRT_PARSE_C</span></span><br></pre></td></tr></table></figure><p>新建配置文件<code>mbedtls_config_x509.h</code>，编辑以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MBEDTLS_CONFIG_X509_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MBEDTLS_CONFIG_X509_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* System support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_HAVE_ASM</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_HAVE_TIME</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed feature support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ENTROPY_HARDWARE_ALT</span></span><br><span class="line"><span class="comment">//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_NO_PLATFORM_ENTROPY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* mbed modules */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA1_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_SHA256_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_MD_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_BIGNUM_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_OID_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_RSA_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_PKCS1_V21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_PK_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_PK_PARSE_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ASN1_PARSE_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ASN1_WRITE_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_X509_USE_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_BASE64_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_PEM_PARSE_C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_X509_CRT_PARSE_C</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/check_config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _MBEDTLS_CONFIG_X509_H_ */</span></span></span><br></pre></td></tr></table></figure><p>在MDK中配置使用该文件：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201004132201128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p><h3 id="API说明-1">9.2.2 API说明</h3><p>使用时需要包含头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/x509_crt.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>① 初始化证书结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_x509_crt_init</span><span class="params">( mbedtls_x509_crt *crt )</span></span>;</span><br></pre></td></tr></table></figure><p>② 证书解析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          Parse one DER-encoded or one or more concatenated PEM-encoded</span></span><br><span class="line"><span class="comment"> *                 certificates and add them to the chained list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                 For CRTs in PEM encoding, the function parses permissively:</span></span><br><span class="line"><span class="comment"> *                 if at least one certificate can be parsed, the function</span></span><br><span class="line"><span class="comment"> *                 returns the number of certificates for which parsing failed</span></span><br><span class="line"><span class="comment"> *                 (hence \c 0 if all certificates were parsed successfully).</span></span><br><span class="line"><span class="comment"> *                 If no certificate could be parsed, the function returns</span></span><br><span class="line"><span class="comment"> *                 the first (negative) error encountered during parsing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                 PEM encoded certificates may be interleaved by other data</span></span><br><span class="line"><span class="comment"> *                 such as human readable descriptions of their content, as</span></span><br><span class="line"><span class="comment"> *                 long as the certificates are enclosed in the PEM specific</span></span><br><span class="line"><span class="comment"> *                 &#x27;-----&#123;BEGIN/END&#125; CERTIFICATE-----&#x27; delimiters.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param chain    The chain to which to add the parsed certificates.</span></span><br><span class="line"><span class="comment"> * \param buf      The buffer holding the certificate data in PEM or DER format.</span></span><br><span class="line"><span class="comment"> *                 For certificates in PEM encoding, this may be a concatenation</span></span><br><span class="line"><span class="comment"> *                 of multiple certificates; for DER encoding, the buffer must</span></span><br><span class="line"><span class="comment"> *                 comprise exactly one certificate.</span></span><br><span class="line"><span class="comment"> * \param buflen   The size of \p buf, including the terminating \c NULL byte</span></span><br><span class="line"><span class="comment"> *                 in case of PEM encoded data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return         \c 0 if all certificates were parsed successfully.</span></span><br><span class="line"><span class="comment"> * \return         The (positive) number of certificates that couldn&#x27;t</span></span><br><span class="line"><span class="comment"> *                 be parsed if parsing was partly successful (see above).</span></span><br><span class="line"><span class="comment"> * \return         A negative X509 or PEM error code otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_x509_crt_parse</span><span class="params">( mbedtls_x509_crt *chain, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen )</span></span>;</span><br></pre></td></tr></table></figure><p>③ 获取证书信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          Returns an informational string about the</span></span><br><span class="line"><span class="comment"> *                 certificate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param buf      Buffer to write to</span></span><br><span class="line"><span class="comment"> * \param size     Maximum size of buffer</span></span><br><span class="line"><span class="comment"> * \param prefix   A line prefix</span></span><br><span class="line"><span class="comment"> * \param crt      The X509 certificate to represent</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return         The length of the string written (not including the</span></span><br><span class="line"><span class="comment"> *                 terminated nul byte), or a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_x509_crt_info</span><span class="params">( <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *prefix,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> mbedtls_x509_crt *crt )</span></span>;</span><br></pre></td></tr></table></figure><p>④ 获取证书认证信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          Returns an informational string about the</span></span><br><span class="line"><span class="comment"> *                 verification status of a certificate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param buf      Buffer to write to</span></span><br><span class="line"><span class="comment"> * \param size     Maximum size of buffer</span></span><br><span class="line"><span class="comment"> * \param prefix   A line prefix</span></span><br><span class="line"><span class="comment"> * \param flags    Verification flags created by mbedtls_x509_crt_verify()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return         The length of the string written (not including the</span></span><br><span class="line"><span class="comment"> *                 terminated nul byte), or a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_x509_crt_verify_info</span><span class="params">( <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *prefix,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">uint32_t</span> flags )</span></span>;</span><br></pre></td></tr></table></figure><p>⑤ 证书认证</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          Verify a chain of certificates.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                 The verify callback is a user-supplied callback that</span></span><br><span class="line"><span class="comment"> *                 can clear / modify / add flags for a certificate. If set,</span></span><br><span class="line"><span class="comment"> *                 the verification callback is called for each</span></span><br><span class="line"><span class="comment"> *                 certificate in the chain (from the trust-ca down to the</span></span><br><span class="line"><span class="comment"> *                 presented crt). The parameters for the callback are:</span></span><br><span class="line"><span class="comment"> *                 (void *parameter, mbedtls_x509_crt *crt, int certificate_depth,</span></span><br><span class="line"><span class="comment"> *                 int *flags). With the flags representing current flags for</span></span><br><span class="line"><span class="comment"> *                 that specific certificate and the certificate depth from</span></span><br><span class="line"><span class="comment"> *                 the bottom (Peer cert depth = 0).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                 All flags left after returning from the callback</span></span><br><span class="line"><span class="comment"> *                 are also returned to the application. The function should</span></span><br><span class="line"><span class="comment"> *                 return 0 for anything (including invalid certificates)</span></span><br><span class="line"><span class="comment"> *                 other than fatal error, as a non-zero return code</span></span><br><span class="line"><span class="comment"> *                 immediately aborts the verification process. For fatal</span></span><br><span class="line"><span class="comment"> *                 errors, a specific error code should be used (different</span></span><br><span class="line"><span class="comment"> *                 from MBEDTLS_ERR_X509_CERT_VERIFY_FAILED which should not</span></span><br><span class="line"><span class="comment"> *                 be returned at this point), or MBEDTLS_ERR_X509_FATAL_ERROR</span></span><br><span class="line"><span class="comment"> *                 can be used if no better code is available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           In case verification failed, the results can be displayed</span></span><br><span class="line"><span class="comment"> *                 using \c mbedtls_x509_crt_verify_info()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           Same as \c mbedtls_x509_crt_verify_with_profile() with the</span></span><br><span class="line"><span class="comment"> *                 default security profile.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           It is your responsibility to provide up-to-date CRLs for</span></span><br><span class="line"><span class="comment"> *                 all trusted CAs. If no CRL is provided for the CA that was</span></span><br><span class="line"><span class="comment"> *                 used to sign the certificate, CRL verification is skipped</span></span><br><span class="line"><span class="comment"> *                 silently, that is *without* setting any flag.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \note           The \c trust_ca list can contain two types of certificates:</span></span><br><span class="line"><span class="comment"> *                 (1) those of trusted root CAs, so that certificates</span></span><br><span class="line"><span class="comment"> *                 chaining up to those CAs will be trusted, and (2)</span></span><br><span class="line"><span class="comment"> *                 self-signed end-entity certificates to be trusted (for</span></span><br><span class="line"><span class="comment"> *                 specific peers you know) - in that case, the self-signed</span></span><br><span class="line"><span class="comment"> *                 certificate doesn&#x27;t need to have the CA bit set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param crt      The certificate chain to be verified.</span></span><br><span class="line"><span class="comment"> * \param trust_ca The list of trusted CAs.</span></span><br><span class="line"><span class="comment"> * \param ca_crl   The list of CRLs for trusted CAs.</span></span><br><span class="line"><span class="comment"> * \param cn       The expected Common Name. This will be checked to be</span></span><br><span class="line"><span class="comment"> *                 present in the certificate&#x27;s subjectAltNames extension or,</span></span><br><span class="line"><span class="comment"> *                 if this extension is absent, as a CN component in its</span></span><br><span class="line"><span class="comment"> *                 Subject name. Currently only DNS names are supported. This</span></span><br><span class="line"><span class="comment"> *                 may be \c NULL if the CN need not be verified.</span></span><br><span class="line"><span class="comment"> * \param flags    The address at which to store the result of the verification.</span></span><br><span class="line"><span class="comment"> *                 If the verification couldn&#x27;t be completed, the flag value is</span></span><br><span class="line"><span class="comment"> *                 set to (uint32_t) -1.</span></span><br><span class="line"><span class="comment"> * \param f_vrfy   The verification callback to use. See the documentation</span></span><br><span class="line"><span class="comment"> *                 of mbedtls_x509_crt_verify() for more information.</span></span><br><span class="line"><span class="comment"> * \param p_vrfy   The context to be passed to \p f_vrfy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return         \c 0 if the chain is valid with respect to the</span></span><br><span class="line"><span class="comment"> *                 passed CN, CAs, CRLs and security profile.</span></span><br><span class="line"><span class="comment"> * \return         #MBEDTLS_ERR_X509_CERT_VERIFY_FAILED in case the</span></span><br><span class="line"><span class="comment"> *                 certificate chain verification failed. In this case,</span></span><br><span class="line"><span class="comment"> *                 \c *flags will have one or more</span></span><br><span class="line"><span class="comment"> *                 \c MBEDTLS_X509_BADCERT_XXX or \c MBEDTLS_X509_BADCRL_XXX</span></span><br><span class="line"><span class="comment"> *                 flags set.</span></span><br><span class="line"><span class="comment"> * \return         Another negative error code in case of a fatal error</span></span><br><span class="line"><span class="comment"> *                 encountered during the verification process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_x509_crt_verify</span><span class="params">( mbedtls_x509_crt *crt,</span></span></span><br><span class="line"><span class="function"><span class="params">                     mbedtls_x509_crt *trust_ca,</span></span></span><br><span class="line"><span class="function"><span class="params">                     mbedtls_x509_crl *ca_crl,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="keyword">char</span> *cn, <span class="keyword">uint32_t</span> *flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> (*f_vrfy)(<span class="keyword">void</span> *, mbedtls_x509_crt *, <span class="keyword">int</span>, <span class="keyword">uint32_t</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">void</span> *p_vrfy )</span></span>;</span><br></pre></td></tr></table></figure><p>⑥ 释放证书结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \brief          Unallocate all certificate data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param crt      Certificate chain to free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mbedtls_x509_crt_free</span><span class="params">( mbedtls_x509_crt *crt )</span></span>;</span><br></pre></td></tr></table></figure><p>⑦ 错误码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * \name X509 Error codes</span></span><br><span class="line"><span class="comment"> * \&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE              -0x2080  <span class="comment">/**&lt; Unavailable feature, e.g. RSA hashing/encryption combination. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_UNKNOWN_OID                      -0x2100  <span class="comment">/**&lt; Requested OID is unknown. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_INVALID_FORMAT                   -0x2180  <span class="comment">/**&lt; The CRT/CRL/CSR format is invalid, e.g. different type expected. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_INVALID_VERSION                  -0x2200  <span class="comment">/**&lt; The CRT/CRL/CSR version element is invalid. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_INVALID_SERIAL                   -0x2280  <span class="comment">/**&lt; The serial tag or value is invalid. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_INVALID_ALG                      -0x2300  <span class="comment">/**&lt; The algorithm tag or value is invalid. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_INVALID_NAME                     -0x2380  <span class="comment">/**&lt; The name tag or value is invalid. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_INVALID_DATE                     -0x2400  <span class="comment">/**&lt; The date tag or value is invalid. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_INVALID_SIGNATURE                -0x2480  <span class="comment">/**&lt; The signature tag or value invalid. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_INVALID_EXTENSIONS               -0x2500  <span class="comment">/**&lt; The extension tag or value is invalid. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_UNKNOWN_VERSION                  -0x2580  <span class="comment">/**&lt; CRT/CRL/CSR has an unsupported version number. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG                  -0x2600  <span class="comment">/**&lt; Signature algorithm (oid) is unsupported. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_SIG_MISMATCH                     -0x2680  <span class="comment">/**&lt; Signature algorithms do not match. (see \c ::mbedtls_x509_crt sig_oid) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_CERT_VERIFY_FAILED               -0x2700  <span class="comment">/**&lt; Certificate verification failed, e.g. CRL, CA or signature check failed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT              -0x2780  <span class="comment">/**&lt; Format not recognized as DER or PEM. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_BAD_INPUT_DATA                   -0x2800  <span class="comment">/**&lt; Input invalid. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_ALLOC_FAILED                     -0x2880  <span class="comment">/**&lt; Allocation of memory failed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_FILE_IO_ERROR                    -0x2900  <span class="comment">/**&lt; Read/write of file failed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_BUFFER_TOO_SMALL                 -0x2980  <span class="comment">/**&lt; Destination buffer is too small. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBEDTLS_ERR_X509_FATAL_ERROR                      -0x3000  <span class="comment">/**&lt; A fatal error occurred, eg the chain is too long or the vrfy callback failed. */</span></span></span><br></pre></td></tr></table></figure><h3 id="编写测试函数-7">9.2.3 编写测试函数</h3><p>编写头文件<code>baidu_certs.h</code>，将百度的证书存储：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __CERTS_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __CERTS_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> baidu_ca_cert[] =</span><br><span class="line"><span class="string">&quot;-----BEGIN CERTIFICATE-----\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;MIIKLjCCCRagAwIBAgIMclh4Nm6fVugdQYhIMA0GCSqGSIb3DQEBCwUAMGYxCzAJ\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;BgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMTwwOgYDVQQDEzNH\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;bG9iYWxTaWduIE9yZ2FuaXphdGlvbiBWYWxpZGF0aW9uIENBIC0gU0hBMjU2IC0g\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;RzIwHhcNMjAwNDAyMDcwNDU4WhcNMjEwNzI2MDUzMTAyWjCBpzELMAkGA1UEBhMC\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;Q04xEDAOBgNVBAgTB2JlaWppbmcxEDAOBgNVBAcTB2JlaWppbmcxJTAjBgNVBAsT\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;HHNlcnZpY2Ugb3BlcmF0aW9uIGRlcGFydG1lbnQxOTA3BgNVBAoTMEJlaWppbmcg\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;QmFpZHUgTmV0Y29tIFNjaWVuY2UgVGVjaG5vbG9neSBDby4sIEx0ZDESMBAGA1UE\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;AxMJYmFpZHUuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwamw\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;rkca0lfrHRUfblyy5PgLINvqAN8p/6RriSZLnyMv7FewirhGQCp+vNxaRZdPrUEO\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;vCCGSwxdVSFH4jE8V6fsmUfrRw1y18gWVHXv00URD0vOYHpGXCh0ro4bvthwZnuo\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;k0ko0qN2lFXefCfyD/eYDK2G2sau/Z/w2YEympfjIe4EkpbkeBHlxBAOEDF6Speg\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;68ebxNqJN6nDN9dWsX9Sx9kmCtavOBaxbftzebFoeQOQ64h7jEiRmFGlB5SGpXhG\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;eY9Ym+k1Wafxe1cxCpDPJM4NJOeSsmrp5pY3Crh8hy900lzoSwpfZhinQYbPJqYI\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;jqVJF5JTs5Glz1OwMQIDAQABo4IGmDCCBpQwDgYDVR0PAQH/BAQDAgWgMIGgBggr\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;BgEFBQcBAQSBkzCBkDBNBggrBgEFBQcwAoZBaHR0cDovL3NlY3VyZS5nbG9iYWxz\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;aWduLmNvbS9jYWNlcnQvZ3Nvcmdhbml6YXRpb252YWxzaGEyZzJyMS5jcnQwPwYI\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;KwYBBQUHMAGGM2h0dHA6Ly9vY3NwMi5nbG9iYWxzaWduLmNvbS9nc29yZ2FuaXph\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;dGlvbnZhbHNoYTJnMjBWBgNVHSAETzBNMEEGCSsGAQQBoDIBFDA0MDIGCCsGAQUF\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;BwIBFiZodHRwczovL3d3dy5nbG9iYWxzaWduLmNvbS9yZXBvc2l0b3J5LzAIBgZn\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;gQwBAgIwCQYDVR0TBAIwADBJBgNVHR8EQjBAMD6gPKA6hjhodHRwOi8vY3JsLmds\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;b2JhbHNpZ24uY29tL2dzL2dzb3JnYW5pemF0aW9udmFsc2hhMmcyLmNybDCCA04G\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;A1UdEQSCA0UwggNBggliYWlkdS5jb22CDGJhaWZ1YmFvLmNvbYIMd3d3LmJhaWR1\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;LmNughB3d3cuYmFpZHUuY29tLmNugg9tY3QueS5udW9taS5jb22CC2Fwb2xsby5h\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;dXRvggZkd3ouY26CCyouYmFpZHUuY29tgg4qLmJhaWZ1YmFvLmNvbYIRKi5iYWlk\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;dXN0YXRpYy5jb22CDiouYmRzdGF0aWMuY29tggsqLmJkaW1nLmNvbYIMKi5oYW8x\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;MjMuY29tggsqLm51b21pLmNvbYINKi5jaHVhbmtlLmNvbYINKi50cnVzdGdvLmNv\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;bYIPKi5iY2UuYmFpZHUuY29tghAqLmV5dW4uYmFpZHUuY29tgg8qLm1hcC5iYWlk\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;dS5jb22CDyoubWJkLmJhaWR1LmNvbYIRKi5mYW55aS5iYWlkdS5jb22CDiouYmFp\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;ZHViY2UuY29tggwqLm1pcGNkbi5jb22CECoubmV3cy5iYWlkdS5jb22CDiouYmFp\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;ZHVwY3MuY29tggwqLmFpcGFnZS5jb22CCyouYWlwYWdlLmNugg0qLmJjZWhvc3Qu\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;Y29tghAqLnNhZmUuYmFpZHUuY29tgg4qLmltLmJhaWR1LmNvbYISKi5iYWlkdWNv\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;bnRlbnQuY29tggsqLmRsbmVsLmNvbYILKi5kbG5lbC5vcmeCEiouZHVlcm9zLmJh\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;aWR1LmNvbYIOKi5zdS5iYWlkdS5jb22CCCouOTEuY29tghIqLmhhbzEyMy5iYWlk\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;dS5jb22CDSouYXBvbGxvLmF1dG+CEioueHVlc2h1LmJhaWR1LmNvbYIRKi5iai5i\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;YWlkdWJjZS5jb22CESouZ3ouYmFpZHViY2UuY29tgg4qLnNtYXJ0YXBwcy5jboIN\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;Ki5iZHRqcmN2LmNvbYIMKi5oYW8yMjIuY29tggwqLmhhb2thbi5jb22CDyoucGFl\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;LmJhaWR1LmNvbYIRKi52ZC5iZHN0YXRpYy5jb22CEmNsaWNrLmhtLmJhaWR1LmNv\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;bYIQbG9nLmhtLmJhaWR1LmNvbYIQY20ucG9zLmJhaWR1LmNvbYIQd24ucG9zLmJh\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;aWR1LmNvbYIUdXBkYXRlLnBhbi5iYWlkdS5jb20wHQYDVR0lBBYwFAYIKwYBBQUH\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;AwEGCCsGAQUFBwMCMB8GA1UdIwQYMBaAFJbeYfG9HBYpUxzAzH07gwBA5hp8MB0G\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;A1UdDgQWBBSeyXnX6VurihbMMo7GmeafIEI1hzCCAX4GCisGAQQB1nkCBAIEggFu\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;BIIBagFoAHYAXNxDkv7mq0VEsV6a1FbmEDf71fpH3KFzlLJe5vbHDsoAAAFxObU8\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;ugAABAMARzBFAiBphmgxIbNZXaPWiUqXRWYLaRST38KecoekKIof5fXmsgIhAMkZ\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;tF8XyKCu/nZll1e9vIlKbW8RrUr/74HpmScVRRsBAHYAb1N2rDHwMRnYmQCkURX/\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;dxUcEdkCwQApBo2yCJo32RMAAAFxObU85AAABAMARzBFAiBURWwwTgXZ+9IV3mhm\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;E0EOzbg901DLRszbLIpafDY/XgIhALsvEGqbBVrpGxhKoTVlz7+GWom8SrfUeHcn\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;4+9Dn7xGAHYA9lyUL9F3MCIUVBgIMJRWjuNNExkzv98MLyALzE7xZOMAAAFxObU8\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;qwAABAMARzBFAiBFBYPxKEdhlf6bqbwxQY7tskgdoFulPxPmdrzS5tNpPwIhAKnK\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;qwzch98lINQYzLAV52+C8GXZPXFZNfhfpM4tQ6xbMA0GCSqGSIb3DQEBCwUAA4IB\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;AQC83ALQ2d6MxeLZ/k3vutEiizRCWYSSMYLVCrxANdsGshNuyM8B8V/A57c0Nzqo\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;CPKfMtX5IICfv9P/bUecdtHL8cfx24MzN+U/GKcA4r3a/k8pRVeHeF9ThQ2zo1xj\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;k/7gJl75koztdqNfOeYiBTbFMnPQzVGqyMMfqKxbJrfZlGAIgYHT9bd6T985IVgz\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;tRVjAoy4IurZenTsWkG7PafJ4kAh6jQaSu1zYEbHljuZ5PXlkhPO9DwW1WIPug6Z\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;rlylLTTYmlW3WETOATi70HYsZN6NACuZ4t1hEO3AsF7lqjdA2HwTN10FX2HuaUvf\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;5OzP+PKupV9VKw8x8mQKU6vr\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;-----END CERTIFICATE-----\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>编写测试函数文件<code>mbedtls_x509_test.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   X509 Function demo</span></span><br><span class="line"><span class="comment"> * @author  mculover666</span></span><br><span class="line"><span class="comment"> * @date    2020/10/04</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MBEDTLS_CONFIG_FILE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> MBEDTLS_CONFIG_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MBEDTLS_X509_CRT_PARSE_C)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mbedtls/x509_crt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;baidu_certs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbedtls_x509_test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">   </span><br><span class="line">    mbedtls_x509_crt cert, cacert;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. init structure */</span></span><br><span class="line">    mbedtls_x509_crt_init(&amp;cert);</span><br><span class="line">    mbedtls_x509_crt_init(&amp;cacert);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. Parser cacert */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . Parse cacert...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_x509_crt_parse(&amp;cacert, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)baidu_ca_cert, <span class="keyword">sizeof</span>(baidu_ca_cert));</span><br><span class="line">     <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot; failed\n  ! mbedtls_x509_crt_parse cacert returned %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot; ok\n&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 2. Cacert parser result */</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n  . Cacert parser result...&quot;</span> );</span><br><span class="line">    </span><br><span class="line">    ret = mbedtls_x509_crt_info(buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="string">&quot;      &quot;</span>, &amp;cacert);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail! mbedtls_x509_crt_info return %d(-0x%04x)\n&quot;</span>, ret, -ret);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf[ret] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ok!\r\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;crt info has %d chars\r\n&quot;</span>, <span class="built_in">strlen</span>(buf));    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\r\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>:  </span><br><span class="line">    <span class="comment">/* 3. release structure */</span></span><br><span class="line">    mbedtls_x509_crt_free(&amp;cert);</span><br><span class="line">    mbedtls_x509_crt_free(&amp;cacert);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MBEDTLS_RSA_C */</span></span></span><br></pre></td></tr></table></figure><h3 id="测试结果-8">9.2.4 测试结果</h3><p>在main.c中声明该测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">mbedtls_x509_test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在main函数中调用该测试函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 10. x509 test */</span></span><br><span class="line">mbedtls_x509_test();</span><br></pre></td></tr></table></figure><p>编译、下载、测试结果为：<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20201004131906865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01jdWxvdmVyNjY2,size_16,color_FFFFFF,t_70#pic_center" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> ESP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v2ray科学上网</title>
      <link href="posts/4461482.html"/>
      <url>posts/4461482.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装和更新-V2Ray">1 安装和更新 V2Ray</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装可执行文件和 .dat 数据文件</span><br><span class="line"># bash &lt;(curl -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;v2fly&#x2F;fhs-install-v2ray&#x2F;master&#x2F;install-release.sh)</span><br></pre></td></tr></table></figure><h1 id="安装最新发行的-geoip-dat-和-geosite-dat">2 安装最新发行的 geoip.dat 和 geosite.dat</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 只更新 .dat 数据文件</span><br><span class="line">bash &lt;(curl -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-dat-release.sh)</span><br></pre></td></tr></table></figure><h1 id="移除-V2Ray">3 移除 V2Ray</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh) --remove</span><br></pre></td></tr></table></figure><h1 id="修改配置文件">4 修改配置文件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/etc/v2ray/config.json</span><br><span class="line">systemctl enable v2ray</span><br><span class="line">systemctl start v2ray</span><br></pre></td></tr></table></figure><h1 id="配置为websocket">5 配置为websocket</h1><h2 id="server端">5.1 server端</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;log&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;loglevel&quot;</span>: <span class="string">&quot;warning&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;routing&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;domainStrategy&quot;</span>: <span class="string">&quot;AsIs&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;rules&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;field&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;ip&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;geoip:private&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;outboundTag&quot;</span>: <span class="string">&quot;block&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;inbounds&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;listen&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;port&quot;</span>: <span class="number">10809</span>,</span><br><span class="line">            <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;vmess&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;clients&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;b22e94d6-569d-6d71-46fd-f2183d92375c&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;streamSettings&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;network&quot;</span>: <span class="string">&quot;ws&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;outbounds&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;freedom&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;tag&quot;</span>: <span class="string">&quot;direct&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;blackhole&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;tag&quot;</span>: <span class="string">&quot;block&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="client端">5.2 client端</h2><p><img "" class="lazyload placeholder" data-original="/posts/4461482/vmess_ws.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="vmess_ws.png"></p><h1 id="配置为TCP">6 配置为TCP</h1><h2 id="server">6.1 server</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;log&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;loglevel&quot;</span>: <span class="string">&quot;warning&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;routing&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;domainStrategy&quot;</span>: <span class="string">&quot;AsIs&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;rules&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;field&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;ip&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;geoip:private&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;outboundTag&quot;</span>: <span class="string">&quot;block&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;inbounds&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;listen&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;port&quot;</span>: <span class="number">10809</span>,</span><br><span class="line">            <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;vmess&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;clients&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;b22e94d6-569d-6d71-46fd-f2183d92375c&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;streamSettings&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;network&quot;</span>: <span class="string">&quot;tcp&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;outbounds&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;freedom&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;tag&quot;</span>: <span class="string">&quot;direct&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;blackhole&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;tag&quot;</span>: <span class="string">&quot;block&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="client">6.2 client</h2><p><img "" class="lazyload placeholder" data-original="/posts/4461482/vmess_tcp.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="vmess_ws.png"></p><h1 id="快速链接">7 快速链接</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmess:&#x2F;&#x2F;ew0KICAidiI6ICIyIiwNCiAgInBzIjogImNyZWVrd2F0ZXIiLA0KICAiYWRkIjogImNyZWVrd2F0ZXIuaWN1IiwNCiAgInBvcnQiOiAiMTA4MDkiLA0KICAiaWQiOiAiYjIyZTk0ZDYtNTY5ZC02ZDcxLTQ2ZmQtZjIxODNkOTIzNzVjIiwNCiAgImFpZCI6ICIwIiwNCiAgIm5ldCI6ICJ3cyIsDQogICJ0eXBlIjogIm5vbmUiLA0KICAiaG9zdCI6ICIiLA0KICAicGF0aCI6ICIiLA0KICAidGxzIjogIiINCn0&#x3D;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐鑫coredump分析</title>
      <link href="posts/37a8bef3.html"/>
      <url>posts/37a8bef3.html</url>
      
        <content type="html"><![CDATA[<h1 id="UART-、ELF-FORMAT-、CRC32">1 UART 、ELF FORMAT 、CRC32</h1><table><thead><tr><th>text</th><th>data</th><th>bss</th><th>dec</th><th>hex</th><th>filename</th></tr></thead><tbody><tr><td>2417</td><td>112</td><td>1512</td><td>4041</td><td>fc9</td><td>core_dump_port.o</td></tr><tr><td>821</td><td>0</td><td>0</td><td>821</td><td>335</td><td>core_dump_flash.o</td></tr><tr><td>241</td><td>0</td><td>0</td><td>241</td><td>f1</td><td>core_dump_common.o</td></tr><tr><td>1304</td><td>0</td><td>0</td><td>1304</td><td>518</td><td>core_dump_uart.o</td></tr><tr><td>7913</td><td>0</td><td>388</td><td>8301</td><td>206d</td><td>core_dump_elf.o</td></tr></tbody></table><table><thead><tr><th>text</th><th>data</th><th>bss</th><th>dec</th></tr></thead><tbody><tr><td>12696</td><td>112</td><td>1900</td><td>14708</td></tr></tbody></table><h1 id="UART-、BIN-FORMAT、CRC32">2 UART 、BIN FORMAT、CRC32</h1><table><thead><tr><th>text</th><th>data</th><th>bss</th><th>dec</th><th>hex</th><th>filename</th></tr></thead><tbody><tr><td>2417</td><td>112</td><td>1512</td><td>4041</td><td>fc9</td><td>core_dump_port.o</td></tr><tr><td>821</td><td>0</td><td>0</td><td>821</td><td>335</td><td>core_dump_flash.o</td></tr><tr><td>2874</td><td>0</td><td>256</td><td>3130</td><td>c3a</td><td>core_dump_common.o</td></tr><tr><td>1304</td><td>0</td><td>0</td><td>1304</td><td>518</td><td>core_dump_uart.o</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>core_dump_elf.o</td></tr><tr><td>7416</td><td>112</td><td>1768</td><td>9296</td><td></td><td>SUM</td></tr></tbody></table><table><thead><tr><th>text</th><th>data</th><th>bss</th><th>dec</th></tr></thead><tbody><tr><td>7416</td><td>112</td><td>1768</td><td>9296</td></tr></tbody></table><h1 id="UART-、ELF-FORMAT-、SHA256">3 UART 、ELF FORMAT 、SHA256</h1><table><thead><tr><th>text</th><th>data</th><th>bss</th><th>dec</th><th>hex</th><th>filename</th></tr></thead><tbody><tr><td>2834</td><td>112</td><td>1512</td><td>4458</td><td>fc9</td><td>core_dump_port.o</td></tr><tr><td>1079</td><td>0</td><td>0</td><td>1079</td><td>437</td><td>core_dump_flash.o</td></tr><tr><td>241</td><td>0</td><td>0</td><td>241</td><td>f1</td><td>core_dump_common.o</td></tr><tr><td>1343</td><td>0</td><td>0</td><td>1343</td><td>53f</td><td>core_dump_uart.o</td></tr><tr><td>7913</td><td>0</td><td>388</td><td>8301</td><td>206d</td><td>core_dump_elf.o</td></tr></tbody></table><table><thead><tr><th>text</th><th>data</th><th>bss</th><th>dec</th></tr></thead><tbody><tr><td>13410</td><td>112</td><td>1900</td><td>15422</td></tr></tbody></table><h1 id="FLASH、ELF-FORMAT-、CRC32">4 FLASH、ELF FORMAT 、CRC32</h1><table><thead><tr><th>text</th><th>data</th><th>bss</th><th>dec</th><th>hex</th><th>filename</th></tr></thead><tbody><tr><td>2444</td><td>112</td><td>1512</td><td>4068</td><td>fe4</td><td>core_dump_port.o</td></tr><tr><td>3767</td><td>0</td><td>80</td><td>3847</td><td>f07</td><td>core_dump_flash.o</td></tr><tr><td>241</td><td>0</td><td>0</td><td>241</td><td>f1</td><td>core_dump_common.o</td></tr><tr><td>1343</td><td>0</td><td>0</td><td>1343</td><td>53f</td><td>core_dump_uart.o</td></tr><tr><td>7913</td><td>0</td><td>388</td><td>8301</td><td>206d</td><td>core_dump_elf.o</td></tr></tbody></table><table><thead><tr><th>text</th><th>data</th><th>bss</th><th>dec</th></tr></thead><tbody><tr><td>15617</td><td>112</td><td>1980</td><td>17709</td></tr></tbody></table><h1 id="FLASH、BIN-FORMAT-、CRC32">5 FLASH、BIN FORMAT 、CRC32</h1><table><thead><tr><th>text</th><th>data</th><th>bss</th><th>dec</th><th>hex</th><th>filename</th></tr></thead><tbody><tr><td>2444</td><td>112</td><td>1512</td><td>4068</td><td>fe4</td><td>core_dump_port.o</td></tr><tr><td>3767</td><td>0</td><td>80</td><td>3847</td><td>f07</td><td>core_dump_flash.o</td></tr><tr><td>2874</td><td>0</td><td>256</td><td>3130</td><td>c3a</td><td>core_dump_common.o</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>core_dump_uart.o</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>core_dump_elf.o</td></tr></tbody></table><table><thead><tr><th>text</th><th>data</th><th>bss</th><th>dec</th></tr></thead><tbody><tr><td>15617</td><td>112</td><td>1980</td><td>17709</td></tr></tbody></table><h1 id="FLASH、ELF-FORMAT-、SHA256">6 FLASH、ELF FORMAT 、SHA256</h1><table><thead><tr><th>text</th><th>data</th><th>bss</th><th>dec</th><th>hex</th><th>filename</th></tr></thead><tbody><tr><td>2861</td><td>112</td><td>1512</td><td>4485</td><td>1185</td><td>core_dump_port.o</td></tr><tr><td>4025</td><td>0</td><td>220</td><td>4245</td><td>1095</td><td>core_dump_flash.o</td></tr><tr><td>241</td><td>0</td><td>0</td><td>241</td><td>f1</td><td>core_dump_common.o</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>core_dump_uart.o</td></tr><tr><td>7913</td><td>0</td><td>388</td><td>8301</td><td>206d</td><td>core_dump_elf.o</td></tr></tbody></table><table><thead><tr><th>text</th><th>data</th><th>bss</th><th>dec</th></tr></thead><tbody><tr><td>15040</td><td>112</td><td>2120</td><td>17272</td></tr></tbody></table><h1 id="依赖">7 依赖</h1><p>panic</p><p>sha256</p><p>crc32</p><p>esp自己实现的几个task相关的系统函数</p><p>flash 加密</p><p>partition</p><p>编译链相关</p>]]></content>
      
      
      <categories>
          
          <category> ESP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几个开源文件系统分析</title>
      <link href="posts/e9f64d20.html"/>
      <url>posts/e9f64d20.html</url>
      
        <content type="html"><![CDATA[<h1 id="littleFS">1 littleFS</h1><h2 id="功能">1.1 功能</h2><ul><li><strong>Power-loss resilience 断电恢复能力</strong> - littlefs设计用于处理随机电源故障。所有文件操作都有强的“写时拷贝”保证，如果断电，文件系统将恢复到上一次已知的良好状态。</li><li><strong>Dynamic wear leveling 动态磨损均衡</strong> - littlefs设计时考虑了闪存，并提供动态块上的磨损均衡。此外，littlefs可以检测坏块并在它们周围工作。</li><li><strong>Bounded RAM/ROM 有界RAM/ROM</strong> - littlefs设计目的使用少量内存。RAM的使用是有严格限制的，这意味着RAM消耗不会随着文件系统的增长而改变。文件系统不包含无限递归，动态内存仅限于静态提供的可配置缓冲区。</li></ul><h1 id="SPIFFS">2 SPIFFS</h1><p>Spiffs是一个用于嵌入式目标上的SPI NOR flash设备的文件系统。</p><h2 id="介绍">2.1 介绍</h2><ul><li>小(嵌入式)目标，没有堆的少量RAM</li><li>只有大范围的数据(块)才能被删除</li><li>擦除将把所有块中的位重置为1</li><li>写操作把1变成0</li><li>0只能被擦除成1</li><li>静态磨损均衡</li></ul><h2 id="功能-1">2.2 功能</h2><p>能做：</p><ul><li><p>使用<strong>静态大小的ram缓冲区</strong>，与文件的数量无关</p></li><li><p><strong>类可移植操作系统接口</strong>: open, close, read, write, seek, stat,等</p></li><li><p>多个spiffs配置可以在相同的目标上运行—甚至可以在相同的SPI闪存设备上运行</p></li><li><p><strong>静态磨损均衡</strong></p></li><li><p><strong>内置文件系统一致性检查</strong></p></li></ul><p>不能做什么:</p><ul><li><p><strong>spiffs不支持目录</strong>。它产生一个平面结构。使用路径tmp/myfile.txt创建文件将创建一个名为tmp/myfile.txt的文件，而不是在tmp目录下创建一个名为myfile.txt的文件。</p></li><li><p><strong>非实时堆栈</strong>。一个写操作的持续时间可能比另一个长得多。</p></li><li><p><strong>可伸缩性较差</strong>。Spiffs适用于小型内存设备——SPI flash的正常大小。超过~128Mbyte就不推荐了。</p></li><li><p><strong>不能检测或处理坏块</strong>。</p></li><li><p>一个配置，一个二进制。没有通用的spiffs二进制可以处理所有类型的配置。</p></li></ul><h1 id="littleFS-SPIFFS-FATFS">3 littleFS-SPIFFS-FATFS</h1><h2 id="静态系统资源">3.1 静态系统资源</h2><h3 id="littleFS-SPIFFS">3.1.1 littleFS-SPIFFS</h3><p>对比静态系统资源，主要比较编译后的bin文件的text/data/bss段的大小。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text段：存放代码执行语句 </span><br><span class="line">data段：存放已初始化的全局变量和局部静态变量 </span><br><span class="line">bss段：未初始化的全局变量和局部静态变量</span><br></pre></td></tr></table></figure><p>设计了下面的Shell命令统计静态信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">&quot;*.o&quot;</span> -<span class="built_in">exec</span> size &#123;&#125; \; | awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">BEGIN&#123;</span></span><br><span class="line"><span class="string">datasum = 0;</span></span><br><span class="line"><span class="string">textsum = 0;</span></span><br><span class="line"><span class="string">bsssum = 0;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">/data/&#123;</span></span><br><span class="line"><span class="string">getline;</span></span><br><span class="line"><span class="string">textsum += $1;</span></span><br><span class="line"><span class="string">datasum += $2;</span></span><br><span class="line"><span class="string">bsssum += $3;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">END&#123;</span></span><br><span class="line"><span class="string">printf &quot;text %d\ndata %d\nbss %d\n&quot;, textsum, datasum, bsssum</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>统计结果如下：</p><table><thead><tr><th align="center">FS</th><th align="center">text</th><th align="center">data</th><th align="center">bss</th></tr></thead><tbody><tr><td align="center">littleFS</td><td align="center">24000</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">SPIFFS</td><td align="center">36940</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><blockquote><p>可以发现，SPIFFS的代码量比LittleFS多53%，也就意味着SPIFFS需要更多的内存存放代码。</p></blockquote><h3 id="littleFS-FATFS">3.1.2 littleFS-FATFS</h3><p><img "" class="lazyload placeholder" data-original="/posts/e9f64d20/fatfs_littlefs_romram.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="filesystem.md"></p><blockquote><p>littleFS最小的资源占用</p></blockquote><h2 id="空间利用率-littleFS-SPIFFS">3.2 空间利用率(littleFS-SPIFFS)</h2><p>文件系统需要额外空间存放一些元数据，因此用户可用的空间实际大小并不直接等于分区大小。在 4896KB 的分区上分别挂载SPIFFS和Littlefs两个文件系统，他们的可用空间是多少呢？</p><p>空的文件系统体现不出来，我们试着往不同文件系统中存放一些资源文件，再观察使用情况。</p><p>这些资源文件在ubuntu的ext4 (块大小为4K）中统计有2794KB的大小。以此为标准，我们看看SPIFFS和LittleFS的空间使用情况</p><table><thead><tr><th align="center">FS</th><th align="center">used(KB)</th><th align="center">total(KB)</th><th align="left">note</th></tr></thead><tbody><tr><td align="center">SPIFFS</td><td align="center">2722</td><td align="center">4607</td><td align="left"></td></tr><tr><td align="center">LittleFS</td><td align="center">3680</td><td align="center">4896</td><td align="left">block size = 32K</td></tr><tr><td align="center">LittleFS</td><td align="center">2800</td><td align="center">4896</td><td align="left">block size = 4K</td></tr></tbody></table><p>由于LittleFS的块大小决定了文件存储的最小单位，因此分别统计块大小为4K和32K的空间使用情况。当块越大，则越有可能会出现空间浪费的情况。例如32K的块大小，即使文件内容只有1KB，LittleFS也会为其分配32K的空间，造成了31K的空间浪费。</p><blockquote><p>从空间利用率来看，SPIFFS略优于LittleFS。</p></blockquote><h2 id="掉电安全与修复（littleFS-SPIFFS-FATFS）">3.3 掉电安全与修复（littleFS-SPIFFS-FATFS）</h2><p>文件系统的掉电安全指在任意一时刻掉电，文件系统依然能保证其一致性，文件系统允许丢失掉电时没写完整的数据，但不能奔溃。</p><p>通过读写掉电的方式验证掉电安全，即在读写压测时随机时间掉电，再次上电后需要保证文件系统正常运行且已写入的文件数据不丢失。</p><p>SPIFFS掉电后需要调用<code>SPIFFS_check()</code>进行修复，否则无法保证文件系统一致性。这就类似于ext4与e2fsck的关系。</p><p>在实测中，4896KB的空间，SPIFFS的修复需要510s，在项目中已经放弃对其的掉电压测。</p><p>与SPIFFS相反，LittleFS在设计时就保证了掉电安全的问题，因此不需要每次掉电后执行修复工作。</p><p>而2.1.3版本的LittleFS在10W次的掉电测试中，在数万次掉电后小概率出现文件系统奔溃导致不能正确挂载的情况，是LittleFS本身逻辑的问题。在2.2版本解决。</p><p>littlefs具有强大的copy-on-write保证，并且磁盘上的存储总是保持有效状态。</p><table><thead><tr><th align="center">littleFS</th><th align="center">SPIFFS</th><th align="center">FATFS</th></tr></thead><tbody><tr><td align="center">copy-on-write</td><td align="center">修复较慢</td><td align="center">无</td></tr></tbody></table><h2 id="读写性能">3.4 读写性能</h2><p>当空间使用率不同，测试的性能有可能不一样，在SPIFFS中尤其明显。</p><table><thead><tr><th align="center">IO操作</th><th align="center">空闲空间</th><th align="center">SPIFFS</th><th align="center">LittleFS(32K Block)</th><th align="center">LittleFS(4K Block)</th></tr></thead><tbody><tr><td align="center">读</td><td align="center">20%</td><td align="center">6095.24 KB/s</td><td align="center">8629.21 KB/s</td><td align="center">7529.41 KB/s</td></tr><tr><td align="center">读</td><td align="center">100%</td><td align="center">6564.10 KB/s</td><td align="center">8727.27 KB/s</td><td align="center">7314.29 KB/s</td></tr><tr><td align="center">写</td><td align="center">20%</td><td align="center">21.64 KB/s</td><td align="center">142.54 KB/s</td><td align="center">121.92 KB/s</td></tr><tr><td align="center">写</td><td align="center">100%</td><td align="center">128.49 KB/s</td><td align="center">155.37 KB/s</td><td align="center">127.87 KB/s</td></tr></tbody></table><blockquote><p>在读写性能表现上，SPIFFS最差，且剩余空间越少，SPIFFS写性能越差。LittleFS的性能相对比较高和稳定，块大小会直接影响到写性能。</p></blockquote><h2 id="动态内存">3.5 动态内存</h2><p>动态内存指通过<code>malloc</code>申请分配的堆内存大小。不管是SPIFFS还是LittleFS都是为小系统设计的，其内存使用情况都经过精心设计，内存占用非常小。</p><p>LittleFS会为每个打开的文件单独申请一个<code>cache_size</code>的内存，在测试时，cache_size 为256B。为了对比的公平性，我们假设SPIFFS和LittleFS打开相同数量的文件情况下统计内存。</p><table><thead><tr><th align="center">LittleFS</th><th align="center">SPIFFS</th></tr></thead><tbody><tr><td align="center">3856 B</td><td align="center">3790 B</td></tr></tbody></table><p>两者使用动态内存的情况相近，在最大打开数量的情况下，SPIFFS使用动态内存略少。</p><p>由于SPIFFS的内存使用并不会随着打开文件增加而增加，也就意味着，在打开少量文件的情况下，LittleFS会比SPIFFS更少的动态内存使用量。</p><h2 id="CPU占用">3.6 CPU占用</h2><p>在读写压测时，统计进程使用的CPU资源百分比</p><table><thead><tr><th align="center">LittleFS (32K)</th><th align="center">LittleFS (4K)</th><th align="center">SPIFFS</th></tr></thead><tbody><tr><td align="center">22~27</td><td align="center">27~50</td><td align="center">44~80</td></tr></tbody></table><p>可以发现，在相同情况下，LittleFS的CPU占用率会比SPIFFS少。</p><h2 id="磨损均衡（littleFS-SPIFFS-FATFS）">3.7 磨损均衡（littleFS-SPIFFS-FATFS）</h2><p><img "" class="lazyload placeholder" data-original="/posts/e9f64d20/dynamic_wear_leveling.gif" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="filesystem.md"></p><table><thead><tr><th align="center">LittleFS</th><th align="center">SPIFFS</th><th align="center">FATFS</th></tr></thead><tbody><tr><td align="center">动态</td><td align="center">静态</td><td align="center">无</td></tr></tbody></table><h1 id="littleFS-SPIFFS-FATFS在ESP上对比">4 littleFS-SPIFFS-FATFS在ESP上对比</h1><h2 id="格式化一个512K的分区">4.1 格式化一个512K的分区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FAT:         963,766 us</span><br><span class="line">SPIFFS:   10,824,054 us</span><br><span class="line">LittleFS:  2,067,845 us</span><br></pre></td></tr></table></figure><h2 id="写入588K的文件">4.2 写入588K的文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FAT:         13,601,171 us</span><br><span class="line">SPIFFS*:    118,883,197 us</span><br><span class="line">LittleFS**:   6,582,045 us</span><br><span class="line">LittleFS***:  5,734,811 us</span><br><span class="line">*Only wrote 374,784 bytes instead of the benchmark 440,000, so this value is extrapolated</span><br><span class="line">**CONFIG_LITTLEFS_CACHE_SIZE&#x3D;128</span><br><span class="line">***CONFIG_LITTLEFS_CACHE_SIZE&#x3D;512 (default value)</span><br></pre></td></tr></table></figure><blockquote><p>当SPIFFS写满的时候，速度会急剧下降，如下是SPIFFS不同剩余内存写入时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">88000 bytes written in 1325371 us</span><br><span class="line">88000 bytes written in 1327848 us</span><br><span class="line">88000 bytes written in 5292095 us</span><br><span class="line">88000 bytes written in 19191680 us</span><br><span class="line">22784 bytes written in 74082963 us</span><br></pre></td></tr></table></figure></blockquote><h2 id="读取588K的文件">4.3 读取588K的文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FAT:          3,111,817 us</span><br><span class="line">SPIFFS*:      3,392,886 us</span><br><span class="line">LittleFS**:   3,425,796 us</span><br><span class="line">LittleFS***:  3,210,140 us</span><br><span class="line">*Only read 374,784 bytes instead of the benchmark 440,000, so this value is extrapolated</span><br><span class="line">**CONFIG_LITTLEFS_CACHE_SIZE&#x3D;128</span><br><span class="line">***CONFIG_LITTLEFS_CACHE_SIZE&#x3D;512 (default value)</span><br></pre></td></tr></table></figure><h2 id="删除588K的文件">4.4 删除588K的文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FAT:         934,769 us</span><br><span class="line">SPIFFS*:      822,730 us</span><br><span class="line">LittleFS**:   31,502 us</span><br><span class="line">LittleFS***:  20,063 us</span><br><span class="line">*The 5th file was smaller, did not extrapolate value.</span><br><span class="line">**CONFIG_LITTLEFS_CACHE_SIZE&#x3D;128</span><br><span class="line">***CONFIG_LITTLEFS_CACHE_SIZE&#x3D;512 (default value)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ESP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置终端走代理</title>
      <link href="posts/f44b287.html"/>
      <url>posts/f44b287.html</url>
      
        <content type="html"><![CDATA[<h1 id="配置终端使用代理">1 配置终端使用代理</h1><h2 id="临时（只在该终端生效）">1.1 临时（只在该终端生效）</h2><ul><li>第一种方法：走http<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:1087</span><br><span class="line">export https_proxy=http://127.0.0.1:1087</span><br></pre></td></tr></table></figure></li><li>第二种方法：走socks<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=socks://127.0.0.1:1080</span><br><span class="line">export https_proxy=socks://127.0.0.1:1080</span><br></pre></td></tr></table></figure></li><li>windows终端则将export改为set</li></ul><h2 id="永久（不建议）">1.2 永久（不建议）</h2><p>省略。。。</p><h1 id="设置apt使用代理">2 设置apt使用代理</h1><h2 id="方法一：临时">2.1 方法一：临时</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -o Acquire::http::proxy=&quot;http://127.0.0.1:1080/&quot; update</span><br></pre></td></tr></table></figure><h2 id="方法二：临时，配置终端走代理，使得apt命令走代理">2.2 方法二：临时，配置终端走代理，使得apt命令走代理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:1080</span><br></pre></td></tr></table></figure><ul><li>详细的配置可以看另一篇终端配置</li></ul><h2 id="方法三：永久（不推荐）">2.3 方法三：永久（不推荐）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/apt.conf # 或者修改/etc/envrionment</span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加如下命令</span></span><br><span class="line">Acquire::http::proxy &quot;http://127.0.0.1:1080/&quot;;</span><br><span class="line">Acquire::ftp::proxy &quot;ftp://127.0.0.1:1080/&quot;;</span><br><span class="line">Acquire::https::proxy &quot;https://127.0.0.1:1080/&quot;;</span><br></pre></td></tr></table></figure><h1 id="设置git使用代理">3 设置git使用代理</h1><h2 id="方法一：使用socks5协议">3.1 方法一：使用socks5协议</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><h2 id="方法二：使用http协议">3.2 方法二：使用http协议</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br></pre></td></tr></table></figure><h2 id="查看所有配置">3.3 查看所有配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><h2 id="reset-代理设置">3.4 reset 代理设置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux设备树</title>
      <link href="posts/e1ba271a.html"/>
      <url>posts/e1ba271a.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux根文件系统搭建</title>
      <link href="posts/f9852f95.html"/>
      <url>posts/f9852f95.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介">1 简介</h1><h2 id="bin-目录">1.1 /bin 目录</h2><p>存放着系统需要的可执行文件，例如<code>ls</code>，<code>mv</code>等命令，该目录下所有用户都可以使用</p><h2 id="dev-目录">1.2 /dev 目录</h2><p>device 的缩写，该目录下存放的文件都是和设备有关的，都是设备文件</p><h2 id="etc-目录">1.3 /etc 目录</h2><p>存放配置文件</p><h2 id="lib-目录">1.4 /lib 目录</h2><p>存放着Linux所必须的库文件，是共享库</p><h2 id="mnt-目录">1.5 /mnt 目录</h2><p>临时挂载目录，一般是空目录    </p><h2 id="proc-目录">1.6 /proc 目录</h2><p>proc文件系统的挂载点，是个虚拟文件系统，里面的文件都是临时存在的，一般用来存储系统运行信息文件</p><h2 id="usr-目录">1.7 /usr 目录</h2><p>不是user的缩写，而是 unix software resource的缩写，也就是Unix操作系统软件资源目录</p><h2 id="var-目录">1.8 /var 目录</h2><p>存放一些可以改变的数据</p><h2 id="sbin-目录">1.9 /sbin 目录</h2><p>存放一些可执行文件，<strong>只有管理员可以使用</strong>，主要用户系统管理</p><h2 id="sys-目录">1.10 /sys 目录</h2><p>sysfs文件系统的挂载点，类似于proc文件系统的特殊文件系统，sysfs也是基于ram的文件系统，向用户提供详细的内核数据结构信息</p><h2 id="opt">1.11 /opt</h2><p>可选的文件、软件存放区</p><h1 id="BusyBox构建根文件系统">2 BusyBox构建根文件系统</h1><h2 id="简介-1">2.1 简介</h2><p><a href="https://busybox.net/">Https://busybox.net/</a></p><h2 id="修改源码">2.2 修改源码</h2><p>在NFS服务器中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir rootfs</span><br><span class="line">cd rootfs</span><br><span class="line">tar -vxjf busybox-1.29.0.tar.bz2</span><br></pre></td></tr></table></figure><p>修改busybox的顶层Makefile，添加ARCH和CROSS_COMPILE的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CROSS_COMPILE ?&#x3D; &#x2F;usr&#x2F;local&#x2F;arm&#x2F;gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf&#x2F;bin&#x2F;arm-linux-gnueabihf-</span><br><span class="line">ARCH ?&#x3D; arm</span><br></pre></td></tr></table></figure><p>修改 busybox-1.29.0/libbb/printable_string.c，找到函数 printable_string</p><p>修改libbb/unicode.c</p><h2 id="配置busybox">2.3 配置busybox</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make defconfig</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><ul><li>Location-&gt;settings-&gt;build static binary(no shared libs)</li><li>Location-&gt;settings-&gt;vi-style line editing commands</li><li>Location-&gt;linux module utilities-&gt;simplified modutils</li><li>Location-&gt;linux system utilities-&gt;mdev(16kb)</li><li>Location-&gt;support-&gt;Check $LC_ALL, $LC_CTYPE and $LANG environment variables</li></ul><h2 id="编译">2.4 编译</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install CONFIG_PREFIX=/home/wzy/linux/nfs/rootfs # 输出路径</span><br></pre></td></tr></table></figure><h2 id="根文件系统中添加lib库">2.5 根文件系统中添加lib库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir lib</span><br><span class="line">cd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linuxgnueabihf/libc/lib</span><br><span class="line">cp *so* *.a /home/wzy/linux/nfs/rootfs/lib/ -d</span><br><span class="line">cd /home/wzy/linux/nfs/rootfs/lib/</span><br><span class="line">rm ld-linux-armhf.so.3</span><br><span class="line">cd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linuxgnueabihf/libc/lib</span><br><span class="line">cp ld-linux-armhf.so.3 /home/wzy/linux/nfs/rootfs/lib/</span><br><span class="line">cd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/lib</span><br><span class="line">cp *so* *.a /home/wzy/linux/nfs/rootfs/lib/ -d</span><br></pre></td></tr></table></figure><h2 id="根文件系统中urs-lib目录中添加库文件">2.6 根文件系统中urs/lib目录中添加库文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/lib</span><br><span class="line">cp *so* *.a /home/wzy/linux/nfs/rootfs/usr/lib/ -d</span><br></pre></td></tr></table></figure><h2 id="创建其他文件夹">2.7 创建其他文件夹</h2><p>在根文件系统中创建其他文件夹，如 dev、proc、mnt、sys、tmp 和 root 等</p><h2 id="根文件系统测试">2.8 根文件系统测试</h2><p>由于使用NFS挂载根文件系统，所以需要设置<strong>uboot</strong>中的<strong>bootargs</strong>环境变量中的<strong>root</strong>值</p><p>进入开发板的uboot命令行模式，输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.250:/home/wzy/linux/nfs/rootfs,proto=tcp rw ip=192.168.1.251:192.168.1.250:192.168.1.1:255.255.255.0::eth0:off&#x27; # 设置 bootargs</span><br><span class="line">saveenv # 保存环境变量</span><br></pre></td></tr></table></figure><p>然后使用<strong>boot</strong>命令启动Linux内核</p><blockquote><p>root=/dev/nfs nfsroot=192.168.1.250:/home/wzy/linux/nfs/rootfs,proto=tcp rw ip=192.168.1.251:192.168.1.250:192.168.1.1:255.255.255.0::eth0:off</p><p>其中：</p><p>192.168.1.250：服务器IP地址</p><p>/home/wzy/linux/nfs/rootfs：根文件系统的存放路径</p><p>proto=tcp rw：表示使用tcp协议，挂载的根文件系统为可读可写</p><p>ip=192.168.1.251:192.168.1.250:192.168.1.1:255.255.255.0::eth0:off：开发板IP，服务器IP，网关，子网掩码，客户机名字（空着），设备名（网卡名），自动配置不使用（off）</p></blockquote><h2 id="创建-etc-init-d-rcS文件">2.9 创建/etc/init.d/rcS文件</h2><p>在rcS中输入如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/lib:/usr/lib</span><br><span class="line">runlevel=S</span><br><span class="line"><span class="built_in">umask</span> 022</span><br><span class="line"><span class="built_in">export</span> PATH LD_LIBRARY_PATH runlevel</span><br><span class="line"></span><br><span class="line">mount -a</span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动</span></span><br><span class="line"><span class="built_in">cd</span> /usr/bin</span><br><span class="line">./lcd_always_on</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line">vsftpd &amp;</span><br><span class="line">/sbin/sshd &amp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;/var/lib/alsa/asound.state&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ALSA: Restoring mixer setting......&quot;</span></span><br><span class="line">/sbin/alsactl -f /var/lib/alsa/asound.state restore &amp;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>最后修改可执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 rcS</span><br></pre></td></tr></table></figure><h2 id="创建-etc-fstab文件">2.10 创建/etc/fstab文件</h2><p>创建/etc/fstab文件，并添加如下源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&lt;file system&gt;&lt;mount point&gt; &lt;type&gt;&lt;options&gt;&lt;dump&gt;&lt;pass&gt;</span></span><br><span class="line">proc/procprocdefaults00</span><br><span class="line">tmpfs/tmptmpfsdefaults00</span><br><span class="line">sysfs/syssysfsdefaults00</span><br><span class="line">tmpfs/devtmpfsdefaults00</span><br></pre></td></tr></table></figure><ul><li>File system：要挂载的特殊设备，也可以是块设备，譬如/dev/sda</li><li>mount point：挂载点</li><li>type：文件系统类型，例如ext2、ext3、proc、romfs、tmpfs等</li><li>options：挂载选项</li><li>dump：是否允许备份</li><li>Pass：是否进行磁盘检查</li></ul><h2 id="创建-etc-inittab文件">2.11 创建/etc/inittab文件</h2><p>inittab的详细内容可以参考busybox下的examples/inittab</p><p>init程序会读取/etc/inittab这个文件，改文件由若干台指令组成，以“:”分割的四个段组成，格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span><br></pre></td></tr></table></figure><ul><li>id：指令的标识符，不能重复</li><li>runlevels：对于busybox无意义，为空</li><li>action：动作，如下表所示</li><li>Process：具体的动作，比如程序、脚本或者命令等</li></ul><table><thead><tr><th>动作action</th><th>描述</th></tr></thead><tbody><tr><td>sysinit</td><td>在系统初始化的时候 process 才会执行一次</td></tr><tr><td>respawn</td><td>当 process 终止以后马上启动一个新的</td></tr><tr><td>askfirst</td><td>和 respawn 类似，在运行 process 之前在控制台上显示“Please press Enter to activate this console.”。只要用户按下“Enter”键以后才会执行 process</td></tr><tr><td>wait</td><td>告诉 init，要等待相应的进程执行完以后才能继续执行。</td></tr><tr><td>once</td><td>仅执行一次，而且不会等待 process 执行完成</td></tr><tr><td>restart</td><td>当 init 重启的时候才会执行 process</td></tr><tr><td>ctrlaltdel</td><td>当按下 ctrl+alt+del 组合键才会执行 process</td></tr><tr><td>shutdown</td><td>关机的时候执行 process</td></tr></tbody></table><p>参考 busybox 的 examples/inittab 文件，创建一个/etc/inittab，输入如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">etc/inittab</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统运行以后运行这个rcS脚本</span></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将console作为控制台终端</span></span><br><span class="line">console::askfirst:-/bin/sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启的话运行/sbin/init</span></span><br><span class="line">::restart:/sbin/init</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按下ctrl+alt+del组合键的话就运行/sbin/reboot，所以该组合键可以重启系统</span></span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关机的时候执行/bin/umount，卸载各个文件系统</span></span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关机的时候执行/sbin/swapoff，关闭交换分区</span></span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br></pre></td></tr></table></figure><h2 id="外网测试">2.12 外网测试</h2><p>在 rootfs 中新建文件/etc/resolv.conf，然后在里面输入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>设置域名服务器，保存后重启开发板，ping百度可以成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><h2 id="测试软件">2.13 测试软件</h2><p>在根文件系统中创建hello.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world!\r\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc hello.c -o hello</span><br></pre></td></tr></table></figure><p>查看可执行文件并在开发板运行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file hello</span><br><span class="line">.&#x2F;hello</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux uboot移植</title>
      <link href="posts/e3a5220d.html"/>
      <url>posts/e3a5220d.html</url>
      
        <content type="html"><![CDATA[<p>编译NXP官方uboot，烧入开发板</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">U-Boot 2016.03 (Aug 08 2021 - 05:35:02 -0700)</span><br><span class="line"></span><br><span class="line">CPU:   Freescale i.MX6ULL rev1.1 69 MHz (running at 396 MHz)</span><br><span class="line">CPU:   Industrial temperature grade (-40C to 105C) at 37C</span><br><span class="line">Reset cause: POR</span><br><span class="line">Board: MX6ULL 14x14 EVK</span><br><span class="line">I2C:   ready</span><br><span class="line">DRAM:  512 MiB</span><br><span class="line">MMC:   FSL_SDHC: 0, FSL_SDHC: 1</span><br><span class="line">unsupported panel TFT7016</span><br><span class="line">In:    serial</span><br><span class="line">Out:   serial</span><br><span class="line">Err:   serial</span><br><span class="line">switch to partitions #0, OK</span><br><span class="line">mmc0 is current device</span><br><span class="line">Net:   Board Net Initialization Failed</span><br><span class="line">No ethernet found.</span><br><span class="line">Normal Boot</span><br><span class="line">Hit any key to stop autoboot:  0 </span><br><span class="line">=&gt; </span><br></pre></td></tr></table></figure><p>检查SD卡和EMMC驱动检查</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=&gt; mmc list</span><br><span class="line">FSL_SDHC: 0 (SD)</span><br><span class="line">FSL_SDHC: 1</span><br><span class="line">=&gt; </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">=&gt; mmc dev 0</span><br><span class="line">switch to partitions #0, OK</span><br><span class="line">mmc0 is current device</span><br><span class="line"></span><br><span class="line">=&gt; mmc info</span><br><span class="line">Device: FSL_SDHC</span><br><span class="line">Manufacturer ID: 3</span><br><span class="line">OEM: 5344</span><br><span class="line">Name: SC16G </span><br><span class="line">Tran Speed: 50000000</span><br><span class="line">Rd Block Len: 512</span><br><span class="line">SD version 3.0</span><br><span class="line">High Capacity: Yes</span><br><span class="line">Capacity: 14.8 GiB</span><br><span class="line">Bus Width: 4-bit</span><br><span class="line">Erase Group Size: 512 Bytes</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">=&gt; mmc dev 1</span><br><span class="line">switch to partitions #0, OK</span><br><span class="line">mmc1(part 0) is current device</span><br><span class="line">=&gt; </span><br><span class="line"></span><br><span class="line">=&gt; mmc info</span><br><span class="line">Device: FSL_SDHC</span><br><span class="line">Manufacturer ID: 15</span><br><span class="line">OEM: 100</span><br><span class="line">Name: 8GTF4 </span><br><span class="line">Tran Speed: 52000000</span><br><span class="line">Rd Block Len: 512</span><br><span class="line">MMC version 4.0</span><br><span class="line">High Capacity: Yes</span><br><span class="line">Capacity: 7.3 GiB</span><br><span class="line">Bus Width: 8-bit</span><br><span class="line">Erase Group Size: 512 KiB</span><br><span class="line">=&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改了LCD和网卡驱动后的UBOOT启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">U-Boot 2016.03 (Aug 09 2021 - 00:16:32 +0800)</span><br><span class="line"></span><br><span class="line">CPU:   Freescale i.MX6ULL rev1.1 69 MHz (running at 396 MHz)</span><br><span class="line">CPU:   Industrial temperature grade (-40C to 105C) at 35C</span><br><span class="line">Reset cause: POR</span><br><span class="line">Board: MX6ULL 14x14 EVK</span><br><span class="line">I2C:   ready</span><br><span class="line">DRAM:  512 MiB</span><br><span class="line">MMC:   FSL_SDHC: 0, FSL_SDHC: 1</span><br><span class="line">Display: TFT7016 (1024x600)</span><br><span class="line">Video: 1024x600x24</span><br><span class="line">In:    serial</span><br><span class="line">Out:   serial</span><br><span class="line">Err:   serial</span><br><span class="line">switch to partitions #0, OK</span><br><span class="line">mmc0 is current device</span><br><span class="line">Net:   FEC1</span><br><span class="line">Normal Boot</span><br><span class="line">Hit any key to stop autoboot:  0 </span><br><span class="line">=&gt; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uboot移植</title>
      <link href="posts/54ee180f.html"/>
      <url>posts/54ee180f.html</url>
      
        <content type="html"><![CDATA[<h1 id="nxp-uboot编译测试">1 nxp uboot编译测试</h1><h2 id="官方uboot编译">1.1 官方uboot编译</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_evk_emmc_defconfig</span><br><span class="line">make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16</span><br></pre></td></tr></table></figure><p><img "" class="lazyload placeholder" data-original="/posts/54ee180f/image-20210710235722229.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210710235722229"></p><h2 id="uboot烧写">1.2 uboot烧写</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给予 imxdownload 可执行权限</span></span><br><span class="line">chmod 777 imxdownload </span><br><span class="line"><span class="meta">#</span><span class="bash"> 烧写到 SD 卡中，不能烧写到/dev/sda 或 sda1 里面</span></span><br><span class="line">./imxdownload u-boot.bin /dev/sdd </span><br></pre></td></tr></table></figure><img "" class="lazyload placeholder" data-original="/posts/54ee180f/image-20210711000055197.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210711000055197" style="zoom:50%;"><p>可以看出uboot可以正常启动</p><h2 id="SD卡和EMMC驱动检查">1.3 SD卡和EMMC驱动检查</h2><p>使用<code>mmc list</code>列出当前的MMC设备</p><img "" class="lazyload placeholder" data-original="/posts/54ee180f/image-20210711000437314.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210711000437314" style="zoom:50%;"><p>检查MMC设备0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mmc dev 0</span><br><span class="line">mmc info</span><br></pre></td></tr></table></figure><p>结果如下图所示，mmc设备0是SD卡，SD卡的容量是14.8G，说明SD卡驱动正常</p><img "" class="lazyload placeholder" data-original="/posts/54ee180f/image-20210711000607379.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210711000607379" style="zoom:50%;"><p>检查MMC设备1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mmc dev 1</span><br><span class="line">mmc info</span><br></pre></td></tr></table></figure><p>mmc 设备 1 为 EMMC，容量为 3.6GB，说明 EMMC 驱动也成功</p><img "" class="lazyload placeholder" data-original="/posts/54ee180f/image-20210711000833189.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210711000833189" style="zoom:50%;"><h2 id="LCD驱动检查">1.4 LCD驱动检查</h2><p>屏幕默认是4.3 寸 480x272 分辨率，其他的会有错误</p><h2 id="网络驱动">1.5 网络驱动</h2><p>uboot启动时有网络驱动错误提示</p><img "" class="lazyload placeholder" data-original="/posts/54ee180f/image-20210711001014500.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210711001014500" style="zoom:50%;"><p>由于开发板的网络芯片复位引脚和 NXP 官方开发板</p><h2 id="总结">1.6 总结</h2><p>①、uboot 启动正常，DRAM 识别正确，SD 卡和 EMMC 驱动正常</p><p>②、uboot 里面的 LCD 驱动默认是给 4.3 寸 480x272 分辨率的，如果使用的其他分辨率的屏幕需要修改驱动。</p><p>③、网络不能工作，识别不出来网络信息，需要修改驱动。</p><h1 id="uboot移植">2 uboot移植</h1><h2 id="添加开发板默认配置文件">2.1 添加开发板默认配置文件</h2><p>添加config路径下的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd configs</span><br><span class="line">cp mx6ull_14x14_evk_emmc_defconfig mx6ull_alientek_emmc_defconfig</span><br></pre></td></tr></table></figure><p>然后将文件 mx6ull_alientek_emmc_defconfig 中的内容改成下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SYS_EXTRA_OPTIONS&#x3D;&quot;IMX_CONFIG&#x3D;board&#x2F;freescale&#x2F;mx6ull_alientek_emmc&#x2F;imximage.cfg,MX6ULL_EVK_EMMC_REWORK&quot;</span><br><span class="line">CONFIG_ARM&#x3D;y </span><br><span class="line">CONFIG_ARCH_MX6&#x3D;y </span><br><span class="line">CONFIG_TARGET_MX6ULL_ALIENTEK_EMMC&#x3D;y </span><br><span class="line">CONFIG_CMD_GPIO&#x3D;y</span><br></pre></td></tr></table></figure><h2 id="添加开发板对应的头文件">2.2 添加开发板对应的头文件</h2><p>添加include/configs/路径下对应的头文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp include/configs/mx6ullevk.h mx6ull_alientek_emmc.h</span><br></pre></td></tr></table></figure><p>修改文件内容为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2016 Freescale Semiconductor, Inc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Configuration settings for the Freescale i.MX6UL 14x14 EVK board.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SPDX-License-Identifier:GPL-2.0+</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MX6ULL_ALEITENK_EMMC_CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MX6ULL_ALEITENK_EMMC_CONFIG_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/imx-regs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sizes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mx6_common.h&quot;</span><span class="comment">/* 也有一些配置 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/imx-common/gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* uncomment for PLUGIN mode support */</span></span><br><span class="line"><span class="comment">/* #define CONFIG_USE_PLUGIN */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* uncomment for SECURE mode support */</span></span><br><span class="line"><span class="comment">/* #define CONFIG_SECURE_BOOT */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURE_BOOT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_CSF_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CSF_SIZE 0x4000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> is_mx6ull_9x9_evk()CONFIG_IS_ENABLED(TARGET_MX6ULL_9X9_EVK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置SDRAM大小 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TARGET_MX6ULL_9X9_EVK</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYS_SDRAM_SIZESZ_256M</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_BOOTARGS_CMA_SIZE   <span class="meta-string">&quot;cma=96M &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYS_SDRAM_SIZESZ_512M</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_BOOTARGS_CMA_SIZE   <span class="meta-string">&quot;&quot;</span></span></span><br><span class="line"><span class="comment">/* DCDC used on 14x14 EVK, no PMIC */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CONFIG_LDO_BYPASS_CHECK</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SPL options */</span></span><br><span class="line"><span class="comment">/* We default not support SPL</span></span><br><span class="line"><span class="comment"> * #define CONFIG_SPL_LIBCOMMON_SUPPORT</span></span><br><span class="line"><span class="comment"> * #define CONFIG_SPL_MMC_SUPPORT</span></span><br><span class="line"><span class="comment"> * #include &quot;imx6_spl.h&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_DISPLAY_CPUINFO<span class="comment">/* UBOOT启动的时候可以显示CPU信息 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_DISPLAY_BOARDINFO<span class="comment">/* uboot启动的时候输出板子的信息 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* malloc内存池大小，这里设置为16MB */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_MALLOC_LEN(16 * SZ_1M)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_BOARD_EARLY_INIT_F<span class="comment">/* 定义后board_init_f函数会调用board_early_init_f函数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_BOARD_LATE_INIT<span class="comment">/* 定义后board_init_r函数会调用board_late_init函数*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MXC_UART<span class="comment">/* 使能串口功能 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MXC_UART_BASEUART1_BASE<span class="comment">/* 串口基地址，这里使用串口1，基地址为UART1_BASE */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FSL_USDHC<span class="comment">/* EMMC接在USDHC2上 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_FSL_ESDHC_ADDRUSDHC2_BASE_ADDR<span class="comment">// EMMC所使用接口的基地址，也就是USDHC2基地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NAND接在USDHC2上</span></span><br><span class="line"><span class="comment">// 由于NAND和USDHC2的引脚冲突，所以如果使用NAND的话只能使用一个USDHC设备（SD卡）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYS_USE_NAND<span class="comment">// 如果使用NAND，则只有一个USDHC</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_FSL_USDHC_NUM1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_FSL_USDHC_NUM2<span class="comment">// 否则的话，有两个USDHC</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C配置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CMD_I2C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMD_I2C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_I2C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_I2C_MXC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_I2C_MXC_I2C1<span class="comment">/* enable I2C bus 1 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_I2C_MXC_I2C2<span class="comment">/* enable I2C bus 2 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_I2C_SPEED100000<span class="comment">// I2C速度，32</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PMIC only for 9X9 EVK */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_POWER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_POWER_I2C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_POWER_PFUZE3000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_POWER_PFUZE3000_I2C_ADDR  0x08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_MMC_IMG_LOAD_PART1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NAND分区设置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYS_BOOT_NAND</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MFG_NAND_PARTITION <span class="meta-string">&quot;mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs) &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MFG_NAND_PARTITION <span class="meta-string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义MFGTOOLS烧写系统时用到的环境变量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MFG_ENV_SETTINGS \</span></span><br><span class="line"><span class="string">&quot;mfgtool_args=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; &quot;</span> \</span><br><span class="line">    CONFIG_BOOTARGS_CMA_SIZE \</span><br><span class="line"><span class="string">&quot;rdinit=/linuxrc &quot;</span> \</span><br><span class="line"><span class="string">&quot;g_mass_storage.stall=0 g_mass_storage.removable=1 &quot;</span> \</span><br><span class="line"><span class="string">&quot;g_mass_storage.file=/fat g_mass_storage.ro=1 &quot;</span> \</span><br><span class="line"><span class="string">&quot;g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF &quot;</span>\</span><br><span class="line"><span class="string">&quot;g_mass_storage.iSerialNumber=\&quot;\&quot; &quot;</span>\</span><br><span class="line">CONFIG_MFG_NAND_PARTITION \</span><br><span class="line"><span class="string">&quot;clk_ignore_unused &quot;</span>\</span><br><span class="line"><span class="string">&quot;\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;initrd_addr=0x83800000\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;initrd_high=0xffffffff\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;bootcmd_mfg=run mfgtool_args;bootz $&#123;loadaddr&#125; $&#123;initrd_addr&#125; $&#123;fdt_addr&#125;;\0&quot;</span> \</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_SYS_BOOT_NAND)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_EXTRA_ENV_SETTINGS \</span></span><br><span class="line">CONFIG_MFG_ENV_SETTINGS \</span><br><span class="line"><span class="string">&quot;panel=TFT7016\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;fdt_addr=0x83000000\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;fdt_high=0xffffffff\0&quot;</span>  \</span><br><span class="line"><span class="string">&quot;console=ttymxc0\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;bootargs=console=ttymxc0,115200 ubi.mtd=4 &quot;</span>  \</span><br><span class="line"><span class="string">&quot;root=ubi0:rootfs rootfstype=ubifs &quot;</span>     \</span><br><span class="line">CONFIG_BOOTARGS_CMA_SIZE \</span><br><span class="line"><span class="string">&quot;mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),1m(misc),-(rootfs)\0&quot;</span>\</span><br><span class="line"><span class="string">&quot;bootcmd=nand read $&#123;loadaddr&#125; 0x4000000 0x800000;&quot;</span>\</span><br><span class="line"><span class="string">&quot;nand read $&#123;fdt_addr&#125; 0x5000000 0x100000;&quot;</span>\</span><br><span class="line"><span class="string">&quot;bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;\0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_EXTRA_ENV_SETTINGS \</span></span><br><span class="line">CONFIG_MFG_ENV_SETTINGS \</span><br><span class="line"><span class="string">&quot;script=boot.scr\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;image=zImage\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;console=ttymxc0\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;fdt_high=0xffffffff\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;initrd_high=0xffffffff\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;fdt_file=undefined\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;fdt_addr=0x83000000\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;boot_fdt=try\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;ip_dyn=yes\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;panel=TFT7016\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;mmcdev=&quot;</span>__stringify(CONFIG_SYS_MMC_ENV_DEV)<span class="string">&quot;\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;mmcpart=&quot;</span> __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) <span class="string">&quot;\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;mmcroot=&quot;</span> CONFIG_MMCROOT <span class="string">&quot; rootwait rw\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;mmcautodetect=yes\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;mmcargs=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; &quot;</span> \</span><br><span class="line">CONFIG_BOOTARGS_CMA_SIZE \</span><br><span class="line"><span class="string">&quot;root=$&#123;mmcroot&#125;\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;loadbootscript=&quot;</span> \</span><br><span class="line"><span class="string">&quot;fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;script&#125;;\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;bootscript=echo Running bootscript from mmc ...; &quot;</span> \</span><br><span class="line"><span class="string">&quot;source\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;loadimage=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;image&#125;\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;loadfdt=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;fdt_addr&#125; $&#123;fdt_file&#125;\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;mmcboot=echo Booting from mmc ...; &quot;</span> \</span><br><span class="line"><span class="string">&quot;run mmcargs; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $&#123;boot_fdt&#125; = yes || test $&#123;boot_fdt&#125; = try; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;if run loadfdt; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;; &quot;</span> \</span><br><span class="line"><span class="string">&quot;else &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $&#123;boot_fdt&#125; = try; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;bootz; &quot;</span> \</span><br><span class="line"><span class="string">&quot;else &quot;</span> \</span><br><span class="line"><span class="string">&quot;echo WARN: Cannot load the DT; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;else &quot;</span> \</span><br><span class="line"><span class="string">&quot;bootz; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi;\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;netargs=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; &quot;</span> \</span><br><span class="line">CONFIG_BOOTARGS_CMA_SIZE \</span><br><span class="line"><span class="string">&quot;root=/dev/nfs &quot;</span> \</span><br><span class="line"><span class="string">&quot;ip=dhcp nfsroot=$&#123;serverip&#125;:$&#123;nfsroot&#125;,v3,tcp\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;netboot=echo Booting from net ...; &quot;</span> \</span><br><span class="line"><span class="string">&quot;run netargs; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $&#123;ip_dyn&#125; = yes; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv get_cmd dhcp; &quot;</span> \</span><br><span class="line"><span class="string">&quot;else &quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv get_cmd tftp; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;$&#123;get_cmd&#125; $&#123;image&#125;; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $&#123;boot_fdt&#125; = yes || test $&#123;boot_fdt&#125; = try; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;if $&#123;get_cmd&#125; $&#123;fdt_addr&#125; $&#123;fdt_file&#125;; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;; &quot;</span> \</span><br><span class="line"><span class="string">&quot;else &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $&#123;boot_fdt&#125; = try; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;bootz; &quot;</span> \</span><br><span class="line"><span class="string">&quot;else &quot;</span> \</span><br><span class="line"><span class="string">&quot;echo WARN: Cannot load the DT; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;else &quot;</span> \</span><br><span class="line"><span class="string">&quot;bootz; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi;\0&quot;</span> \</span><br><span class="line"><span class="string">&quot;findfdt=&quot;</span>\</span><br><span class="line"><span class="string">&quot;if test $fdt_file = undefined; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv fdt_file imx6ull-alientek-emmc.dtb; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi;\0&quot;</span> \</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置环境变量 bootcmd 的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_BOOTCOMMAND \</span></span><br><span class="line">   <span class="string">&quot;run findfdt;&quot;</span> \</span><br><span class="line">   <span class="string">&quot;mmc dev $&#123;mmcdev&#125;;&quot;</span> \</span><br><span class="line">   <span class="string">&quot;mmc dev $&#123;mmcdev&#125;; if mmc rescan; then &quot;</span> \</span><br><span class="line">   <span class="string">&quot;if run loadbootscript; then &quot;</span> \</span><br><span class="line">   <span class="string">&quot;run bootscript; &quot;</span> \</span><br><span class="line">   <span class="string">&quot;else &quot;</span> \</span><br><span class="line">   <span class="string">&quot;if run loadimage; then &quot;</span> \</span><br><span class="line">   <span class="string">&quot;run mmcboot; &quot;</span> \</span><br><span class="line">   <span class="string">&quot;else run netboot; &quot;</span> \</span><br><span class="line">   <span class="string">&quot;fi; &quot;</span> \</span><br><span class="line">   <span class="string">&quot;fi; &quot;</span> \</span><br><span class="line">   <span class="string">&quot;else run netboot; fi&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Miscellaneous configurable options */</span></span><br><span class="line"><span class="comment">// 设置命令memtest相关的宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CMD_MEMTEST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_MEMTEST_START0x80000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_MEMTEST_END(CONFIG_SYS_MEMTEST_START + 0x8000000)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_LOAD_ADDRCONFIG_LOADADDR<span class="comment">// Linux kernel在dram中的加载地址，0x80800000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_HZ1000<span class="comment">// 系统时钟频率，1000hz</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_STACKSIZESZ_128K<span class="comment">// 栈大小 128k</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Physical Memory Map */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_NR_DRAM_BANKS1<span class="comment">// dram banks的数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYS_SDRAMMMDC0_ARB_BASE_ADDR<span class="comment">// dram控制MMDC0所管辖的dram范围起始地址，0x80000000</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_SDRAM_BASEPHYS_SDRAM<span class="comment">// dram的起始地址，0x80000000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_INIT_RAM_ADDRIRAM_BASE_ADDR<span class="comment">// 内部iram的起始地址，0x00900000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_INIT_RAM_SIZEIRAM_SIZE<span class="comment">// 内部iram大小，0x00040000=128k</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初试sp偏移</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_INIT_SP_OFFSET \</span></span><br><span class="line">(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初试sp地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_INIT_SP_ADDR \</span></span><br><span class="line">(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FLASH and environment organization */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_NO_FLASH</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYS_BOOT_QSPI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FSL_QSPI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_IS_IN_SPI_FLASH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined CONFIG_SYS_BOOT_NAND</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_USE_NAND</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_IS_IN_NAND</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FSL_QSPI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_IS_IN_MMC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_MMC_ENV_DEV1<span class="comment">// 默认的mmc设备，USDHC2，也就是emmc</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_MMC_ENV_PART0<span class="comment">// 模式分区，默认为第0个分区</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MMCROOT<span class="meta-string">&quot;/dev/mmcblk1p2&quot;</span><span class="comment">// emmc设备的第二个分区      /* USDHC2 */</span></span></span><br><span class="line"><span class="comment">// 第0个分区保存uboot</span></span><br><span class="line"><span class="comment">// 第1个分区保存linux镜像和设备树</span></span><br><span class="line"><span class="comment">// 第2个分区为Linux系统的根文件系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CMD_BMODE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FSL_QSPI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_QSPI_BASEQSPI0_BASE_ADDR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_QSPI_MEMMAP_BASEQSPI0_AMBA_BASE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CMD_SF</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SPI_FLASH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SPI_FLASH_BAR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SF_DEFAULT_BUS0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SF_DEFAULT_CS0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SF_DEFAULT_SPEED40000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SF_DEFAULT_MODESPI_MODE_0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SPI_FLASH_STMICRO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* NAND stuff */</span></span><br><span class="line"><span class="comment">// 与nand有关的定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYS_USE_NAND</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CMD_NAND</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CMD_NAND_TRIMFFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_NAND_MXS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_MAX_NAND_DEVICE1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_NAND_BASE0x40000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_NAND_5_ADDR_CYCLE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_NAND_ONFI_DETECTION</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* DMA stuff, needed for GPMI/MXS NAND support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_APBH_DMA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_APBH_DMA_BURST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_APBH_DMA_BURST8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_SIZESZ_8K<span class="comment">// 环境变量大小，8K</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_ENV_IS_IN_MMC)<span class="comment">// 如果环境变量保存在EMMC中</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_OFFSET(12 * SZ_64K)<span class="comment">// 环境变量便宜地址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_ENV_IS_IN_SPI_FLASH)<span class="comment">// 如果环境变量保存在SPIFLASH中</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_OFFSET(768 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_SECT_SIZE(64 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_SPI_BUSCONFIG_SF_DEFAULT_BUS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_SPI_CSCONFIG_SF_DEFAULT_CS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_SPI_MODECONFIG_SF_DEFAULT_MODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_SPI_MAX_HZCONFIG_SF_DEFAULT_SPEED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_ENV_IS_IN_NAND)<span class="comment">// 如果环境变量定义在nand中</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CONFIG_ENV_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_OFFSET(60 &lt;&lt; 20)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_SECT_SIZE(128 &lt;&lt; 10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_SIZECONFIG_ENV_SECT_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USB Configs */</span></span><br><span class="line"><span class="comment">// usb相关的定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CMD_USB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMD_USB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_USB_EHCI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_USB_EHCI_MX6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_USB_STORAGE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_EHCI_HCD_INIT_AFTER_RESET</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_USB_HOST_ETHER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_USB_ETHER_ASIX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MXC_USB_FLAGS   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_USB_MAX_CONTROLLER_COUNT 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络相关的定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMD_NET</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CMD_PING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CMD_DHCP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CMD_MII</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FEC_MXC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_MII</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FEC_ENET_DEV1<span class="comment">// uboot使用的网口，0,用ENET1  1,用ENET2</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (CONFIG_FEC_ENET_DEV == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMX_FEC_BASEENET_BASE_ADDR<span class="comment">// ENET接口的寄存器首地址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FEC_MXC_PHYADDR          0x0<span class="comment">// 网口PHY芯片的地址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FEC_XCV_TYPE             RMII<span class="comment">// PHY芯片所使用的接口类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (CONFIG_FEC_ENET_DEV == 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMX_FEC_BASEENET2_BASE_ADDR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FEC_MXC_PHYADDR0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FEC_XCV_TYPERMII</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ETHPRIME<span class="meta-string">&quot;FEC&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_PHYLIB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_PHY_SMSC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_IMX_THERMAL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPL_BUILD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_VIDEO<span class="comment">// 开启LCD</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VIDEO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CFB_CONSOLE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_VIDEO_MXS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_VIDEO_LOGO<span class="comment">// 使能LOGO显示</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_VIDEO_SW_CURSOR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_VGA_AS_SINGLE_DEVICE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_CONSOLE_IS_IN_ENV</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SPLASH_SCREEN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SPLASH_SCREEN_ALIGN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CMD_BMP<span class="comment">// 使能BMP图片显示指令，这样就可以在uboot中显示图片了，一般用于显示logo</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_BMP_16BPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_VIDEO_BMP_RLE8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_VIDEO_BMP_LOGO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_IMX_VIDEO_SKIP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FAT_WRITE <span class="comment">/* 使能fatwrite命令 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_IOMUX_LPSR</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_ANDROID_SUPPORT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mx6ullevk_android.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="添加开发板对应的板级文件夹">2.3 添加开发板对应的板级文件夹</h2><p>首先需要创建对应的文件夹，可以直接从已有的复制一个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 复制一个板级文件夹</span></span><br><span class="line">cp board/freescale/mx6ullevk/ -r board/freescale/mx6ull_alientek_emmc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重命名文件</span></span><br><span class="line">mv board/freescale/mx6ull_alientek_emmc/mx6ullevk.c mx6ull_alientek_emmc.c</span><br></pre></td></tr></table></figure><h3 id="修改Makefile">2.3.1 修改Makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj-y  := mx6ull_alientek_emmc.o      <span class="comment"># 修改为这个文件名</span></span><br><span class="line"></span><br><span class="line">extra-<span class="variable">$(CONFIG_USE_PLUGIN)</span> :=  plugin.bin</span><br><span class="line"><span class="variable">$(obj)</span>/plugin.bin: <span class="variable">$(obj)</span>/plugin.o</span><br><span class="line"><span class="variable">$(OBJCOPY)</span> -O binary --gap-fill 0xff <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h3 id="修改imximage-cfg">2.3.2 修改imximage.cfg</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PLUGIN board/freescale/mx6ullevk/plugin.bin 0x00907000</span><br></pre></td></tr></table></figure><p>上述代码修改为</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PLUGIN board/freescale/mx6ull_alientek_emmc /plugin.bin 0x00907000</span><br></pre></td></tr></table></figure><h3 id="修改Kconfig文件">2.3.3 修改Kconfig文件</h3><p>修改kconfig文件为如下代码</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if TARGET_MX6ULL_ALIENTEK_EMMC</span><br><span class="line"></span><br><span class="line">config SYS_BOARD</span><br><span class="line">default <span class="string">&quot;mx6ull_alientek_emmc&quot;</span></span><br><span class="line"></span><br><span class="line">config SYS_VENDOR</span><br><span class="line">default <span class="string">&quot;freescale&quot;</span></span><br><span class="line"></span><br><span class="line">config SYS_SOC</span><br><span class="line">default <span class="string">&quot;mx6&quot;</span></span><br><span class="line"></span><br><span class="line">config SYS_CONFIG_NAME</span><br><span class="line">default <span class="string">&quot;mx6ull_alientek_emmc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h3 id="修改MAINTAINERS文件">2.3.4 修改MAINTAINERS文件</h3><p>修改为如下代码</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MX6ULL_ALIENTEK_EMMC BOARD</span><br><span class="line"><span class="section">M:Peng Fan &lt;peng.fan@nxp.com&gt;</span></span><br><span class="line"><span class="section">S:Maintained</span></span><br><span class="line"><span class="section">F:board/freescale/mx6ull_alientek_emmc/</span></span><br><span class="line"><span class="section">F:include/configs/mx6ull_alientek_emmc.h</span></span><br><span class="line"><span class="section">F:configs/mx6ull_alientek_emmc_defconfig</span></span><br></pre></td></tr></table></figure><h2 id="修改uboot图形界面配置文件">2.4 修改uboot图形界面配置文件</h2><p>修改arch/arm/cpu/armv7/mx6/Kconfig文件或者arch/arm/Kconfig文件</p><p>在 207 行加入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config TARGET_MX6ULL_ALIENTEK_EMMC</span><br><span class="line">bool &quot;Support mx6ull_alientek_emmc&quot;</span><br><span class="line">select MX6ULL</span><br><span class="line">select DM</span><br><span class="line">select DM_THERMAL</span><br></pre></td></tr></table></figure><p>在最后一行的 endif 的前一行添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &quot;board&#x2F;freescale&#x2F;mx6ull_alientek_emmc&#x2F;Kconfig&quot;</span><br></pre></td></tr></table></figure><p>这样对应的开发板就添加到Uboot中了</p><h2 id="使用新添加的板子编译uboot">2.5 使用新添加的板子编译uboot</h2><p>uboot根目录下新建一个编译脚本mx6ull_alientek_emmc.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_alientek_emmc_defconfig</span><br><span class="line">make V=0  ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16</span><br></pre></td></tr></table></figure><p>执行编译脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 mx6ull_alientek_emmc.sh # 给予可执行权限，一次即可</span><br><span class="line">./mx6ull_alientek_emmc.sh         # 运行脚本编译 uboot</span><br></pre></td></tr></table></figure><p>烧入开发板可以运行</p><h2 id="LCD驱动修改">2.6 LCD驱动修改</h2><p>未用到，暂时不修改</p><h2 id="网络驱动修改">2.7 网络驱动修改</h2><ul><li><p>修改PHY地址</p></li><li><p>删除 uboot 中 74LV595 的驱动代码</p></li><li><p>添加开发板网络复位引脚驱动</p></li><li><p>修改 drivers/net/phy/phy.c 文件中的函数 genphy_update_link</p></li></ul><h2 id="测试">2.8 测试</h2><p>编译uboot后烧入代码，启动后可以看到“Net： FEC1”这一行，提示当前使用的 FEC1 这个网口，也就是 ENET2</p><p>设置开发板环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setenv ipaddr 192.168.1.55       # 开发板 IP 地址</span><br><span class="line">setenv ethaddr 00:04:9f:04:d2:35 # 开发板网卡 MAC 地址</span><br><span class="line">setenv gatewayip 192.168.1.1     # 开发板默认网关</span><br><span class="line">setenv netmask 255.255.255.0     # 开发板子网掩码</span><br><span class="line">setenv serverip 192.168.1.250    # 服务器地址，也就是 Ubuntu 地址</span><br><span class="line">saveenv                          # 保存环境变量</span><br></pre></td></tr></table></figure><p>ping主机可以Ping通</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.1.250</span><br></pre></td></tr></table></figure><p>再来测试一下 ENET1 的网络是否正常工作，打开 mx6ull_alientek_emmc.h， 将 CONFIG_FEC_ENET_DEV 改为 0，然后重新编译一下 uboot 并烧写到 SD 卡中重启，也可以Ping通</p><blockquote><p>CONFIG_FEC_ENET_DEV 设置为 0，使用的是ENET1</p><p>CONFIG_FEC_ENET_DEV 设置为 1，使用的是ENET2，建议设置这个为Uboot默认网口</p></blockquote><h2 id="修改uboot启动时输出的开发板名称">2.9 修改uboot启动时输出的开发板名称</h2><p>修改 mx6ull_alientek_emmc.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkboard</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_mx6ull_9x9_evk())</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Board: MX6ULL 9x9 EVK\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Board: MX6ULL ALIENTEK EMMC\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置bootcmd和bootargs环境变量">2.10 设置bootcmd和bootargs环境变量</h2><p>bootcmd 保存着 uboot 默认命令，uboot 倒计时结束以后就会执行 bootcmd 中的命令。这些命令一般都是用来启动 Linux 内核的，比如读取 EMMC 或 者 NAND Flash 中的 Linux 内核镜像文件和设备树文件到 DRAM 中，然后启动 Linux 内核。</p><p>可以在 uboot 启动以后进入命令行设置 bootcmd 环境变量的值。</p><p>如果 EMMC 或者 NAND 中没有保存 bootcmd 的值，那么 uboot 就会使用默认的值，板子第一次运行 uboot 的时候都会使用默认值来设置 bootcmd 环境变量。</p><p> include/env_default.h中，bootcmd 的默认值就是CONFIG_BOOTCOMMAND，bootargs 的默认值就是 CONFIG_BOOTARGS。mx6ull_alientek_emmc.h 文件中通过设置宏 CONFIG_BOOTCOMMAND 来设置 bootcmd 的默认值。</p><h3 id="bootcmd">2.10.1 bootcmd</h3><h3 id="bootargs">2.10.2 bootargs</h3><p>bootargs 保存着 uboot 传递给 Linux 内核的参数</p><ul><li>console：设置 linux 终端(或者叫控制台)</li><li>root：设置根文件系统的位置</li><li>rootfstype：于指定根文件系统类型</li></ul><h1 id="uboot启动Linux测试">3 uboot启动Linux测试</h1><h2 id="从EMMC启动Linux系统">3.1 从EMMC启动Linux系统</h2><p>将Linux镜像文件zImage和设备树文件保存在EMMC中，检查下EMMC中是否有zImage文件和设备树文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls mmc 1:1</span><br></pre></td></tr></table></figure><p>设置 bootargs 和 bootcmd这两个环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">setenv bootcmd &#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000;&#x27;</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>输入<strong>boot</strong>或者<strong>run bootcmd</strong>可以启动Linux内核</p><h2 id="从网络启动Linux系统">3.2 从网络启动Linux系统</h2><p>设置 bootargs 和 bootcmd 这两个环境变量，设置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">setenv bootcmd &#x27;tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000&#x27;</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>一开始是通过tftp下载zImage和imx6ull-alientek-emmc.dtb这两个文件</p><p>下载完成以后就是启动 Linux 内核</p>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uboot图形化配置</title>
      <link href="posts/196c55f4.html"/>
      <url>posts/196c55f4.html</url>
      
        <content type="html"><![CDATA[<h1 id="配置体验">1 配置体验</h1><p>安装ncurses库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure><p>首先需要使用<code>make xxx_defconfig</code>进行默认配置，然后再使用<code>make menuconfig</code>来对uboot进一步配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_alientek_emmc_defconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig</span><br></pre></td></tr></table></figure><blockquote><p>在menuconfig界面中：</p><p>按下Y：将当前选择的编译进uboot</p><p>按下N：当前选择的不编译进uboot</p><p>按下M：当前选择的编译为模块</p><p>按下H或者？：显示当前选项的提示信息</p></blockquote><p>例如使能DNS</p><p>“Command line interface —&gt;Network commands —&gt;选中dns</p><p>编译烧录uboot</p><p>设置dns服务器的IP地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv dnsip 114.114.114.114</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>使用dns命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns www.baidu.com</span><br></pre></td></tr></table></figure><h1 id="原理">2 原理</h1><p>当输入 make menuconfig 以后会匹配到顶层 Makefile 的如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%config: scripts_basic outputmakefile FORCE</span></span><br><span class="line"><span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=scripts/kconfig <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>其中 <code>build=-f ./scripts/Makefile.build obj</code></p><p>所以第一行展开就是<code>@ make -f ./scripts/Makefile.build obj=scripts/kconfig menuconfig</code></p><p>Makefile.build 会读取 scripts/kconfig/Makefile 中的内容，在 scripts/kconfig/Makefile 中可以找到如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">menuconfig: <span class="variable">$(obj)</span>/mconf</span></span><br><span class="line"><span class="variable">$&lt;</span> <span class="variable">$(silent)</span> <span class="variable">$(Kconfig)</span></span><br></pre></td></tr></table></figure><p>其中obj= scripts/kconfig，silent是设置静默编译的，在这里可以忽略不计，Kconfig=Kconfig，因此扩展以后就是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">menuconfig: scripts/kconfig/mconf</span></span><br><span class="line">scripts/kconfig/mconf Kconfig</span><br></pre></td></tr></table></figure><p>目标 menuconfig 依赖 scripts/kconfig/mconf，因此 scripts/kconfig/mconf.c 这个文件会被编译，生成 mconf 这个可执行文件。目标 menuconfig 对应的规则为 scripts/kconfig/mconf Kconfig，也就是说 mconf 会调用 uboot 根目录下的 Kconfig 文件开始构建图形配置界面。</p><h1 id="Kconfig语法">3 Kconfig语法</h1><h2 id="mainmenu">3.1 mainmenu</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainmenu <span class="string">&quot;U-Boot $UBOOTVERSION Configuration&quot;</span></span><br></pre></td></tr></table></figure><img "" class="lazyload placeholder" data-original="/posts/196c55f4/image-20210714142218204.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210714142218204" style="zoom:50%;"><p>mainmenu用来配置主菜单名</p><h2 id="source">3.2 source</h2><p>读取其他目录下的Kconfig</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&quot;xxx/Kconfig&quot;</span> <span class="comment">//xxx 为具体的目录名，相对路径</span></span><br></pre></td></tr></table></figure><h2 id="menu-endmenu条目">3.3 menu/endmenu条目</h2><p>menu 用于生成菜单，endmenu 就是菜单结束标志，这两个一般是成对出现的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">menu <span class="string">&quot;General setup&quot;</span></span><br><span class="line"></span><br><span class="line">config LOCALVERSION</span><br><span class="line">string <span class="string">&quot;Local version - append to U-Boot release&quot;</span></span><br><span class="line"></span><br><span class="line">config LOCALVERSION_AUTO</span><br><span class="line">bool <span class="string">&quot;Automatically append version information to the version string&quot;</span></span><br><span class="line">default y</span><br><span class="line"></span><br><span class="line">endmenu<span class="comment"># General setup</span></span><br></pre></td></tr></table></figure><img "" class="lazyload placeholder" data-original="/posts/196c55f4/image-20210714143147031.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210714143147031" style="zoom:50%;"><h2 id="变量类型">3.4 变量类型</h2><p>Bool:y/n 是否</p><p>Tristate:y/m/n 是/模块/否</p><p>String：字符串</p><p>Help: 表示帮助信息</p><p>Default：表示默认值</p><h2 id="Depends-on和select">3.5 Depends on和select</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">config SYS_GENERIC_BOARD</span><br><span class="line">bool</span><br><span class="line">depends on HAVE_GENERIC_BOARD</span><br><span class="line"></span><br><span class="line">choice</span><br><span class="line">prompt <span class="string">&quot;Architecture select&quot;</span></span><br><span class="line">default SANDBOX</span><br><span class="line"></span><br><span class="line">config ARC</span><br><span class="line">bool <span class="string">&quot;ARC architecture&quot;</span></span><br><span class="line">select HAVE_PRIVATE_LIBGCC</span><br><span class="line">select HAVE_GENERIC_BOARD</span><br><span class="line">select SYS_GENERIC_BOARD</span><br><span class="line">select SUPPORT_OF_CONTROL</span><br></pre></td></tr></table></figure><p>Depends on 说明SYS_GENERIC_BOARD依赖于HAVE_GENERIC_BOARD</p><p>select 表示ARC选中后，HAVE_PRIVATE_LIBGCC等也会被选中</p><h2 id="choice-endchoice">3.6 choice/endchoice</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">choice</span><br><span class="line">prompt <span class="string">&quot;Architecture select&quot;</span></span><br><span class="line">default SANDBOX</span><br><span class="line"></span><br><span class="line">config ARC</span><br><span class="line">bool <span class="string">&quot;ARC architecture&quot;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">config ARM</span><br><span class="line">bool <span class="string">&quot;ARM architecture&quot;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">config AVR32</span><br><span class="line">bool <span class="string">&quot;AVR32 architecture&quot;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">config BLACKFIN</span><br><span class="line">bool <span class="string">&quot;Blackfin architecture&quot;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">config M68K</span><br><span class="line">bool <span class="string">&quot;M68000 architecture&quot;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">endchoice</span><br></pre></td></tr></table></figure><img "" class="lazyload placeholder" data-original="/posts/196c55f4/image-20210714143855491.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210714143855491" style="zoom:50%;"><p>定义一组可选项</p><h2 id="menuconfig">3.7 menuconfig</h2><p>带有选项的菜单，只有EXPERT被选中了，里面的选项才会显示出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">menu &quot;General setup&quot;</span><br><span class="line"></span><br><span class="line">menuconfig EXPERT</span><br><span class="line">bool &quot;Configure standard U-Boot features (expert users)&quot;</span><br><span class="line">default y</span><br><span class="line"></span><br><span class="line">if EXPERT</span><br><span class="line">config SYS_MALLOC_CLEAR_ON_INIT</span><br><span class="line">bool &quot;Init with zeros the memory reserved for malloc (slow)&quot;</span><br><span class="line">default y</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">endmenu # General setup</span><br></pre></td></tr></table></figure><img "" class="lazyload placeholder" data-original="/posts/196c55f4/image-20210714144247011.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210714144247011" style="zoom:50%;"><img "" class="lazyload placeholder" data-original="/posts/196c55f4/image-20210714144257714.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210714144257714" style="zoom:50%;"><h2 id="comment">3.8 comment</h2><p>用于图形化界面中显示注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config NAND_ARASAN</span><br><span class="line">bool &quot;Configure Arasan Nand&quot;</span><br><span class="line"></span><br><span class="line">comment &quot;Generic NAND options&quot;</span><br></pre></td></tr></table></figure><img "" class="lazyload placeholder" data-original="/posts/196c55f4/image-20210714144554386.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210714144554386" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uboot</title>
      <link href="posts/90b9e97a.html"/>
      <url>posts/90b9e97a.html</url>
      
        <content type="html"><![CDATA[<h1 id="U-Boot简介">1 U-Boot简介</h1><p>uboot 官网为 <a href="http://www.denx.de/wiki/U-Boot/">http://www.denx.de/wiki/U-Boot/</a></p><p>NXP 就 维 护 的 2016.03 这 个 版 本 的 uboot ， 下 载 地 址 为 ：<a href="http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/tag/?h=imx_v2016.03_4.1.15_2.0.0_ga&amp;id=rel_imx_4.1.15_2.1.0_ga">http://git.freescale.com/git/cgit.cgi/imx/uboot-imx.git/tag/?h=imx_v2016.03_4.1.15_2.0.0_ga&amp;id=rel_imx_4.1.15_2.1.0_ga</a></p><h1 id="U-Boot编译">2 U-Boot编译</h1><p>首先在 Ubuntu 中安装 ncurses 库，否则编译会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure><p>编译命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_ddr512_emmc_defconfig</span><br><span class="line">make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12</span><br></pre></td></tr></table></figure><h1 id="U-Boot烧写">3 U-Boot烧写</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 imxdownload //给予 imxdownload 可执行权限，一次即可</span><br><span class="line">./imxdownload u-boot.bin /dev/sdd //烧写到 SD 卡，不能烧写到/dev/sda 或 sda1 设备里面！</span><br></pre></td></tr></table></figure><h1 id="U-Boot启动">4 U-Boot启动</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">示例代码 30.3.1 uboot 输出信息</span><br><span class="line">U-Boot 2016.03-gd3f0479 (Aug 07 2020 - 20:47:37 +0800) </span><br><span class="line"></span><br><span class="line">CPU: Freescale i.MX6ULL rev1.1 792 MHz (running at 396 MHz) </span><br><span class="line">CPU: Industrial temperature grade (-40C to 105C) at 51C</span><br><span class="line">Reset cause: POR</span><br><span class="line">Board: I.MX6U ALPHA|MINI</span><br><span class="line">I2C: ready</span><br><span class="line">DRAM: 512 MiB</span><br><span class="line">MMC: FSL_SDHC: 0, FSL_SDHC: 1</span><br><span class="line">Display: ATK-LCD-7-1024x600 (1024x600)</span><br><span class="line">Video: 1024x600x24</span><br><span class="line">In: serial</span><br><span class="line">Out: serial</span><br><span class="line">Err: serial</span><br><span class="line">switch to partitions #0, OK</span><br><span class="line">mmc1(part 0) is current device</span><br><span class="line">Net: FEC1</span><br><span class="line">Error: FEC1 address not set.</span><br><span class="line"></span><br><span class="line">Normal Boot</span><br><span class="line">Hit any key to stop autoboot: 0</span><br><span class="line">&#x3D;&gt;</span><br></pre></td></tr></table></figure><p>第 1 行是 uboot 版本号和编译时间，可以看出，当前的 uboot 版本号是 2016.03，编译时间是 2020 年 8 月 7 日凌晨 20 点 47 分。 </p><p>第 3 和第 4 行是 CPU 信息，可以看出当前使用的 CPU 是飞思卡尔的 I.MX6ULL（I.MX 以前属于飞思卡尔，然而飞思卡尔被 NXP 收购了），频率为 792MHz，但是此时运行在 396MHz。这颗芯片是工业级的，结温为-40°C~105°C。</p><p>第 5 行是复位原因，当前的复位原因是 POR。I.MX6ULL 芯片上有个 POR_B 引脚，将这个引脚拉低即可复位 I.MX6ULL。 </p><p>第 6 行是板子名字，当前的板子名字为“I.MX6U ALPHA|MINI”。</p><p>第 7 行提示 I2C 准备就绪。</p><p>第 8 行提示当前板子的 DRAM（内存）为 512MB，如果是 NAND 版本的话内存为 256MB。</p><p>第 9 行提示当前有两个 MMC/SD 卡控制器：FSL_SDHC(0)和 FSL_SDHC(1)。I.MX6ULL支持两个 MMC/SD，正点原子的 I.MX6ULL EMMC 核心板上 FSL_SDHC(0)接的 SD(TF)卡，FSL_SDHC(1)接的 EMMC。 </p><p>第 10 和第 11 行是 LCD 型号，当前的 LCD 型号是 ATK-LCD-7-1024x600 (1024x600)，分辨率为 1024x600，格式为 RGB888(24 位)。 </p><p>第 12~14 是标准输入、标准输出和标准错误所使用的终端，这里都使用串口(serial)作为终端。</p><p>第 15 和 16 行是切换到 emmc 的第 0 个分区上，因为当前的 uboot 是 emmc 版本的，也就是从 emmc 启动的。我们只是为了方便将其烧写到了 SD 卡上，但是它的“内心”还是 EMMC的。所以 uboot 启动以后会将 emmc 作为默认存储器，当然了，你也可以将 SD 卡作为 uboot 的存储器，这个我们后面会讲解怎么做。</p><p>第 17 行是网口信息，提示我们当前使用的 FEC1 这个网口，I.MX6ULL 支持两个网口。</p><p>第 18 行提示 FEC1 网卡地址没有设置，后面我们会讲解如何在 uboot 里面设置网卡地址。</p><p>第 20 行提示正常启动，也就是说 uboot 要从 emmc 里面读取环境变量和参数信息启动 Linux内核了。</p><p>第 21 行是倒计时提示，默认倒计时 3 秒，倒计时结束之前按下回车键就会进入 Linux 命令行模式。如果在倒计时结束以后没有按下回车键，那么 Linux 内核就会启动，Linux 内核一旦启动，uboot 就会寿终正寝。</p><h1 id="U-Boot命令">5 U-Boot命令</h1><p>进入 uboot 的命令行模式以后输入“help”或者“？”，然后按下回车即可查看当前 uboot 所支持的命令，如下图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210619224146998.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="uboot命令列表" style="zoom:50%;"><h2 id="查看命令的详细用法">5.1 查看命令的详细用法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? bootz </span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span> </span><br><span class="line">help bootz</span><br></pre></td></tr></table></figure><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210619225750059.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="bootz 命令使用说明" style="zoom:50%;"><h2 id="信息查询命令">5.2 信息查询命令</h2><h3 id="bdinfo">5.2.1 bdinfo</h3><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210619225932043.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="bdinfo 命令" style="zoom:50%;"><p>可以得出 DRAM 的起始地址和大小、启动参数保存起始地址、波特率、sp(堆栈指针)起始地址等信息。</p><h3 id="printenv">5.2.2 printenv</h3><p>命令“printenv”用于输出环境变量信息，uboot 也支持 TAB 键自动补全功能，输入“print”然后按下 TAB 键就会自动补全命令，直接输入“print”也可以。输入“print”，然后按下回车键，环境变量如下图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210619230103790.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="printenv 命令结果" style="zoom: 50%;"><h3 id="version">5.2.3 version</h3><p>命令 version 用于查看 uboot 的版本号</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210619230859876.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="version 命令结果" style="zoom:50%;"><p>当前 uboot 版本号为 2016.03，2020 年 8 月 7 日编译的，编译器为arm-poky-linux-gnueabi-gcc，这是 NXP 官方提供的编译器</p><h2 id="环境变量">5.3 环境变量</h2><h3 id="setenv-修改环境变量">5.3.1 setenv 修改环境变量</h3><p>将环境变量 bootdelay 改为 5，就可以使用如下所示命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv bootdelay 5</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210619232814961.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="环境变量修改" style="zoom:50%;"><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210619232832014.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="5秒倒计时" style="zoom:50%;"><p>有时候我们修改的环境变量值可能会有空格，比如 bootcmd、bootargs 等，这个时候环境变量值就得用单引号括起来，比如下面修改环境变量 bootargs 的值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>上面命令设置 bootargs 的值为“console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw”，其中“console=ttymxc0,115200”、“root=/dev/mmcblk1p2”、“rootwait”和“rw”相当于四组“值”，这四组“值”之间用空格隔开，所以需要使用单引号‘’将其括起来，表示这四组“值”都属于环境变量 bootargs。</p><h3 id="setenv-新建环境变量">5.3.2 setenv 新建环境变量</h3><p>命令 setenv 也可以用于新建命令，用法就是修改环境变量一样，比如我们新建一个环境变量 author，author 的值为creekwater，那么就可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv author creekwater</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>新建环境变量 creekwater 完成以后重启 uboot，然后使用命令 printenv 查看当前环境变量。</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210620180856303.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="环境变量" style="zoom:50%;"><h3 id="setevn-删除环境变量">5.3.3 setevn 删除环境变量</h3><p>既然可以新建环境变量，那么就可以删除环境变量，删除环境变量也是使用命令 setenv，要删除一个环境变量只要给这个环境变量赋空值即可，比如我们删除掉上面新建的 author 这个环境变量，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv creekwater</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>上面命令中通过 setenv 给 author 赋空值，也就是什么都不写来删除环境变量 author。重启uboot 就会发现环境变量 author 没有了。</p><h2 id="内存操作命令">5.4 内存操作命令</h2><p>内存操作命令就是用于直接对 DRAM 进行读写操作的，常用的内存操作命令有 md、nm、mm、mw、cp 和 cmp。我们依次来看一下这些命令都是做什么的。</p><h3 id="md-显示内存值">5.4.1 md 显示内存值</h3><p>md 命令用于显示内存值，格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md[.b, .w, .l] address [# of objects]</span><br></pre></td></tr></table></figure><p>命令中的[.b .w .l]对应 byte、word 和 long，也就是分别以 1 个字节、2 个字节、4 个字节来显示内存值。address 就是要查看的内存起始地址，[# of objects]表示要查看的数据长度，这个数据长度单位不是字节，而是跟你所选择的显示格式有关。</p><p>比如你设置要查看的内存长度为20(十六进制为 0x14)，如果显示格式为.b 的话那就表示 20 个字节；</p><p>如果显示格式为.w 的话就表示 20 个 word，也就是 20*2=40 个字节；</p><p>如果显示格式为.l 的话就表示 20 个 long，也就是20*4=80 个字节。</p><blockquote><p>注意：uboot 命令中的数字都是十六进制的！不是十进制的！</p></blockquote><p>如果查看以 0X80000000 开始的 20 个字节的内存值，显示格式为.b 的话，应该使用如下所示命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">md.b 80000000 14</span><br><span class="line"><span class="meta">#</span><span class="bash"> 而不是 md.b 80000000 20</span></span><br></pre></td></tr></table></figure><p>因为uboot 命令里面的数字都是十六进制的，所以可以不用写“0x”前缀，十进制的 20 其十六进制为 0x14，所以命令 md 后面的个数应该是 14，如果写成 20 的话就表示查看32(十六进制为 0x20)个字节的数据。分析下面三个命令的区别：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">md.b 80000000 10</span><br><span class="line">md.w 80000000 10</span><br><span class="line">md.l 80000000 10</span><br></pre></td></tr></table></figure><p>上面这三个命令都是查看以 0X80000000 为起始地址的内存数据，第一个命令以.b 格式显示，长度为 0x10，也就是 16 个字节；</p><p>第二个命令以.w 格式显示，长度为 0x10，也就是 16*2=32个字节；</p><p>最后一个命令以.l 格式显示，长度也是 0x10，也就是 16*4=64 个字节。</p><p>这三个命令的执行结果如下图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210619234336918.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="md 命令使用示意" style="zoom:50%;"><h3 id="nm-修改内存值">5.4.2 nm 修改内存值</h3><p>nm 命令用于修改指定地址的内存值，命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm [.b, .w, .l] address</span><br></pre></td></tr></table></figure><p>nm 命令同样可以以.b、.w 和.l 来指定操作格式，比如现在以.l 格式修改 0x80000000 地址的数据为 0x12345678。输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm.l 80000000</span><br></pre></td></tr></table></figure><p>输入上述命令以后如下图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210619234758340.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="nm 命令" style="zoom:50%;"><p>在上图中，80000000 表示现在要修改的内存地址，0500e031 表示地址 0x80000000 现在的数据，？后面就可以输入要修改后的数据 0x12345678，输入完成以后按下回车，然后再输</p><p>入‘q’即可退出，如下图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210619234918951.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="修改内存数据" style="zoom:50%;"><p>修改完成以后在使用命令 md 来查看一下有没有修改成功，如下图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210619235122533.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="查看修改后的值" style="zoom:50%;"><p>此时地址 0X80000000 的值变为了 0x12345678。</p><h3 id="mm-修改内存值">5.4.3 mm 修改内存值</h3><p>mm 命令也是修改指定地址内存值的，使用 mm 修改内存值的时候地址会自增，而使用命令 nm 的话地址不会自增。比如以.l 格式修改从地址 0x80000000 开始的连续 3 个内存块(3*4=12个字节)的数据为 0X05050505，操作如下图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210619235235921.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="mm 命令" style="zoom:50%;"><p>从上图可以看出，修改了地址 0X80000000、0X80000004 和 0X8000000C 的内容为0x05050505。使用命令 md 查看修改后的值，结果如图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210619235312726.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="查看修改后的内存数据" style="zoom:50%;"><p>可以看出内存数据修改成功。</p><h3 id="mw-填充内存">5.4.4 mw 填充内存</h3><p>命令 mw 用于使用一个指定的数据填充一段内存，命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mw [.b, .w, .l] address value [count]</span><br></pre></td></tr></table></figure><p>mw 命令同样可以以.b、.w 和.l 来指定操作格式，address 表示要填充的内存起始地址，value为要填充的数据，count 是填充的长度。比如使用.l 格式将以 0X80000000 为起始地址的 0x10 个内存块(0x10 * 4=64 字节)填充为 0X0A0A0A0A，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mw.l 80000000 0A0A0A0A 10</span><br></pre></td></tr></table></figure><p>然后使用命令 md 来查看，如下图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210620180352686.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="查看修改后的内存数据" style="zoom:50%;"><h3 id="cp-数据拷贝">5.4.5 cp 数据拷贝</h3><p>cp 是数据拷贝命令，用于将 DRAM 中的数据从一段内存拷贝到另一段内存中，或者把 Nor Flash 中的数据拷贝到 DRAM 中。命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [.b, .w, .l] source target count</span><br></pre></td></tr></table></figure><p>cp 命令同样可以以.b、.w 和.l 来指定操作格式，source 为源地址，target 为目的地址，count 为拷贝的长度。我们使用.l 格式将 0x80000000 处的地址拷贝到 0X80000100 处，长度为 0x10 个内存块(0x10 * 4=64 个字节)，命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp.l 80000000 80000100 10</span><br></pre></td></tr></table></figure><p>结果如图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210620181625687.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="cp 命令操作结果" style="zoom:50%;"><p>在上图中，先使用 md.l 命令打印出地址 0x80000000 和 0x80000100 处的数据，然后使用命令cp.l将0x80000100处的数据拷贝到0x80000100处。最后使用命令md.l查看0x80000100处的数据有没有变化，检查拷贝是否成功。</p><h3 id="cmp-内存数据比较">5.4.6 cmp 内存数据比较</h3><p>cmp 是比较命令，用于比较两段内存的数据是否相等，命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp [.b, .w, .l] addr1 addr2 count</span><br></pre></td></tr></table></figure><p>cmp 命令同样可以以.b、.w 和.l 来指定操作格式，addr1 为第一段内存首地址，addr2 为第二段内存首地址，count 为要比较的长度。我们使用.l 格式来比较 0x80000000 和 0X80000100 这两个地址数据是否相等，比较长度为 0x10 个内存块(16 * 4=64 个字节)，命令如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp.l 80000000 80000100 10</span><br></pre></td></tr></table></figure><p>结果如图</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210620181935193.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="cmp 命令比较结果" style="zoom:50%;"><p>从上图可以看出两段内存的数据相等。我们再随便挑两段内存比较一下，比如地址 0x80002000 和 0x800003000，长度为 0X10，比较结果下图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210620182043861.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="cmp 命令比较结果" style="zoom:50%;"><p>从上图可以看出，0x80002000 处的数据和 0x80003000 处的数据就不一样。</p><h2 id="网络操作命令">5.5 网络操作命令</h2><p>uboot 是支持网络的，我们在移植 uboot 的时候一般都要调通网络功能，因为在移植 linux kernel 的时候需要使用到 uboot 的网络功能做调试。uboot 支持大量的网络相关命令，比如 dhcp、ping、nfs 和 tftpboot，接下来依次学习一下这几个和网络有关的命令。</p><p>在使用 uboot 的网络功能之前先用网线将开发板的 ENET2 接口和电脑或者路由器连接起来，I.MX6U-ALPHA 开发板有两个网口：ENET1 和 ENET2，一定要连接 ENET2，不能连接错了，ENET2 接口如图所示。</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210620182313644.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="ENET2 网络接口" style="zoom:50%;"><p>建议开发板和主机 PC 都连接到同一个路由器上！最后设置表中所示的几个环境变量。</p><table><thead><tr><th>环境变量</th><th>描述</th></tr></thead><tbody><tr><td>ipaddr</td><td>开发板 ip 地址，可以不设置，使用 dhcp 命令来从路由器获取 IP 地址。</td></tr><tr><td>ethaddr</td><td>开发板的 MAC 地址，一定要设置。</td></tr><tr><td>gatewayip</td><td>网关地址。</td></tr><tr><td>netmask</td><td>子网掩码。</td></tr><tr><td>serverip</td><td>服务器 IP 地址，也就是 Ubuntu 主机 IP 地址，用于调试代码。</td></tr></tbody></table><p>表中环境变量设置命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setenv ipaddr 192.168.1.50</span><br><span class="line">setenv ethaddr 00:04:9f:04:d2:35</span><br><span class="line">setenv gatewayip 192.168.1.1</span><br><span class="line">setenv netmask 255.255.255.0</span><br><span class="line">setenv serverip 192.168.1.253</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>注意，网络地址环境变量的设置要根据自己的实际情况，确保 Ubuntu 主机和开发板的 IP地址在同一个网段内，比如我现在的开发板和电脑都在 192.168.1.0 这个网段内，所以设置开发板的 IP 地址为 192.168.1.50，我的 Ubuntu 主机的地址为 192.168.1.253，因此 serverip 就是192.168.1.253。ethaddr 为网络 MAC 地址，是一个 48bit 的地址，如果在同一个网段内有多个开发板的话一定要保证每个开发板的 ethaddr 是不同的，否则通信会有问题！设置好网络相关的环境变量以后就可以使用网络相关命令了。</p><h3 id="ping-命令">5.5.1 ping 命令</h3><p>开发板的网络能否使用，是否可以和服务器(Ubuntu 主机)进行通信，通过 ping 命令就可以验证，直接 ping 服务器的 IP 地址即可，比如我的服务器 IP 地址为 192.168.1.253，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.1.253</span><br></pre></td></tr></table></figure><p>结果如图所示</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210620182910766.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="ping 命令" style="zoom:50%;"><p>可以看出，192.168.1.253 这个主机存在，说明 ping 成功，uboot 的网络工作正常。</p><blockquote><p>注意！只能在 uboot 中 ping 其他的机器，其他机器不能 ping uboot，因为 uboot 没有对 ping命令做处理，如果用其他的机器 ping uboot 的话会失败！</p></blockquote><h3 id="dhcp-命令">5.5.2 dhcp 命令</h3><p>dhcp 用于从路由器获取 IP 地址，前提得开发连接到路由器上的，如果开发板是和电脑直连的，那么 dhcp 命令就会失效。直接输入 dhcp 命令即可通过路由器获取到 IP 地址，如图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210620183208736.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="dhcp 命令" style="zoom:50%;"><p>从上图可以看出，开发板通过 dhcp 获取到的 IP 地址为 192.168.1.137。同时在上图中可以看到“warning：no boot file name;”、“TFTP from server 192.168.1.1”这样的字样。这是因为 DHCP 不单单是获取 IP 地址，其还会通过 TFTP 来启动 linux 内核，输入“? dhcp”可查看 dhcp 命令详细的信息，如下图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210620183337213.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="dhcp 命令使用查询" style="zoom:50%;"><h3 id="nfs-命令">5.5.3 nfs 命令</h3><p>nfs(Network File System)网络文件系统，通过 nfs 可以在计算机之间通过网络来分享资源，比如我们将 linux 镜像和设备树文件放到 Ubuntu 中，然后在 uboot 中使用 nfs 命令将 Ubuntu 中 的 linux 镜像和设备树下载到开发板的 DRAM 中。这样做的目的是为了方便调试 linux 镜像和设备树，也就是网络调试，通过网络调试是 Linux 开发中最常用的调试方法。原因是嵌入式 linux开发不像单片机开发，可以直接通过 JLINK 或 STLink 等仿真器将代码直接烧写到单片机内部的 flash 中，嵌入式 Linux 通常是烧写到 EMMC、NAND Flash、SPI Flash 等外置 flash 中，但是嵌入式 Linux 开发也没有 MDK，IAR 这样的 IDE，更没有烧写算法，因此不可能通过点击一个“download”按钮就将固件烧写到外部 flash 中。虽然半导体厂商一般都会提供一个烧写固件的软件，但是这个软件使用起来比较复杂，这个烧写软件一般用于量产的。其远没有 MDK、IAR的一键下载方便，在 Linux 内核调试阶段，如果用这个烧写软件的话将会非常浪费时间，而这个时候网络调试的优势就显现出来了，可以通过网络将编译好的 linux 镜像和设备树文件下载到 DRAM 中，然后就可以直接运行。</p><p>我们一般使用 uboot 中的 nfs 命令将 Ubuntu 中的文件下载到开发板的 DRAM 中，在使用之前需要开启 Ubuntu 主机的 NFS 服务，并且要新建一个 NFS 使用的目录，以后所有要通过NFS 访问的文件都需要放到这个 NFS 目录中。Ubuntu 的 NFS 服务开启前文已经详细讲解过了，包括 NFS 文件目录的创建。我设置的/home/creekwater/linux/nfs 这个目录为我的 NFS 文件目录。uboot 中的 nfs 命令格式如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nfs [loadAddress] [[hostIPaddr:]bootfilename]</span><br></pre></td></tr></table></figure><p>loadAddress 是要保存的 DRAM 地址，[[hostIPaddr:]bootfilename]是要下载的文件地址。这里我们将正点原子官方编译出来的 Linux 镜像文件 zImage 下载到开发板 DRAM 的 0x80800000这个地址处。正点原子编译出来的 zImage 文件已经放到了开发板光盘中，路径为：8、系统镜像-&gt;1、出厂系统镜像-&gt;2、kernel 镜像\linux-imx-4.1.15-2.1.0-gbfed875-v1.6 -&gt;zImage。将文件zImage 通 过 FileZilla 发送到 Ubuntu 中 的 NFS 目 录 下 ， 比 如 我 的 就 是 放 到/home/creekwater/linux/nfs 这个目录下，完成以后的 NFS 目录如图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210620184356976.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="NFS 目录中的 zImage 文件" style="zoom:50%;"><p>准备好以后就可以使用 nfs 命令来将 zImage 下载到开发板 DRAM 的 0X80800000 地址处，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nfs 80800000 192.168.1.253:&#x2F;home&#x2F;creekwater&#x2F;linux&#x2F;nfs&#x2F;zImage</span><br></pre></td></tr></table></figure><p>命令中的“ 80800000 ” 表 示 zImage 保 存 地 址 ，“192.168.1.253:/home/creekwater/linux/nfs/zImage”表示 zImage 在 192.168.1.253 这个主机中，路径为/home/creekwater/linux/nfs/zImage。下载过程如图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210620184910494.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="nfs 命令下载 zImage 过程" style="zoom:50%;"><p>在上图中会以“#”提示下载过程，下载完成以后会提示下载的数据大小，这里下载的 6785272 字节(出厂系统在不断的更更新中，因此以实际的 zImage 大小为准)，而 zImage 的大小就是 6785272 字节，如下图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210620185346075.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="zImage 大小" style="zoom:50%;"><p>下载完成以后查看 0x80800000 地址处的数据，使用命令 md.b 来查看前 0x100 个字节的数据，如图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210620185801053.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="下载的数据" style="zoom:50%;"><p>在使用 winhex 软件来查看 zImage，检查一下前面的数据是否和上图的一致，结果如下图所示：</p><img "" class="lazyload placeholder" data-original="/posts/90b9e97a/image-20210620185849955.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="winhex 查看 zImage" style="zoom:50%;"><p>可以看出两个图中的前 100 个字节的数据一致，说明 nfs 命令下载到的 zImage 是正确的。</p><h3 id="tftp-命令">5.5.4 tftp 命令</h3><h2 id="EMMC和SD卡操作命令">5.6 EMMC和SD卡操作命令</h2><h3 id="mmc-info-命令">5.6.1 mmc info 命令</h3><h3 id="mmc-rescan-命令">5.6.2 mmc rescan 命令</h3><h3 id="mmc-list">5.6.3 mmc list</h3><h3 id="mmc-dev">5.6.4 mmc dev</h3><h3 id="mmc-part">5.6.5 mmc part</h3><h3 id="mmc-read">5.6.6 mmc read</h3><h3 id="mmc-write">5.6.7 mmc write</h3><h3 id="mmc-erase">5.6.8 mmc erase</h3><h2 id="FAT-格式文件系统操作命令">5.7 FAT 格式文件系统操作命令</h2><h3 id="fatinfo">5.7.1 fatinfo</h3><h3 id="fatls">5.7.2 fatls</h3><h3 id="fstype">5.7.3 fstype</h3><h3 id="fatload">5.7.4 fatload</h3><h3 id="fatwrite">5.7.5 fatwrite</h3><h2 id="EXT-格式文件系统操作命令">5.8 EXT 格式文件系统操作命令</h2><h2 id="NAND-操作指令">5.9 NAND 操作指令</h2><h3 id="nand-info">5.9.1 nand info</h3><h3 id="nand-device">5.9.2 nand device</h3><h3 id="nand-erase">5.9.3 nand erase</h3><h3 id="nand-write">5.9.4 nand write</h3><h3 id="nand-read">5.9.5 nand read</h3><h2 id="BOOT-操作命令">5.10 BOOT 操作命令</h2><h3 id="bootz">5.10.1 bootz</h3><h3 id="bootm">5.10.2 bootm</h3><h3 id="boot">5.10.3 boot</h3><h2 id="其他常用命令">5.11 其他常用命令</h2><h3 id="reset">5.11.1 reset</h3><h3 id="go">5.11.2 go</h3><h3 id="run">5.11.3 run</h3><h3 id="mtest">5.11.4 mtest</h3>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无人机地面站QT版</title>
      <link href="posts/f53accbe.html"/>
      <url>posts/f53accbe.html</url>
      
        <content type="html"><![CDATA[<p><strong>下载链接</strong><br><a href="https://github.com/flyghost/creekwater">源代码</a><br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20190903161741537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMzE0MTMz,size_16,color_FFFFFF,t_70" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无人机地面站VS版</title>
      <link href="posts/dacd2817.html"/>
      <url>posts/dacd2817.html</url>
      
        <content type="html"><![CDATA[<p><strong>界面如图所示，源代码如下</strong><br><a href="https://github.com/flyghost/phantom">源代码</a><br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20190903161003735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMzE0MTMz,size_16,color_FFFFFF,t_70" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="在这里插入图片描述"></p><p><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/2019090316103653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMzE0MTMz,size_16,color_FFFFFF,t_70" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="在这里插入图片描述"><br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/2019090316105021.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMzE0MTMz,size_16,color_FFFFFF,t_70" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu18.04-LTS搭建PX4编译环境</title>
      <link href="posts/1e83aa5d.html"/>
      <url>posts/1e83aa5d.html</url>
      
        <content type="html"><![CDATA[<p>这里先给出官方的教程<a href="http://dev.px4.io/zh/setup/dev_env_linux.html">px4环境搭建</a><br>由于个人按照官方的教程总是有各种问题，故总结几个必要的安装命令，环境也成功搭建</p><h1 id="安装python、git、qt">1 安装python、git、qt</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-argparse git-core wget zip \</span><br><span class="line">    python-empy qtcreator cmake build-essential genromfs -y</span><br></pre></td></tr></table></figure><h1 id="安装仿真软件和需要的库文件，注意体验下面两句的区别（一句代码后有-y-，一句没有）">2 安装仿真软件和需要的库文件，注意体验下面两句的区别（一句代码后有 -y ，一句没有）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openjdk-8-jre</span><br><span class="line">sudo apt-get install ant protobuf-compiler libeigen3-dev libopencv-dev openjdk-8-jdk openjdk-8-jre clang-3.5 lldb-3.5 -y</span><br></pre></td></tr></table></figure><h1 id="卸载modemmanager模式管理器">3 卸载modemmanager模式管理器</h1><p>Ubuntu配备了一系列代理管理，这会严重干扰相关的串口（或usb串口），最明显的表现就是硬件连接到PC机后，无法读出硬件，无法烧录上传固件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove modemmanager</span><br></pre></td></tr></table></figure><h1 id="更新、安装相关的库">4 更新、安装相关的库</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-serial openocd \</span><br><span class="line">    flex bison libncurses5-dev autoconf texinfo build-essential \</span><br><span class="line">    libftdi-dev libtool zlib1g-dev \</span><br><span class="line">    python-empy gcc-arm-none-eabi -y</span><br></pre></td></tr></table></figure><h1 id="安装正确版本的gcc-arm-none-eabi">5 安装正确版本的gcc-arm-none-eabi</h1><p>还记的上面出现的那个Failed吗？实际我们安装的gcc-arm-none-eabi版本不支持源码，所以需要安装正确的版本。输入一下代码可以查看gcc-arm-none-eabi版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-gcc --version</span><br></pre></td></tr></table></figure><h1 id="下载GCC4-9-4或5-4-3">6 下载GCC4.9.4或5.4.3</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接使用该命令下载也可以</span><br><span class="line">sudo apt-get install gcc-arm-none-eabi</span><br></pre></td></tr></table></figure><p>GCC4.9.4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;launchpad.net&#x2F;gcc-arm-embedded&#x2F;4.9&#x2F;4.9-2015-q3-update&#x2F;+download&#x2F;gcc-arm-none-eabi-4_9-2015q3-20150921-linux.tar.bz2</span><br></pre></td></tr></table></figure><p>GCC5.4.3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;launchpad.net&#x2F;gcc-arm-embedded&#x2F;5.0&#x2F;5-2016-q2-update&#x2F;+download&#x2F;gcc-arm-none-eabi-5_4-2016q2-20160622-linux.tar.bz2</span><br></pre></td></tr></table></figure><h1 id="安装GCC4-9-4">7 安装GCC4.9.4</h1><p>在压缩包同一路径下，新建一个xxx.sh文件，将下述代码法制到脚本文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pushd .</span><br><span class="line"># 卸载新版的gcc-arm-none-eabi</span><br><span class="line">sudo apt-get remove gcc-arm-none-eabi</span><br><span class="line"># 安装下载好的gcc-arm-none-eabi</span><br><span class="line"># 解压</span><br><span class="line">tar -jxf gcc-arm-none-eabi-4_9-2015q3-20150921-linux.tar.bz2</span><br><span class="line"># 移动</span><br><span class="line">sudo mv gcc-arm-none-eabi-4_9-2015q3 &#x2F;opt</span><br><span class="line">exportline&#x3D;&quot;export PATH&#x3D;&#x2F;opt&#x2F;gcc-arm-none-eabi-4_9-2015q3&#x2F;bin:\$PATH&quot;</span><br><span class="line">if grep -Fxq &quot;$exportline&quot; ~&#x2F;.profile; then echo nothing to do ; else echo $exportline &gt;&gt; ~&#x2F;.profile; fi</span><br><span class="line"># 使路径生效</span><br><span class="line">. ~&#x2F;.profile</span><br><span class="line">popd</span><br></pre></td></tr></table></figure><h1 id="或者安装GCC5-4-3">8 或者安装GCC5.4.3</h1><p>在压缩包同一路径下，新建一个xxx.sh文件，将下述代码法制到脚本文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pushd .</span><br><span class="line"># 卸载新版的gcc-arm-none-eabi</span><br><span class="line">sudo apt-get remove gcc-arm-none-eabi</span><br><span class="line"># 安装下载好的gcc-arm-none-eabi</span><br><span class="line"># 解压</span><br><span class="line">tar -jxf gcc-arm-none-eabi-5_4-2016q2-20160622-linux.tar.bz2</span><br><span class="line"># 移动</span><br><span class="line">sudo mv gcc-arm-none-eabi-5_4-2016q2 &#x2F;opt</span><br><span class="line">exportline&#x3D;&quot;export PATH&#x3D;&#x2F;opt&#x2F;gcc-arm-none-eabi-5_4-2016q2&#x2F;bin:\$PATH&quot;</span><br><span class="line">if grep -Fxq &quot;$exportline&quot; ~&#x2F;.profile; then echo nothing to do ; else echo $exportline &gt;&gt; ~&#x2F;.profile; fi</span><br><span class="line"># 使路径生效</span><br><span class="line">. ~&#x2F;.profile</span><br><span class="line">popd</span><br></pre></td></tr></table></figure><p>修改脚本执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x xxx.sh</span><br></pre></td></tr></table></figure><p>运行该脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;xxx.sh</span><br></pre></td></tr></table></figure><h1 id="编译源码">9 编译源码</h1><p>首先需要安装一个库文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lsb-core</span><br></pre></td></tr></table></figure><p>编译过程中需要安装其他库，在编译一文中有介绍<br>代码下载编译请见<br><strong><a href="https://blog.csdn.net/qq_20314133/article/details/90374584">px4编译</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCODE插件</title>
      <link href="posts/e9b78b5f.html"/>
      <url>posts/e9b78b5f.html</url>
      
        <content type="html"><![CDATA[<p>Bracket Pair Colorizer  括号颜色<br>c/c++ 支持<br>Chinese 中文支持<br>vscode-icons 设置文件图标主题<br>translate to chinese 翻译<br>下载字体：<a href="https://github.com/tonsky/FiraCode">https://github.com/tonsky/FiraCode</a><br>把下载的压缩包解压，然后找到ttf文件夹，全部选中，右键安装即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;editor.fontFamily&quot;: &quot;&#39;Fira Code&#39;, Consolas, &#39;Courier New&#39;, monospace&quot;,&#x2F;&#x2F;添加上FiraCode字体</span><br><span class="line">&quot;editor.fontLigatures&quot;: true,&#x2F;&#x2F;开启连体字</span><br></pre></td></tr></table></figure><p>如果配置完后，编辑器的内容没什么变化的话，重启一下就可以了</p><h1 id="VisualStudio代码无法监视此大工作区中的文件更改”-错误ENOSPC">1 VisualStudio代码无法监视此大工作区中的文件更改”(错误ENOSPC)</h1><p>当您看到此通知时，它指示VS代码文件监视程序正在耗尽句柄，因为工作区很大，并且包含许多文件。运行以下命令可以查看当前限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;inotify&#x2F;max_user_watches</span><br></pre></td></tr></table></figure><p>通过编辑，可以将限制提高到其最大值。/etc/sysctl.conf并将这一行添加到文件的末尾：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#打开</span><br><span class="line">sudo vim &#x2F;etc&#x2F;sysctl.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#添加该代码</span><br><span class="line">fs.inotify.max_user_watches&#x3D;524288</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#保存退出运行</span><br><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>px4编译</title>
      <link href="posts/7a082ea4.html"/>
      <url>posts/7a082ea4.html</url>
      
        <content type="html"><![CDATA[<p>如果下载速度特别慢，可以使用手机的4G网络</p><h1 id="位置确定">1 位置确定</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~&#x2F;src</span><br><span class="line">cd ~&#x2F;src</span><br></pre></td></tr></table></figure><h1 id="开始下载指定版本的px4，在这里是v1-8-2版本">2 开始下载指定版本的px4，在这里是v1.8.2版本</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v1.8.2 https:&#x2F;&#x2F;github.com&#x2F;PX4&#x2F;Firmware.git </span><br></pre></td></tr></table></figure><h1 id="添加子模块：">3 添加子模块：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd Firmware</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><h1 id="显示版本号">4 显示版本号</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe --always --tags</span><br></pre></td></tr></table></figure><h1 id="编译，缺什么安装什么">5 编译，缺什么安装什么</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make px4fmu-v2_default</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="安装jinja">6 安装jinja</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-jinja2</span><br></pre></td></tr></table></figure><h1 id="需要安装的pip">7 需要安装的pip</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-pip </span><br><span class="line">sudo pip install numpy toml</span><br></pre></td></tr></table></figure><h1 id="若提示以下错误：确保cmake安装，重启系统即可">8 若提示以下错误：确保cmake安装，重启系统即可</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMake Error: CMake was unable to find a build program corresponding to &quot;Unix Makefiles&quot;.</span><br></pre></td></tr></table></figure><h1 id="提示flash溢出">9 提示flash溢出</h1><p>1.注释掉不需要的模块（不怎么建议使用，后续会知道如何注释）；<br>2.修改默认的Flash大小。</p><p><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20190530150415678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMzE0MTMz,size_16,color_FFFFFF,t_70" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="在这里插入图片描述"><br>打开/Firmware/platforms/nuttx/nuttx-configs/px4fmu-v2/scripts/ld.script<br>修改如图所示1008为2032即可<br><img "" class="lazyload placeholder" data-original="https://img-blog.csdnimg.cn/20190530150537377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMzE0MTMz,size_16,color_FFFFFF,t_70" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低通滤波（一阶）</title>
      <link href="posts/3dbc53de.html"/>
      <url>posts/3dbc53de.html</url>
      
        <content type="html"><![CDATA[<p><strong>1. 一阶滤波算法的原理</strong><br>一阶滤波，又叫一阶惯性滤波，或一阶低通滤波。是使用软件编程实现普通硬件RC低通滤波器的功能。<br>一阶低通滤波的算法公式为：<br>                         Y(n)=(1-α) * Y(n-1) + αX(n)<br>  式中：α=滤波系数；X(n)=本次采样值；Y(n-1)=上次滤波输出值；Y(n)=本次滤波输出值。<br>一阶低通滤波法采用本次采样值与上次滤波输出值进行加权，得到有效滤波值，使得输出对输入有反馈作用。<br> <strong>2. 一阶滤波算法的程序（适用于单个采样）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define a   0.01                &#x2F;&#x2F; 滤波系数a（0-1）  </span><br><span class="line"> </span><br><span class="line">char value;                    &#x2F;&#x2F;滤波后的值 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输入：新的采样值</span><br><span class="line">&#x2F;&#x2F;输出：滤波后的值</span><br><span class="line">char filter(char new_value)   </span><br><span class="line">&#123;     </span><br><span class="line">    return （1-a）*value + a*new_value;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>3. 一阶滤波算法的不足</strong> </p><ol><li><p>关于灵敏度和平稳度的矛盾 </p><p>   滤波系数越小，滤波结果越平稳，但是灵敏度越低；<br>   滤波系数越大，灵敏度越高，但是滤波结果越不稳定。</p><p>  一阶滤波无法完美地兼顾灵敏度和平稳度。有时，我们只能寻找一个平衡，在可接受的灵敏度范围内取得尽可能好的平稳度。而在一些场合，我们希望拥有这样一种接近理想状态的滤波算法。即：<br>  当数据快速变化时，滤波结果能及时跟进（灵敏度优先）；<br>  当数据趋于稳定，在一个固定的点上下振荡时，滤波结果能趋于平稳（平稳度优先）。</p></li><li><p>关于小数舍弃带来的误差 </p><p>一阶滤波算法有一个鲜为人知的问题：小数舍弃带来的误差。 比如： 本次采样值=25，上次滤波结果=24，滤波系数=10， 根据滤波算法:<br>   本次滤波结果=(25<em>10+24</em>(256-10))/256=24.0390625<br>但是，我们在单片机运算中，很少采用浮点数。因此运算后的小数部分要么舍弃，要么进行四舍五入运算。这样一来，本例中的结果24.0390625就变成了24。假如每次采样值都=25，那么滤波结果永远=24。也就是说滤波结果和实际数据一直存在无法消除的误差</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波代码整理（一维）</title>
      <link href="posts/298ba0d1.html"/>
      <url>posts/298ba0d1.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct _1_ekf_filter</span><br><span class="line">&#123;</span><br><span class="line">float LastP;</span><br><span class="line">floatNow_P;</span><br><span class="line">float out;</span><br><span class="line">float Kg;</span><br><span class="line">float Q;</span><br><span class="line">float R;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void kalman_1(struct _1_ekf_filter *ekf,float input)  </span><br><span class="line">&#123;</span><br><span class="line">ekf-&gt;Now_P &#x3D; ekf-&gt;LastP + ekf-&gt;Q;</span><br><span class="line">ekf-&gt;Kg &#x3D; ekf-&gt;Now_P &#x2F; (ekf-&gt;Now_P + ekf-&gt;R);</span><br><span class="line">ekf-&gt;out &#x3D; ekf-&gt;out + ekf-&gt;Kg * (input - ekf-&gt;out);</span><br><span class="line">ekf-&gt;LastP &#x3D; (1-ekf-&gt;Kg) * ekf-&gt;Now_P ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用范例</span><br><span class="line">static struct _1_ekf_filter ekf &#x3D; &#123;0.02,0,0,0,0.001,0.543&#125;;&#x2F;&#x2F;初始化参数</span><br><span class="line">float pMpu;</span><br><span class="line">kalman_1(&amp;ekf,(float)pMpu);  </span><br><span class="line">pMpu &#x3D; (int16_t)ekf.out;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互补滤波</title>
      <link href="posts/85fa6466.html"/>
      <url>posts/85fa6466.html</url>
      
        <content type="html"><![CDATA[<p>最近在研究小四轴的飞行，姿态检测主要用到的传感器是MPU6050。从MPU6050读出来的加速度和角速度数据最后要转成姿态，可以转换成欧拉角（偏航角、俯仰角和滚转角）或四元数表示，为了减少计算量（欧拉角涉及正弦运算，运算量相对较大），方便在STM32主控上实现，可以转换成四元数表示。那么问题来了，四元数姿态融合算法哪家强？这里介绍圆点博士小四轴飞控开源代码关于四元数姿态融合的算法以及代码实现，不能说最强（国外有很多优秀的飞控算法），只是实现效果可以满足小四轴的成功飞行，个人水平渣渣，请大牛批评指正。博士的代码中主要用到的是互补滤波法。</p><p>   先介绍一下互补滤波的基本概念，这是阿莫论坛上一个会员的总结：对mpu6050来说，加速度计对四轴或小车的加速度比较敏感，取瞬时值计算倾角误差比较大；而陀螺仪积分得到的角度不受小车加速度的影响，但是随着时间的增加积分漂移和温度漂移带来的误差比较大。所以这两个传感器正好可以弥补相互的缺点。不过要怎么弥补呢？经过上面的介绍是否感觉到可以用滤波器做文章呢？这里讲的互补滤波就是在短时间内采用陀螺仪得到的角度做为最优，定时对加速度采样来的角度进行取平均值来校正陀螺仪的得到的角度。就是，短时间内用陀螺仪比较准确，以它为主；长时间用加速度计比较准确，这时候加大它的比重，这就是互补了，不过滤波在哪里？加速度计要滤掉高频信号，陀螺仪要滤掉低频信号，互补滤波器就是根据传感器特性不同，通过不同的滤波器（高通或低通，互补的），然后再相加得到整个频带的信号，例如，加速度计测倾角，其动态响应较慢，在高频时信号不可用，所以可通过低通抑制高频；陀螺响应快，积分后可测倾角，不过由于零漂等，在低频段信号不好。通过高通滤波可抑制低频噪声。将两者结合，就将陀螺和加表的优点融合起来，得到在高频和低频都较好的信号，互补滤波需要选择切换的频率点，即高通和低通的频率。</p><p>我个人觉得互补滤波在博士代码里的基本思想是以角速度积分得到角度为主进行姿态解算，但是由于周围环境或自身器件的原因，角速度计积分出来的角度可能会产生误差的累积，长时间可能引起严重的角度偏移，而加速度计虽然精度不高但没有积累误差，可以用来对角度进行纠正。实验证明，这种算法很好的消除了角度偏移。</p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无人机 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
